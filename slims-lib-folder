File Summary:

AlLibrarian.php: A class for logging librarian actions (login, logout, module access). Uses Monolog for logging to file or Elasticsearch.

AltoRouter.php: A URL routing class using AltoRouter.

AdvancedLogging.php: A class for advanced logging using Monolog, supporting file and Elasticsearch logging.

admin_logon.inc.php: A class for administrator authentication, supporting native and LDAP authentication. Uses BCRYPT password hashing.

autoload.php: An autoloader for SLiMS classes and external libraries.

biblio_list.inc.php: A class for displaying a list of bibliographic records, supporting CQL searching. Uses various search methods (MySQL, Elasticsearch, Sphinx).

api.inc.php: An API utility class for various functions, including retrieving bibliographic data and logging activities. Handles search index updates (Solr/Elasticsearch).

biblio_list_index.inc.php: A class for displaying a list of bibliographic records from the index table.

biblio_list_elasticsearch.inc.php: A class for displaying a list of bibliographic records from Elasticsearch.

biblio_list_model.inc.php: An abstract model class for displaying bibliographic record lists.

biblio_list_sphinx.inc.php: A class for displaying a list of bibliographic records from Sphinx.

biblio_list_sqlite.inc.php: A class for displaying a list of bibliographic records from SQLite.

biblio_list_mongodb.inc.php: A class for displaying a list of bibliographic records from MongoDB.

Cache.php: A class for cache management, supporting various providers (File, Redis, etc.).

circulation_api.inc.php: An API utility class for circulation functions (loans).

comment.inc.php: Functions for displaying and adding comments to bibliographic records. Supports third-party comment plugins.

Config.php: A class for managing application configuration, from both files and the database.

content.inc.php: A class for displaying content from the database.

content_custom.inc.php: A class for retrieving custom content from the database.

content_list.inc.php: A class for displaying a list of content items.

Currency.php: A class for currency formatting using NumberFormatter.

DB.php: A class for database management, supporting PDO and MySQLi. Provides database backup functionality.

detail.inc.php: A class for displaying bibliographic record details, supporting various output formats (HTML, XML, MODS, JSON-LD, MARC).

GroupMenu.php: A class to manage menus based on user groups.

GroupMenuOrder.php: A class to manage the order of menus within groups.

index.php: Redirects to the main application directory.

index.html: Redirects to the main application directory.

http_request.inc.php: A class for handling HTTP requests.

ip_based_access.inc.php: A script to restrict module access based on IP address.

helper.inc.php: A helper file containing various utility functions.

Ip.php: A class to get the client's IP address, taking proxies into account.

Jquery.php: A class for manipulating jQuery within PHP code.

Mail.php: A class for sending emails using PHPMailer, supporting email queuing.

marcxmlsenayan.inc.php: A function for parsing MARCXML files.

Json.php: A class for handling JSON encoding and decoding.

member_api.inc.php: An API utility class for membership functions.

member_logon.inc.php: A class for member authentication, supporting native and LDAP authentication. Uses BCRYPT password hashing.

member_session.inc.php: A script for managing member sessions.

modsxmlsenayan.inc.php: A function for parsing MODS XML files.

modsxmlslims.inc.php: A function for parsing MODS XML records.

module.inc.php: A class for managing application modules, including menu generation.

Number.php: A class for number manipulation.

oai-pmh.inc.php: A class for OAI-PMH web services.

Opac.php: The main class for the OPAC, handling routing and rendering of OPAC pages.

Plugins.php: A class for plugin management, including hook and menu registration.

phpwebsocket.php: A class for implementing a WebSocket server.

router.inc.php: A URL routing class using AltoRouter, customized for SLiMS.

Sanitizer.php: A class for sanitizing input data.

utility.inc.php: A utility class with various functions.

VideoStream.php: A class for video streaming.

Visitor.php: A class for recording visitor counts and limiting access.

Url.php: A class for URL manipulation.

  
-------------------------
File Summary: The lib directory contains the core SLiMS library files and several subdirectories housing external libraries and SLiMS modules.  The addition of subfolders suggests a modular architecture:

Subfolders and their likely contents:

Zend: Likely contains the Zend Framework libraries, providing a foundation for various SLiMS functionalities.

bacon: Likely contains the BaconQrCode library, used for generating QR codes.

Cache: Contains classes related to SLiMS's caching mechanisms. Cache.php manages different cache providers.

Captcha: Contains classes related to CAPTCHA implementation for security purposes.

Cli: Contains classes for command-line interface (CLI) tools and scripts for SLiMS.

collection: Likely contains classes for managing collections of bibliographic records.

contents: Contains the PHP files that generate the HTML content for various OPAC pages.

csrf: Contains classes related to Cross-Site Request Forgery (CSRF) protection.

Csv: Contains classes for handling CSV file import/export.

dasprid: Likely contains the DASPRiD Enum library for working with enums.

ezyang: Likely contains the HTML Purifier library by Ezyang, used for sanitizing HTML input.

Filesystems: Contains classes for file system management, likely using a library like League Flysystem.

flex: Likely contains code for integrating a flexbox CSS layout.

guzzlehttp: Contains the Guzzle HTTP client library, used for making external HTTP requests.

Http: Likely contains SLiMS custom classes for managing HTTP requests and responses.

lang: Contains language files for internationalization.

league: Likely contains various League libraries, such as Flysystem (filesystem abstraction) and MimeTypeDetection.

maennchen: Likely contains the ZipStream PHP library for creating zip archives on-the-fly.

Mail: Contains classes for managing email sending, likely using PHPMailer. Mail.php is the main email class.

marc: Likely contains classes for handling MARC records (bibliographic data format).

markbaker: Likely contains math libraries by Mark Baker (Complex and Matrix).

math: Contains math utilities.

Migration: Contains classes and scripts related to database migrations, likely using a library for managing database schema changes.

minigalnano: Likely contains the Mini Gal Nano image gallery library.

myclabs: Likely contains the MyCLabs Enum library for working with enums.

mysqldump-php: Contains the Ifsnop MySQLDump library for creating database backups.

nesbot: Likely contains the Carbon library for date and time manipulation.

oaipmh: Likely contains classes for implementing the Open Archives Initiative Protocol for Metadata Harvesting (OAI-PMH).

paragonie: Likely contains the ParagonIE ConstantTimeEncoding library for secure cryptographic operations.

Parcel: Might contain classes for handling packages or bundles of data.

parsedown: Likely contains the Parsedown library for Markdown parsing.

phpbarcode: Likely contains a PHP barcode generation library.

phplot: Likely contains the PHPlot library for creating charts and graphs.

PHPMailer: Contains the PHPMailer library for sending emails.

phpoffice: Likely contains the PHPSpreadsheet library for creating and manipulating spreadsheets.

phpseclib: Contains the phpseclib library for various cryptographic and networking functions.

psr: Likely contains PSR standard interfaces and implementations (e.g., PSR-16 Simple Cache).

ralouphie: Might contain the Ralouphie library for generating random strings or similar.

recaptcha: Contains classes related to reCAPTCHA integration.

SearchEngine: Contains classes for managing different search engine backends (e.g., Elasticsearch, Sphinx, etc.).

Session: Contains classes for session management, likely with support for different drivers (file, database, etc.).

sphinx: Likely contains classes for interacting with the Sphinx search server.

spomky-labs: Likely contains the OTP (One-Time Password) library.

symfony: Likely contains various Symfony components, such as the translation component or var_dumper.

Table: Contains classes for managing database tables and data manipulation.
  
uuid: Contains the Ramsey UUID library for generating UUIDs.

Total Files (excluding subfolders): 52

------------ files code (files in lib folder not include subfolder) ------------

=== File Combination Summary ===
Generated on: 2024-11-16 13:09:10.670618
Source directory: C:\Users\g1n\Documents\laragon\www\slims\lib
Included extensions: All
Excluded folders: pengumuman
================================================================================

================================================================================
File: AlLibrarian.php
================================================================================

<?php
namespace SLiMS;
/**
 * Advanced logging class for librarian action.
 * Copyright (C) 2020  Hendro Wicaksono (hendrowicaksono@gmail.com)
 * This program is free software;
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

class AlLibrarian extends AdvancedLogging
{
    private $librarian_actions = array ('login', 'logout', 'access');

    public function __construct ($code, $log_options = array())
    {
        if (!isset($log_options['username'])) {
            die('Not enough parameters.');
        } else {
            $this->msg = $log_options;
        }
        $this->setChannel('system');
        $this->setRole('librarian');
        $this->setCode($code);
        $this->setUuid();
        $this->setFrom();
        $this->setWhen();
        $this->setDesc();
        $this->writeLog($this->getDesc(), $this->getMsg());    

    }

    public function setDesc ()
    {
        switch ($this->getMsgVar('code')) {
            # 1xxx - 2000 for librarian activities
            # 1001 - 1100 for librarian activities directly related to system activities
            case '1001': # Librarian Login
                $this->desc =  $this->getMsgVar('username').' ('.$this->getMsgVar('role').') succeeded to login to application from address '.$this->getMsgVar('from').' at '.$this->getMsgVar('when');
            break;
            case '1003': # Librarian Logout
                $this->desc =  $this->getMsgVar('username').' ('.$this->getMsgVar('role').') succeeded to logout from application from address '.$this->getMsgVar('from').' at '.$this->getMsgVar('when');
            break;
            # 1101 - 1150 for librarian activities directly related to cross related modul
            case '1101': # Access main interface of each module
                $this->desc =  $this->getMsgVar('username').' ('.$this->getMsgVar('role').') accessed '.$this->getMsgVar('module').' module from address '.$this->getMsgVar('from').' at '.$this->getMsgVar('when');
            break;
            # 1151 - 1300 for librarian activities directly related to bibliography module activities
            case '1151': # List bibliography record
                $this->desc =  $this->getMsgVar('username').' ('.$this->getMsgVar('role').') list bibliography records from address '.$this->getMsgVar('from').' at '.$this->getMsgVar('when');
            break;
            case '1153': # show form for creating new bibliography
                $this->desc =  $this->getMsgVar('username').' ('.$this->getMsgVar('role').') show form for creating new bibliography record from address '.$this->getMsgVar('from').' at '.$this->getMsgVar('when');
            break;
            case '1155': # view bibliography record detail
                $this->desc =  $this->getMsgVar('username').' ('.$this->getMsgVar('role').') view bibliography record detail with biblio_id '.$this->getMsgVar('biblio_id').' from address '.$this->getMsgVar('from').' at '.$this->getMsgVar('when');
            break;
        }
    }

}
================================================================================
File: AltoRouter.php
================================================================================

<?php

class AltoRouter {

	/**
	 * @var array Array of all routes (incl. named routes).
	 */
	protected $routes = array();

	/**
	 * @var array Array of all named routes.
	 */
	protected $namedRoutes = array();

	/**
	 * @var string Can be used to ignore leading part of the Request URL (if main file lives in subdirectory of host)
	 */
	protected $basePath = '';

	/**
	 * @var array Array of default match types (regex helpers)
	 */
	protected $matchTypes = array(
		'i'  => '[0-9]++',
		'a'  => '[0-9A-Za-z]++',
		'h'  => '[0-9A-Fa-f]++',
		'*'  => '.+?',
		'**' => '.++',
		''   => '[^/\.]++'
	);

	/**
	  * Create router in one call from config.
	  *
	  * @param array $routes
	  * @param string $basePath
	  * @param array $matchTypes
	  */
	public function __construct( $routes = array(), $basePath = '', $matchTypes = array() ) {
		$this->addRoutes($routes);
		$this->setBasePath($basePath);
		$this->addMatchTypes($matchTypes);
	}
	
	/**
	 * Retrieves all routes.
	 * Useful if you want to process or display routes.
	 * @return array All routes.
	 */
	public function getRoutes() {
		return $this->routes;
	}

	/**
	 * Add multiple routes at once from array in the following format:
	 *
	 *   $routes = array(
	 *      array($method, $route, $target, $name)
	 *   );
	 *
	 * @param array $routes
	 * @return void
	 * @author Koen Punt
	 * @throws Exception
	 */
	public function addRoutes($routes){
		if(!is_array($routes) && !$routes instanceof Traversable) {
			throw new \Exception('Routes should be an array or an instance of Traversable');
		}
		foreach($routes as $route) {
			call_user_func_array(array($this, 'map'), $route);
		}
	}

	/**
	 * Set the base path.
	 * Useful if you are running your application from a subdirectory.
	 */
	public function setBasePath($basePath) {
		$this->basePath = $basePath;
	}

	/**
	 * Add named match types. It uses array_merge so keys can be overwritten.
	 *
	 * @param array $matchTypes The key is the name and the value is the regex.
	 */
	public function addMatchTypes($matchTypes) {
		$this->matchTypes = array_merge($this->matchTypes, $matchTypes);
	}

	/**
	 * Map a route to a target
	 *
	 * @param string $method One of 5 HTTP Methods, or a pipe-separated list of multiple HTTP Methods (GET|POST|PATCH|PUT|DELETE)
	 * @param string $route The route regex, custom regex must start with an @. You can use multiple pre-set regex filters, like [i:id]
	 * @param mixed $target The target where this route should point to. Can be anything.
	 * @param string $name Optional name of this route. Supply if you want to reverse route this url in your application.
	 * @throws Exception
	 */
	public function map($method, $route, $target, $name = null) {

		$this->routes[] = array($method, $route, $target, $name);

		if($name) {
			if(isset($this->namedRoutes[$name])) {
				throw new \Exception("Can not redeclare route '{$name}'");
			} else {
				$this->namedRoutes[$name] = $route;
			}

		}

		return;
	}

	/**
	 * Reversed routing
	 *
	 * Generate the URL for a named route. Replace regexes with supplied parameters
	 *
	 * @param string $routeName The name of the route.
	 * @param array @params Associative array of parameters to replace placeholders with.
	 * @return string The URL of the route with named parameters in place.
	 * @throws Exception
	 */
	public function generate($routeName, array $params = array()) {

		// Check if named route exists
		if(!isset($this->namedRoutes[$routeName])) {
			throw new \Exception("Route '{$routeName}' does not exist.");
		}

		// Replace named parameters
		$route = $this->namedRoutes[$routeName];
		
		// prepend base path to route url again
		$url = $this->basePath . $route;

		if (preg_match_all('`(/|\.|)\[([^:\]]*+)(?::([^:\]]*+))?\](\?|)`', $route, $matches, PREG_SET_ORDER)) {

			foreach($matches as $index => $match) {
				list($block, $pre, $type, $param, $optional) = $match;

				if ($pre) {
					$block = substr($block, 1);
				}

				if(isset($params[$param])) {
					// Part is found, replace for param value
					$url = str_replace($block, $params[$param], $url);
				} elseif ($optional && $index !== 0) {
					// Only strip preceeding slash if it's not at the base
					$url = str_replace($pre . $block, '', $url);
				} else {
					// Strip match block
					$url = str_replace($block, '', $url);
				}
			}

		}

		return $url;
	}

	/**
	 * Match a given Request Url against stored routes
	 * @param string $requestUrl
	 * @param string $requestMethod
	 * @return array|boolean Array with route information on success, false on failure (no match).
	 */
	public function match($requestUrl = null, $requestMethod = null) {

		$params = array();
		$match = false;

		// set Request Url if it isn't passed as parameter
		if($requestUrl === null) {
			$requestUrl = isset($_SERVER['REQUEST_URI']) ? $_SERVER['REQUEST_URI'] : '/';
		}

		// strip base path from request url
		$requestUrl = substr($requestUrl, strlen($this->basePath));

		// Strip query string (?a=b) from Request Url
		if (($strpos = strpos($requestUrl, '?')) !== false) {
			$requestUrl = substr($requestUrl, 0, $strpos);
		}

		// set Request Method if it isn't passed as a parameter
		if($requestMethod === null) {
			$requestMethod = isset($_SERVER['REQUEST_METHOD']) ? $_SERVER['REQUEST_METHOD'] : 'GET';
		}

		foreach($this->routes as $handler) {
			list($methods, $route, $target, $name) = $handler;

			$method_match = (stripos($methods, $requestMethod) !== false);

			// Method did not match, continue to next route.
			if (!$method_match) continue;

			if ($route === '*') {
				// * wildcard (matches all)
				$match = true;
			} elseif (isset($route[0]) && $route[0] === '@') {
				// @ regex delimiter
				$pattern = '`' . substr($route, 1) . '`u';
				$match = preg_match($pattern, $requestUrl, $params) === 1;
			} elseif (($position = strpos($route, '[')) === false) {
				// No params in url, do string comparison
				$match = strcmp($requestUrl, $route) === 0;
			} else {
				// Compare longest non-param string with url
				if (strncmp($requestUrl, $route, $position) !== 0) {
					continue;
				}
				$regex = $this->compileRoute($route);
				$match = preg_match($regex, $requestUrl, $params) === 1;
			}

			if ($match) {

				if ($params) {
					foreach($params as $key => $value) {
						if(is_numeric($key)) unset($params[$key]);
					}
				}

				return array(
					'target' => $target,
					'params' => $params,
					'name' => $name
				);
			}
		}
		return false;
	}

	/**
	 * Compile the regex for a given route (EXPENSIVE)
	 */
	protected function compileRoute($route) {
		if (preg_match_all('`(/|\.|)\[([^:\]]*+)(?::([^:\]]*+))?\](\?|)`', $route, $matches, PREG_SET_ORDER)) {

			$matchTypes = $this->matchTypes;
			foreach($matches as $match) {
				list($block, $pre, $type, $param, $optional) = $match;

				if (isset($matchTypes[$type])) {
					$type = $matchTypes[$type];
				}
				if ($pre === '.') {
					$pre = '\.';
				}

				$optional = $optional !== '' ? '?' : null;
				
				//Older versions of PCRE require the 'P' in (?P<named>)
				$pattern = '(?:'
						. ($pre !== '' ? $pre : null)
						. '('
						. ($param !== '' ? "?P<$param>" : null)
						. $type
						. ')'
						. $optional
						. ')'
						. $optional;

				$route = str_replace($block, $pattern, $route);
			}

		}
		return "`^$route$`u";
	}
}

================================================================================
File: AdvancedLogging.php
================================================================================

<?php
namespace SLiMS;
/**
 * Advanced logging class using monolog class
 * Copyright (C) 2020  Hendro Wicaksono (hendrowicaksono@gmail.com)
 * This program is free software;
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

use Monolog\Logger;
use Monolog\Handler\StreamHandler;
use Monolog\Handler\ElasticSearchHandler;
use Monolog\Formatter\FormatterInterface;
use Monolog\Formatter\ElasticsearchFormatter;
use Elasticsearch\Common\Exceptions\RuntimeException as ElasticsearchRuntimeException;
use Elasticsearch\Client;
use Ramsey\Uuid\Uuid;

class AdvancedLogging
{
    protected $msg = array();
    protected $desc;
    private $member_actions = array ('login', 'logout');
    private $allowed_status = array (0, 1);

    public function writeLog ($desc, $msg)
    {
        global $sysconf;
        if ($sysconf['log']['adv']['enabled']) {
            $log = new Logger('system');
            if ($sysconf['log']['adv']['handler'] == 'fs') {
                $log->pushHandler(new \Monolog\Handler\StreamHandler($sysconf['log']['adv']['path'].'/system.log', Logger::DEBUG));
            } elseif ($sysconf['log']['adv']['handler'] == 'es') {
                $client = \Elasticsearch\ClientBuilder::create()
                    ->setHosts(array($sysconf['log']['adv']['host']))
                    ->build();        
                $options = array(
                    'index' => $sysconf['log']['adv']['index'],
                    'type'  => '_doc',
                );
                $handler = new \Monolog\Handler\ElasticsearchHandler($client, $options);
                $log->pushHandler($handler);
            }
            $log->info($this->getDesc(), $this->getMsg());
        }
    }

    public function setChannel ($channel)
    {
        $this->msg['channel'] = $channel;
    }

    public function setRole ($role)
    {
        $this->msg['role'] = $role;
    }

    public function setCode ($code)
    {
        $this->msg['code'] = $code;
    }

    public function setUuid ()
    {
        $uuid = Uuid::uuid4();
        $this->msg['uuid'] =  $uuid->toString();
    }

    public function setUid ($uid)
    {
        $this->msg['uid'] = $uid;
    }

    public function setRealname ($realname)
    {
        $this->msg['realname'] = $realname;
    }

    public function setModule ($module)
    {
        $this->msg['module'] = $module;
    }

    public function setModuleAction ($module_action)
    {
        $this->msg['module_action'] = $module_action;
    }

    public function setWhen ()
    {
        $this->msg['when'] =  date('Y-m-d H:i:s');
    }

    public function setFrom ()
    {
        $this->msg['from'] =  $_SERVER['REMOTE_ADDR'];
    }

    public function getMsg ()
    {
        return $this->msg;
    }

    public function getMsgVar ($key)
    {
        return $this->msg[$key];
    }

    public function setDesc ()
    {
    }
    public function getDesc ()
    {
        return $this->desc;
    }
}
================================================================================
File: admin_logon.inc.php
================================================================================

<?php
/**
 * admin_logon class
 * Class for user authentication
 *
 * Copyright (C) 2007,2008  Arie Nugraha (dicarve@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} else if (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

class admin_logon
{
    private $obj_db = false;
    protected $username = '';
    protected $password = '';
    protected $auth_method = 'native';
    protected $user_info = array();
    public $real_name = '';
    public $ip_check = false;
    public $ip_allowed = array();
    public $errors = '';


    /**
     * Class Constructor
     *
     * @param   string  $str_username
     * @param   string  $str_password
     * @param   string  $str_auth_method
     * @return  void
     */
    public function __construct($str_username, $str_password, $str_auth_method = 'native') {
        $this->username = trim($str_username);
        $this->password = trim($str_password);
        $this->auth_method = $str_auth_method;
    }


    /**
     * Method to check user validity
     *
     * @param   object  $obj_db
     * @return  void
     */
    public function adminValid($obj_db) {
        $this->obj_db = $obj_db;
        $_check_login = call_user_func(array($this, $this->auth_method.'Login'));
        // check if the user exist in database
        if (!$_check_login) {
            return false;
        }

        // if the ip checking is enabled
        if ($this->ip_check) {
            if (!in_array(ip(), $this->ip_allowed)) {
                $this->errors = 'IP not allowed to login';
                return false;
            }
        }

        // update the last login time
        $obj_db->query("UPDATE user SET last_login='".date("Y-m-d H:i:s")."',
            last_login_ip='".ip()."'
            WHERE user_id=".$this->user_info['user_id']);

        return true;
    }

    function setupSession($obj_db)
    {
        global $sysconf;
        $this->real_name = $this->user_info['realname'];
        // fill all sessions var
        $_SESSION['uid'] = $this->user_info['user_id'];
        $_SESSION['uname'] = $this->user_info['username'];
        $_SESSION['realname'] = $this->user_info['realname'];
        //modified by Eddy Subratha
        if (!empty($this->user_info['user_image'])) {
            $_SESSION['upict'] = $this->user_info['user_image'];                    
        } else {
            $_SESSION['upict'] = 'person.png';        
        }
        if (!empty($this->user_info['groups'])) {
            $_SESSION['groups'] = @unserialize($this->user_info['groups']);
            // fetch group privileges
            foreach ($_SESSION['groups'] as $group_id) {
                $_priv_q = $obj_db->query("SELECT ga.*,mdl.module_path FROM group_access AS ga
                    LEFT JOIN mst_module AS mdl ON ga.module_id=mdl.module_id WHERE ga.group_id=$group_id");
                while ($_priv_d = $_priv_q->fetch_assoc()) {
                    if ($_priv_d['r']) {
                        $_SESSION['priv'][$_priv_d['module_path']]['r'] = true;
                    }
                    if ($_priv_d['w']) {
                        $_SESSION['priv'][$_priv_d['module_path']]['w'] = true;
                    }
                    if ($_priv_d['menus']) {
                        $submenus = json_decode($_priv_d['menus'], true);
                        if (isset($_SESSION['priv'][$_priv_d['module_path']]['menus'])) {
                            $_SESSION['priv'][$_priv_d['module_path']]['menus'] = array_unique(array_merge($submenus, $_SESSION['priv'][$_priv_d['module_path']]['menus']));
                        } else {
                            $_SESSION['priv'][$_priv_d['module_path']]['menus'] = $submenus;
                        }
                    }
                }
            }
        } else {
            $_SESSION['groups'] = null;
        }

        $_SESSION['logintime'] = time();
        // session vars needed by some application modules
        $_SESSION['temp_loan'] = array();
        $_SESSION['biblioAuthor'] = array();
        $_SESSION['biblioTopic'] = array();
        $_SESSION['biblioAttach'] = array();

        if (!defined('UCS_VERSION')) {
            // load holiday data from database
            $_holiday_dayname_q = $obj_db->query('SELECT holiday_dayname FROM holiday WHERE holiday_date IS NULL');
            $_SESSION['holiday_dayname'] = array();
            while ($_holiday_dayname_d = $_holiday_dayname_q->fetch_row()) {
                $_SESSION['holiday_dayname'][] = $_holiday_dayname_d[0];
            }

            $_holiday_date_q = $obj_db->query('SELECT holiday_date FROM holiday WHERE holiday_date IS NOT NULL
                ORDER BY holiday_date DESC LIMIT 365');
            $_SESSION['holiday_date'] = array();
            while ($_holiday_date_d = $_holiday_date_q->fetch_row()) {
                $_SESSION['holiday_date'][$_holiday_date_d[0]] = $_holiday_date_d[0];
            }
        }

        // save md5sum of  current application path
        if ($sysconf['load_balanced_env']) {
            $server_addr = ip();
        } else {
            $server_addr = isset($_SERVER['SERVER_ADDR']) ? $_SERVER['SERVER_ADDR'] : (isset($_SERVER['LOCAL_ADDR']) ? $_SERVER['LOCAL_ADDR'] : gethostbyname($_SERVER['SERVER_NAME']));
        }
        $_SESSION['checksum'] = defined('UCS_BASE_DIR')?md5($server_addr.UCS_BASE_DIR.'admin'):md5($server_addr.SB.'admin');
    }

    function setUserInfo($user_info)
    {
        $this->user_info = $user_info;
    }

    function getUserInfo($key = null)
    {
        if (!is_null($key)) return $this->user_info[$key] ?? null;
        return $this->user_info;
    }


    /**
     * LDAP/Active directory login
     *
     * @return  boolean
     */
    protected function ldapLogin() {
        global $ldap_configs;
        if (!function_exists('ldap_connect')) {
            $this->errors = 'LDAP library is not installed yet!';
            return false;
        }
        // connect to Directory Server
        $_ds = $ldap_configs['ldap_port']?ldap_connect($ldap_configs['ldap_server'], $ldap_configs['ldap_port']):ldap_connect($ldap_configs['ldap_server']);

        // check LDAP options
        if ($ldap_configs['ldap_options']) {
            foreach ($ldap_configs['ldap_options'] as $_opt) {
                @ldap_set_option($_ds, $_opt[0], $_opt[1]);
            }
        }

        // LDAP Connection check
        if (!$_ds) {
            $this->errors = 'Failed to connect to LDAP server';
            return false;
        }

        // binding
        $_bind = @ldap_bind($_ds,
            str_ireplace('#loginUserName', $this->username, $ldap_configs['ldap_bind_dn']),
            $this->password);

        if (!$_bind) {
            $this->errors = 'Failed to bind to directory server!';
            return false;
        }

        $_filter = str_ireplace('#loginUserName', $this->username, $ldap_configs['ldap_search_filter']);

        // run query
        // $_search = @ldap_search($_ds, $ldap_configs['ldap_base_dn'], $_filter);
        $_search = @ldap_search($_ds, str_ireplace('#loginUserName', $this->username, $ldap_configs['ldap_bind_dn']), $_filter);
        if (!$_search) {
            $this->errors = 'LDAP search failed because of error!';
            return false;
        }

        // get query entry
        $_entries = @ldap_get_entries($_ds, $_search);
        if ($_entries) {
            $_username = $_entries[0][$ldap_configs['userid_field']][0];
            // check if User data exists in database
            $_check_q = $this->obj_db->query("SELECT u.user_id, u.username, u.realname, u.groups
                FROM user AS u WHERE u.username='".$_username."'");
            if ($_check_q->num_rows < 1) {
                $this->errors = 'You don\'t have enough privileges to enter this section!';
                return false;
            } else {
                $this->user_info = $_check_q->fetch_assoc();
            }
        } else {
            $this->errors = 'LDAP Record not found!';
            return false;
        }

        // closing connection
        ldap_close($_ds);
        return true;
    }


    /**
     * Native database checking login method
     *
     * @return  boolean
     */
    protected function nativeLogin() {
        /*
        $_sql_librarian_login = sprintf("SELECT
            u.user_id, u.username,
            u.realname, u.groups, u.user_image
            FROM user AS u
            WHERE u.username='%s'
                AND u.passwd=MD5('%s')", $this->obj_db->escape_string($this->username), $this->obj_db->escape_string($this->password));
        */
        $_sql_librarian_login = sprintf("SELECT
            u.user_id, u.username, u.passwd,
            u.realname, u.groups, u.user_image, u.2fa
            FROM user AS u
            WHERE u.username='%s'", $this->obj_db->escape_string($this->username));
        $_user_q = $this->obj_db->query($_sql_librarian_login);
    
        // error check
        if ($this->obj_db->error) {
            $this->errors = 'Failed to query user data from database with error: '.$this->obj_db->error;
            return false;
        }
        
        // result check
        if ($_user_q->num_rows < 1) {            
            $this->errors = 'Username not exists in database!';
            return false;
        }
        
        // get user info
        $this->user_info = $_user_q->fetch_assoc();
        // verify password hash
        $verified = password_verify($this->password, $this->user_info['passwd']);
        if (!$verified) {
            // maybe still use md5 encryption
            if ($this->nativeLoginMd5()) {
                $this->errors = array('status' => 'md5_encryption', 'uname' => $this->user_info['username']);
            } else {
                $this->errors = 'Username or Password not exists in database!';
            }
            return false;
        }
        return true;
    }

    /**
     * Native database checking login method with md5 encryption
     *
     * @return  boolean
     */
    protected function nativeLoginMd5() {
        $_sql_librarian_login = sprintf("SELECT
            u.user_id, u.username,
            u.realname, u.groups, u.2fa
            FROM user AS u
            WHERE u.username='%s'
                AND u.passwd=MD5('%s')", $this->obj_db->escape_string($this->username), $this->obj_db->escape_string($this->password));
        $_user_q = $this->obj_db->query($_sql_librarian_login);
        // error check
        if ($this->obj_db->error) {
            $this->errors = 'Failed to query user data from database with error: '.$this->obj_db->error;
            return false;
        }
        // result check
        if ($_user_q->num_rows < 1) {
            $this->errors = 'Username or Password not exists in database!';
            return false;
        }
        return true;
    }

    /**
     * Update password if still use md5 encryption
     *
     * @return  boolean
     */
    public function changePasswd($obj_db, $new_passwd)
    {
        $this->obj_db = $obj_db;

        if ($this->nativeLoginMd5()) {
            $_sql_update_password = sprintf("UPDATE user SET passwd = '%s', last_update = CURDATE() WHERE username = '%s'",
                password_hash($new_passwd, PASSWORD_BCRYPT), $this->username);
            $_update_q = $this->obj_db->query($_sql_update_password);
            // error check
            if ($this->obj_db->error) {
                $this->errors = 'Failed to query user data from database with error: '.$this->obj_db->error;
                return false;
            }
            return true;
        }
        $this->errors = 'Incorect current password!';
        return false;
    }
}

================================================================================
File: autoload.php
================================================================================

<?php
/**
 * @Created by          : Waris Agung Widodo (ido.alit@gmail.com)
 * @Date                : 24/03/20 11.21
 * @File name           : autoload.php
 *
 * Original source code : https://stackoverflow.com/a/39774973
 */

$namespaces = [
    "SLiMS\\" => "/",
    "Slims\\Opac\\" => "../src/Slims/Opac",
    "Volnix\\CSRF\\" => "/csrf/src/",
    "Commands\\" => "../plugins/Commands/",
    "Psr\\SimpleCache\\" => "/psr/simple-cache/src/",
    "PhpOffice\\PhpSpreadsheet\\" => "/phpoffice/phpspreadsheet/src/PhpSpreadsheet/",
    "Ramsey\\Uuid\\" => "/uuid/src/",
    "Ramsey\\Collection\\" => "/collection/src/",
    "Brick\\Math\\" => "/math/src/",
    "Ifsnop\\Mysqldump\\" => "/mysqldump-php/src/Ifsnop/Mysqldump/",
    "PHPMailer\\PHPMailer\\" => "/PHPMailer/src/",
    "GuzzleHttp" => "/guzzlehttp/guzzle/src",
    "GuzzleHttp\\Psr7\\" => "/guzzlehttp/psr7/src",
    "GuzzleHttp\\Exception\\" => "/guzzle/src/",
    "GuzzleHttp\Promise" => "/guzzlehttp/promises/src",
    "Psr\\Http\\Message\\" => "/psr/http-message/src",
    "Psr\\Http\\Client\\" => "/psr/http-client/src",
    "Complex\\" => "/markbaker/comples/classes/src/",
    "Matrix\\" => "/markbaker/matrix/classes/src/",
    "MyCLabs\\Enum\\" => "/myclabs/php-enum/src/",
    "Symfony\\Polyfill\\Mbstring\\" => "/symfony/polyfill-mbstring/",
    "Symfony\\Component\\Translation\\" => "/symfony/translation/",
    "Symfony\\Component\VarDumper\\" => "/symfony/var-dumper/",
    "Symfony\Component\Console\\" => '/symfony/console/',
    "Symfony\Component\String\\" => '/symfony/string/',
    "Symfony\Contracts\Service\\" => '/symfony/service-contracts/',
    "Symfony\\Contracts\\Translation\\" => "/symfony/translation-contracts/",
    "ZipStream\\" => "/maennchen/zipstream-php/src/",
    "Carbon\\" => "/nesbot/carbon/src/Carbon/",
    "Minigalnano\\" => "/minigalnano/",
    "League\\Flysystem\\" => "/league/flysystem/src/",
    "League\\MimeTypeDetection\\" => "/league/mime-type-detection/src/",
    "phpseclib3\\" => "/phpseclib/phpseclib/phpseclib/",
    'ParagonIE\\ConstantTime\\' => '/paragonie/constant_time_encoding/src',
    'OTPHP\\' => '/spomky-labs/otphp/src',
    'DASPRiD\\Enum\\' => '/dasprid/enum/src',
    'BaconQrCode\\' => '/bacon/bacon-qr-code/src',
];

$class_alias = [];
if (file_exists($classAliasPath = __DIR__ . '/../config/class_alias.php')) $class_alias = require $classAliasPath;

foreach ($namespaces as $namespace => $classpaths) {
    if (!is_array($classpaths)) {
        $classpaths = array($classpaths);
    }
    spl_autoload_register(function ($classname) use ($namespace, $classpaths, $class_alias) {
        if (preg_match("#^" . preg_quote($namespace) . "#", $classname)) {
            $classname = str_replace($namespace, "", $classname);
            $filename = preg_replace("#\\\\#", "/", $classname) . ".php";
            foreach ($classpaths as $classpath) {
                $fullpath = __DIR__ . "/" . $classpath . "/$filename";
                if (file_exists($fullpath)) include_once $fullpath;
            }
        } elseif (isset($class_alias[$classname]) && class_exists($class_alias[$classname])) {
            class_alias($class_alias[$classname], $classname);
        }
    });
}

/*
 |--------------------------------------------------------------------------
 | Load library with self autoload
 |--------------------------------------------------------------------------
 */
// Ezyang
include "ezyang/htmlpurifier/library/HTMLPurifier.auto.php";
// Symfony
include "symfony/polyfill-mbstring/bootstrap.php";
// Nesbot legacy function
include "nesbot/carbon/legacy.func.php";
// Var-dumper
// Load the global dump() function
include 'symfony/var-dumper/Resources/functions/dump.php';
================================================================================
File: biblio_list.inc.php
================================================================================

<?php
/**
 * biblio_list class
 * Class for generating list of bibliographic records
 *
 * Copyright (C) 2009 Arie Nugraha (dicarve@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
  die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
  die("can not access this file directly");
}

class biblio_list extends biblio_list_model {
  protected $searchable_fields = array('title', 'author', 'subject', 'isbn',
		'publisher', 'gmd', 'notes', 'colltype', 'publishyear',
		'location', 'itemcode', 'callnumber', 'itemcallnumber', 'notes');
  protected $field_join_type = array('title' => 'OR', 'author' => 'OR', 'subject' => 'OR');


  /**
   * Class Constructor
   *
   * @param   object  $obj_db
   * @param   integer	$int_num_show
   */
  public function __construct($obj_db, $int_num_show) {
    parent::__construct($obj_db, $int_num_show);
  }


  /**
   * Method to set search criteria
   *
   * @param   string  $str_criteria
   * @return  void
   */
  public function setSQLcriteria($str_criteria) {
    if (!$str_criteria)
      return null;
    // defaults
    $_sql_criteria = '';
    $_searched_fields = array();
    $_title_buffer = '';
    $_previous_field = '';
    $_boolean = '';
    // parse query
    $this->orig_query = $str_criteria;
    $_queries = simbio_tokenizeCQL($str_criteria, $this->searchable_fields, $this->stop_words, $this->queries_word_num_allowed);
    // echo '<pre>'; var_dump($_queries); echo '</pre>';
    if (count($_queries) < 1) {
      return null;
    }
    // loop each query
    foreach ($_queries as $_num => $_query) {
      // field
      $_field = $_query['f'];
      // for debugging purpose only
      // echo "<p>$_num. $_field -> $_boolean -> $_sql_criteria</p><p>&nbsp;</p>";
      // boolean
      if ($_title_buffer == '' && $_field != 'boolean') {
        $_sql_criteria .= " $_boolean ";
      }
      // $_sql_criteria .= " $_boolean ";
      // flush title string concatenation
      if ($_field != 'title' && $_title_buffer != '') {
        $_title_buffer = trim($_title_buffer);
        $_sql_criteria .= " biblio.biblio_id IN(SELECT DISTINCT biblio_id FROM biblio WHERE MATCH (title, series_title) AGAINST ('$_title_buffer' IN BOOLEAN MODE)) ";
        // reset title buffer
        $_title_buffer = '';
      }
      //  break the loop if we meet `cql_end` field
      if ($_field == 'cql_end') { break; }
      // boolean mode
      $_b = isset($_query['b'])?$_query['b']:$_query;
      if ($_b == '*') {
        $_boolean = 'OR';
      } else { $_boolean = 'AND'; }
      // search value
      $_q = @$this->obj_db->escape_string($_query['q']);
			$_searched_word = str_replace(array('+', '-', '*'), '', $_q);
			$this->words[$_searched_word] = $_searched_word;
      // searched fields flag set
      $_searched_fields[$_field] = 1;
      $_previous_field = $_field;
      // check field
      if ($_field == 'title') {
        if (strlen($_q) < 4) {
          $_previous_field = 'title_short';
          $_sql_criteria .= " biblio.title LIKE '%$_q%' ";
          $_title_buffer = '';
        } else {
          if (isset($_query['is_phrase'])) {
            $_title_buffer .= ' '.$_b.'"'.$_q.'"';
          } else {
            $_title_buffer .= ' '.$_b.$_q;
          }
        }
      } else if ($_field == 'author') {
        if ($_b == '-') {
          $_sql_criteria .= " biblio.biblio_id NOT IN(SELECT ba.biblio_id FROM biblio_author AS ba"
            ." LEFT JOIN mst_author AS a ON ba.author_id=a.author_id"
            ." WHERE author_name LIKE '%$_q%')";
        } else {
          $_sql_criteria .= " biblio.biblio_id IN(SELECT ba.biblio_id FROM biblio_author AS ba"
            ." LEFT JOIN mst_author AS a ON ba.author_id=a.author_id"
            ." WHERE author_name LIKE '%$_q%')";
        }
      } else if ($_field == 'subject') {
        if ($_b == '-') {
          $_sql_criteria .= " biblio.biblio_id NOT IN(SELECT bt.biblio_id FROM biblio_topic AS bt"
            ." LEFT JOIN mst_topic AS t ON bt.topic_id=t.topic_id"
            ." WHERE topic LIKE '%$_q%')";
        } else {
          $_sql_criteria .= " biblio.biblio_id IN(SELECT bt.biblio_id FROM biblio_topic AS bt"
            ." LEFT JOIN mst_topic AS t ON bt.topic_id=t.topic_id"
            ." WHERE topic LIKE '%$_q%')";
        }
        // reset title buffer
        $_title_buffer = '';
      } else {
        switch ($_field) {
          case 'location' :
			if (!$this->disable_item_data) {
			  $_subquery = 'SELECT location_id FROM mst_location WHERE location_name=\''.$_q.'\'';
			  if ($_b == '-') {
				  $_sql_criteria .= " item.location_id NOT IN ($_subquery)";
			  } else { $_sql_criteria .= " item.location_id IN ($_subquery)"; }
			} else {
			  if ($_b == '-') {
				  $_sql_criteria .= " biblio.node_id !='$_q'";
			  } else { $_sql_criteria .= " biblio.node_id = '$_q'"; }
			}
            break;
          case 'colltype' :
			if (!$this->disable_item_data) {
			  $_subquery = 'SELECT coll_type_id FROM mst_coll_type WHERE coll_type_name=\''.$_q.'\'';
			  if ($_b == '-') {
				  $_sql_criteria .= " item.coll_type_id NOT IN ($_subquery)";
			  } else { $_sql_criteria .= " item.coll_type_id IN ($_subquery)"; }
			}
            break;
          case 'itemcode' :
			if (!$this->disable_item_data) {
			  if ($_b == '-') {
				$_sql_criteria .= " item.item_code != '$_q'";
			  } else { $_sql_criteria .= " item.item_code LIKE '$_q%'"; }
			}
            break;
          case 'callnumber' :
            if ($_b == '-') {
              $_sql_criteria .= ' biblio.call_number NOT LIKE \''.$_q.'%\'';
            } else { $_sql_criteria .= ' biblio.call_number LIKE \''.$_q.'%\''; }
            break;
          case 'itemcallnumber' :
			if (!$this->disable_item_data) {
			  if ($_b == '-') {
				  $_sql_criteria .= ' item.call_number NOT LIKE \''.$_q.'%\'';
			  } else { $_sql_criteria .= ' item.call_number LIKE \''.$_q.'%\''; }
			}
            break;
          case 'class' :
            if ($_b == '-') {
              $_sql_criteria .= ' biblio.classification NOT LIKE \''.$_q.'%\'';
            } else { $_sql_criteria .= ' biblio.classification LIKE \''.$_q.'%\''; }
            break;
          case 'isbn' :
            if ($_b == '-') {
              $_sql_criteria .= ' biblio.isbn_issn!=\''.$_q.'\'';
            } else { $_sql_criteria .= ' biblio.isbn_issn=\''.$_q.'\''; }
            break;
          case 'publisher' :
            $_subquery = 'SELECT publisher_id FROM mst_publisher WHERE publisher_name LIKE \'%'.$_q.'%\'';
            if ($_b == '-') {
              $_sql_criteria .= " biblio.publisher_id NOT IN ($_subquery)";
            } else { $_sql_criteria .= " biblio.publisher_id IN ($_subquery)"; }
            break;
          case 'publishyear' :
            if ($_b == '-') {
              $_sql_criteria .= ' biblio.publish_year!=\''.$_q.'\'';
            } else { $_sql_criteria .= ' biblio.publish_year=\''.$_q.'\''; }
            break;
          case 'gmd' :
            $_subquery = 'SELECT gmd_id FROM mst_gmd WHERE gmd_name=\''.$_q.'\'';
            if ($_b == '-') {
              $_sql_criteria .= " biblio.gmd_id NOT IN ($_subquery)";
            } else { $_sql_criteria .= " biblio.gmd_id IN ($_subquery)"; }
            break;
          case 'notes' :
			      $_q = isset($_query['is_phrase'])?'"'.$_q.'"':$_q;
            if ($_b == '-') {
              $_sql_criteria .= " NOT (MATCH (biblio.notes) AGAINST ('".$_q."' IN BOOLEAN MODE))";
            } else { $_sql_criteria .= " (MATCH (biblio.notes) AGAINST ('".$_q."' IN BOOLEAN MODE))"; }
            break;
        }
      }
    }

    // remove boolean's logic symbol prefix and suffix
    $_sql_criteria = preg_replace('@^(AND|OR|NOT)\s*|\s+(AND|OR|NOT)$@i', '', trim($_sql_criteria));
    // below for debugging purpose only
    // echo "<div style=\"border: 1px solid #f00; padding: 5px; color: #f00; margin: 5px;\">$_sql_criteria</div>";

    $this->criteria = array('sql_criteria' => $_sql_criteria, 'searched_fields' => $_searched_fields);
    return $this->criteria;
  }


  /**
   * Method to print out document records
   *
   * @param   object  $obj_db
   * @param   integer $int_num2show
   * @param   boolean $bool_return_output
   * @return  string
   */
  public function compileSQL() {
    global $sysconf;
    // get page number from http get var
    if (!isset($_GET['page']) OR $_GET['page'] < 1){
      $_page = 1;
    } else{
      $_page = (integer)$_GET['page'];
    }
    $this->current_page = $_page;

    // count the row offset
    if ($_page <= 1) {
      $_offset = 0;
    } else {
      $_offset = ($_page*$this->num2show) - $this->num2show;
    }

    // init sql string
    $_sql_str = 'SELECT SQL_CALC_FOUND_ROWS biblio.biblio_id, biblio.title, biblio.image, biblio.isbn_issn,
			biblio.publish_year, pbl.publisher_name AS `publisher`, pplc.place_name AS `publish_place`, biblio.labels, biblio.input_date';

    // checking custom frontpage fields file
    $custom_frontpage_record_file = SB.$sysconf['template']['dir'].'/'.$sysconf['template']['theme'].'/custom_frontpage_record.inc.php';
    if (file_exists($custom_frontpage_record_file)) {
      include $custom_frontpage_record_file;
      $this->enable_custom_frontpage = true;
      $this->custom_fields = $custom_fields;
      foreach ($this->custom_fields as $_field => $_field_opts) {
        if ($_field_opts[0] == 1 && !in_array($_field, array('availability', 'isbn_issn'))) {
          $_sql_str .= ", biblio.$_field";
        }
      }
    }

    // additional SQL string
    $_add_sql_str = ' LEFT JOIN mst_publisher AS pbl ON biblio.publisher_id=pbl.publisher_id ';
    $_add_sql_str .= ' LEFT JOIN mst_place AS pplc ON biblio.publish_place_id=pplc.place_id ';

    // location
    if ($this->criteria) {
      if (isset($this->criteria['searched_fields']['location']) || isset($this->criteria['searched_fields']['colltype'])) {
        if (!$this->disable_item_data) {
		  $_add_sql_str .= ' LEFT JOIN item ON biblio.biblio_id=item.biblio_id ';
		}
      }
    }

    $_add_sql_str .= ' WHERE opac_hide=0 ';
    // promoted flag
    // if ($this->only_promoted) { $_add_sql_str .= ' AND promoted=1'; }
    // main search criteria
    if (isset($this->criteria['sql_criteria']) && $this->criteria['sql_criteria']!='') {
      $_add_sql_str .= ' AND ('.$this->criteria['sql_criteria'].') ';
    }

    $_sql_str .= ' FROM biblio '.$_add_sql_str.' ORDER BY biblio.last_update DESC LIMIT '.$_offset.', '.$this->num2show;
    // for debugging purpose only
    // echo "<div style=\"border: 1px solid navy; padding: 5px; color: navy; margin: 5px;\">$_sql_str</div>";
	  return $_sql_str;
  }
}

================================================================================
File: api.inc.php
================================================================================

<?php
/**
 * API class
 * A Collection of API static utility methods
 *
 * Copyright (C) 2016  Hendro Wicaksono (hendrowicaksono@gmail.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

class api
{
  #Bibliographic modules related
  /**
   * Static Method to load collection/bibliography data from database
   *
   * @param   object  $obj_db
   * @param   integer  $biblio_id
   * @return  array or false
   */
  public static function biblio_load($obj_db, $biblio_id)
  {
    global $sysconf;
    $_return = FALSE;
    $i = 0;
    $s_bib = 'SELECT mg.gmd_name, mp.publisher_name, ml.language_name, ';
    $s_bib .= 'ma.place_name, mf.frequency, ct.content_type, mt.media_type, ';
    $s_bib .= 'ca.carrier_type, b.* ';
    $s_bib .= 'FROM biblio AS b ';
    $s_bib .= 'LEFT JOIN mst_gmd AS mg ON b.gmd_id=mg.gmd_id ';
    $s_bib .= 'LEFT JOIN mst_publisher AS mp ON b.publisher_id=mp.publisher_id ';
    $s_bib .= 'LEFT JOIN mst_language AS ml ON b.language_id=ml.language_id ';
    $s_bib .= 'LEFT JOIN mst_place AS ma ON b.publish_place_id=ma.place_id ';
    $s_bib .= 'LEFT JOIN mst_frequency AS mf ON b.frequency_id=mf.frequency_id ';
    $s_bib .= 'LEFT JOIN mst_content_type AS ct ON b.content_type_id=ct.id ';
    $s_bib .= 'LEFT JOIN mst_media_type AS mt ON b.media_type_id=mt.id ';
    $s_bib .= 'LEFT JOIN mst_carrier_type AS ca ON b.carrier_type_id=ca.id ';
    $s_bib .= 'WHERE b.biblio_id=\''.$biblio_id.'\'';
    $s_bib .= '';
    $q_bib = $obj_db->query($s_bib);
    if (!$obj_db->errno) {
      $_return = [];
      while ($r_bib = $q_bib->fetch_assoc()) {
        $_return['id'] = $r_bib['biblio_id'];
        $_return['_id'] = $r_bib['biblio_id'];
        $_return['biblio_id'] = $r_bib['biblio_id'];
        $_return['title'] = $r_bib['title'];
        $_return['gmd_name'] = $r_bib['gmd_name'];
        $_return['sor'] = $r_bib['sor'];
        $_return['edition'] = $r_bib['edition'];
        $_return['isbn_issn'] = $r_bib['isbn_issn'];
        $_return['publisher_name'] = $r_bib['publisher_name'];
        $_return['publish_year'] = $r_bib['publish_year'];
        $_return['collation'] = $r_bib['collation'];
        $_return['series_title'] = $r_bib['series_title'];
        $_return['call_number'] = $r_bib['call_number'];
        $_return['language_name'] = $r_bib['language_name'];
        $_return['source'] = $r_bib['source'];
        $_return['place'] = $r_bib['place_name'];
        $_return['classification'] = $r_bib['classification'];
        $_return['notes'] = $r_bib['notes'];
        $_return['image'] = $r_bib['image'];
        $_return['opac_hide'] = $r_bib['opac_hide'];
        $_return['promoted'] = $r_bib['promoted'];
        $_return['labels'] = $r_bib['labels'];
        $_return['frequency'] = $r_bib['frequency'];
        $_return['spec_detail_info'] = $r_bib['spec_detail_info'];
        $_return['content_type'] = $r_bib['content_type'];
        $_return['media_type'] = $r_bib['media_type'];
        $_return['carrier_type'] = $r_bib['carrier_type'];
        #$_return['input_date'] = $r_bib['input_date'];
        #$_return['last_update'] = $r_bib['last_update'];
        $_return['uid'] = $r_bib['uid'];
        #AUTHORS
        $_return['authors'] = NULL;
        $s_aut = 'SELECT an.author_name, an.authority_type, ba.level ';
        $s_aut .= 'FROM biblio AS bi, biblio_author AS ba, mst_author AS an ';
        $s_aut .= 'WHERE bi.biblio_id=ba.biblio_id AND ba.author_id=an.author_id ';
        $s_aut .= 'AND bi.biblio_id='.$r_bib['biblio_id'].' ';
        $s_aut .= 'ORDER BY an.author_id ASC ';
        #debug $s_aut
        #$_return['authors_sql'] = $s_aut;
        $q_aut = $obj_db->query($s_aut);
        $_ca = 0;
        while ($r_aut = $q_aut->fetch_assoc()) {
          $_return['authors'][$_ca]['author_name'] = $r_aut['author_name'];
          $_type = $r_aut['authority_type'];
          $_return['authors'][$_ca]['authority_type'] = $sysconf['authority_type'][$_type];
          #$_return['authors'][$_ca]['authority_level'] = $r_aut['level'];
          $_level = $r_aut['level'];
          $_return['authors'][$_ca]['authority_level'] = $sysconf['authority_level'][$_level];
          $_ca++;
        }
        #SUBJECT/TOPIC
        $_return['subjects'] = NULL;
        $s_sub = 'SELECT mt.topic, mt.topic_type, bt.level ';
        $s_sub .= 'FROM biblio AS bi, biblio_topic AS bt, mst_topic AS mt ';
        $s_sub .= 'WHERE bi.biblio_id=bt.biblio_id AND bt.topic_id=mt.topic_id ';
        $s_sub .= 'AND bi.biblio_id='.$r_bib['biblio_id'].' ';
        $s_sub .= 'ORDER BY mt.topic_id ASC ';
        #debug $s_sub
        #$_return['subjects_sql'] = $s_sub;
        $q_sub = $obj_db->query($s_sub);
        $_ct = 0;
        while ($r_sub = $q_sub->fetch_assoc()) {
          $_return['subjects'][$_ct]['topic'] = $r_sub['topic'];
          $_type = $r_sub['topic_type'];
          $_return['subjects'][$_ct]['topic_type'] = $r_sub['topic_type'];
          $_return['subjects'][$_ct]['topic_type'] = $sysconf['subject_type'][$_type];
          $_level = $r_sub['level'];
          if ($_level == '1') {
            $_return['subjects'][$_ct]['topic_level'] = 'Primary';
          } elseif ($_level == '2') {
            $_return['subjects'][$_ct]['topic_level'] = 'Additional';
          } else {
            $_return['subjects'][$_ct]['topic_level'] = null;
          }
          $_ct++;
        }
        #ITEM/HOLDING
        $_return['items'] = NULL;
        $s_ite = 'SELECT i.*, ct.*, loc.*, mis.*, msp.* ';
        $s_ite .= 'FROM item AS i ';
        $s_ite .= 'LEFT JOIN ';
        $s_ite .= 'mst_coll_type AS ct ';
        $s_ite .= 'ON i.coll_type_id=ct.coll_type_id ';
        $s_ite .= 'LEFT JOIN ';
        $s_ite .= 'mst_location AS loc ';
        $s_ite .= 'ON i.location_id=loc.location_id ';
        $s_ite .= 'LEFT JOIN ';
        $s_ite .= 'mst_item_status AS mis ';
        $s_ite .= 'ON i.item_status_id=mis.item_status_id ';
        $s_ite .= 'LEFT JOIN ';
        $s_ite .= 'mst_supplier AS msp ';
        $s_ite .= 'ON i.supplier_id=msp.supplier_id ';
        $s_ite .= 'WHERE ';
        $s_ite .= 'biblio_id=\''.$r_bib['biblio_id'].'\' ';
        $s_ite .= 'ORDER BY i.item_id ASC ';

        #debug $s_ite
        #$_return['items_sql'] = $s_ite;
        $q_ite = $obj_db->query($s_ite);
        $_ci = 0;
        while ($r_ite = $q_ite->fetch_assoc()) {
          $_return['items'][$_ci]['item_id'] = $r_ite['item_id'];
          $_return['items'][$_ci]['item_code'] = $r_ite['item_code'];
          $_return['items'][$_ci]['call_number'] = $r_ite['call_number'];
          $_return['items'][$_ci]['coll_type_name'] = $r_ite['coll_type_name'];
          $_return['items'][$_ci]['shelf_location'] = $r_ite['site'];
          $_return['items'][$_ci]['location_name'] = $r_ite['location_name'];
          $_return['items'][$_ci]['inventory_code'] = $r_ite['inventory_code'];
          if (is_null($r_ite['item_status_name'])) {
            $_return['items'][$_ci]['item_status'] = 'Available';
          } else {
            $_return['items'][$_ci]['item_status'] = $r_ite['item_status_name'];
          }
          $_return['items'][$_ci]['order_no'] = $r_ite['order_no'];
          $_return['items'][$_ci]['order_date'] = $r_ite['order_date'];
          $_return['items'][$_ci]['received_date'] = $r_ite['received_date'];
          $_return['items'][$_ci]['supplier_name'] = $r_ite['supplier_name'];
          $_source = $r_ite['source'];
          if ($_source == '1') {
            $_return['items'][$_ci]['source'] = 'Buy';
          } elseif ($_source == '2') {
            $_return['items'][$_ci]['source'] = 'Prize/Grant';
          }
          $_return['items'][$_ci]['invoice'] = $r_ite['invoice'];
          $_return['items'][$_ci]['invoice_date'] = $r_ite['invoice_date'];
          $_return['items'][$_ci]['price'] = $r_ite['price'];
          $_return['items'][$_ci]['price_currency'] = $r_ite['price_currency'];
          $_return['items'][$_ci]['input_date'] = $r_ite['input_date'];
          $_return['items'][$_ci]['last_update'] = $r_ite['last_update'];
          $_return['items'][$_ci]['uid'] = $r_ite['uid'];
          $_ci++;
        }
        $_return['hash']['biblio'] = sha1(urlencode(serialize($_return)));
        $_return['hash']['classification'] = sha1(urlencode(serialize($_return['classification'])));
        $_return['hash']['authors'] = sha1(urlencode(serialize($_return['authors'])));
        $_return['hash']['subjects'] = sha1(urlencode(serialize($_return['subjects'])));
        $_return['hash']['image'] = sha1(urlencode(serialize($_return['image'])));
        $_return['input_date'] = $r_bib['input_date'];
        $_return['last_update'] = $r_bib['last_update'];
        $i++;
      }
    }
    return $_return;
  }

  /**
   * Static Method to write biblio activities logs
   *
   * @param   object  $obj_db
   * @param   integer  $biblio_id
   * @param   integer  $user_id
   * @param   string  $username
   * @param   string  $realname
   * @param   string  $title
   * @param   string  $action
   * @param   string  $affectedrow
   * @param   array  $rawdata
   * @return  void
   */
  public static function bibliolog_write($obj_db, $biblio_id, $user_id, $realname, $title, $action, $affectedrow, $rawdata, $additional_information = NULL)
  {
    if (!$obj_db->error) {
      // log table
      $_log_table = 'biblio_log';
      // filter input
      $_biblio_id = (int) $obj_db->escape_string(trim($biblio_id));
      $_user_id = (int) $obj_db->escape_string(trim($user_id));
      $_realname = $obj_db->escape_string(trim($realname));
      $_title = $obj_db->escape_string(trim($title));
      $_ip = $_SERVER['REMOTE_ADDR'];
      if ($action === 'create') {
        $_action = 'create';
      } elseif ($action === 'update') {
        $_action = 'update';
      } elseif ($action === 'delete') {
        $_action = 'delete';
      } else {
        $_action = 'create';        
      }
      if ($affectedrow === 'description') {
        $_affectedrow = 'description';
      } elseif ($affectedrow === 'classification') {
        $_affectedrow = 'classification';
      } elseif ($affectedrow === 'author') {
        $_affectedrow = 'author';
      } elseif ($affectedrow === 'subject') {
        $_affectedrow = 'subject';
      } elseif ($affectedrow === 'abstract') {
        $_affectedrow = 'abstract';
      } elseif ($affectedrow === 'cover') {
        $_affectedrow = 'cover';
      } else {
        $_affectedrow = 'description';     
      }
      $_rawdata = urlencode(serialize($rawdata));
      $_additional_information = $obj_db->escape_string(trim($additional_information));
      $_date = date('Y-m-d H:i:s');
      // insert log data to database
      @$obj_db->query('INSERT INTO '.$_log_table.'
        VALUES (NULL, \''.$_biblio_id.'\', \''.$_user_id.'\', \''.$_realname.'\', \''.$_title.'\', \''.$_ip.'\', \''.$_action.'\', \''.$_affectedrow.'\', \''.$_rawdata.'\', \''.$_additional_information.'\', \''.$_date.'\')');
    }
  }

  public static function bibliolog_compare($obj_db, $biblio_id, $user_id, $realname, $title, $current, $previous = NULL)
  {
    if ($previous == NULL) {
      if ($current['classification'] != 'NONE') {
        api::bibliolog_write($obj_db, $biblio_id, $user_id, $realname, $title, 'update', 'classification', $current, 'New data. Classification. Number: '.$current['classification']);
      }
      if ($current['image'] != NULL) {
        api::bibliolog_write($obj_db, $biblio_id, $user_id, $realname, $title, 'update', 'cover', $current, 'New data. Image. File: '.$current['image']);
      }
      if ($current['authors'] != NULL) {
        $_authors = '';
        foreach ($current['authors'] as $key => $value) {
          $_authors .= $value['author_name'].'; ';
        }
        api::bibliolog_write($obj_db, $biblio_id, $user_id, $realname, $title, 'update', 'author', $current, 'New data. Author. Names: '.$_authors);
      }
      if ($current['subjects'] != NULL) {
        $_subjects = '';
        foreach ($current['subjects'] as $key => $value) {
          $_subjects .= $value['topic'].'; ';
        }
        api::bibliolog_write($obj_db, $biblio_id, $user_id, $realname, $title, 'update', 'subject', $current, 'New data. Subject. Names: '.$_subjects);
      }
    } else {
      if ($current['hash']['biblio'] != $previous['hash']['biblio']) {
        api::bibliolog_write($obj_db, $biblio_id, $user_id, $realname, $title, 'update', 'description', $current, 'Updated data. Bibliography.');
      }
      if ( ($current['classification'] != 'NONE') AND ($current['classification'] != $previous['classification']) ) {
        api::bibliolog_write($obj_db, $biblio_id, $user_id, $realname, $title, 'update', 'classification', $current, 'Updated data. Classification. Number: '.$current['classification']);
      }
      if ( ($current['image'] != NULL) AND ($current['image'] != $previous['image']) ) {
        api::bibliolog_write($obj_db, $biblio_id, $user_id, $realname, $title, 'update', 'cover', $current, 'Updated data. Image. File: '.$current['image']);
      }
      if ( ($current['authors'] != NULL) AND ($current['hash']['authors'] != $previous['hash']['authors']) ) {
        $_authors = '';
        foreach ($current['authors'] as $key => $value) {
          $_authors .= $value['author_name'].'; ';
        }
        api::bibliolog_write($obj_db, $biblio_id, $user_id, $realname, $title, 'update', 'author', $current, 'Updated data. Author. Names: '.$_authors);
      }
      if ( ($current['subjects'] != NULL) AND ($current['hash']['subjects'] != $previous['hash']['subjects']) ) {
        $_subjects = '';
        foreach ($current['subjects'] as $key => $value) {
          $_subjects .= $value['topic'].'; ';
        }
        api::bibliolog_write($obj_db, $biblio_id, $user_id, $realname, $title, 'update', 'subject', $current, 'Updated data. Subject. Names: '.$_subjects);
      }

    }
  }

  #Membership modules related
  public static function member_load($obj_db, $member_id)
  {
    $_return = FALSE;
    $i = 0;
    $s_mbr = '';
    $s_mbr .= 'SELECT mmt.member_type_name, mbr.* ';
    $s_mbr .= 'FROM member AS mbr ';
    $s_mbr .= 'LEFT JOIN mst_member_type AS mmt ON mbr.member_type_id=mmt.member_type_id ';
    $s_mbr .= 'WHERE mbr.member_id=\''.$member_id.'\'';
    $q_mbr = $obj_db->query($s_mbr);
    if (!$obj_db->errno) {
      $_return = [];
      while ($r_mbr = $q_mbr->fetch_assoc()) {
        $_return[$i]['member_id'] = $r_mbr['member_id'];
        $_return[$i]['member_name'] = $r_mbr['member_name'];
        $_return[$i]['gender'] = $r_mbr['gender'];
        $_return[$i]['birth_date'] = $r_mbr['birth_date'];
        $_return[$i]['member_type_name'] = $r_mbr['member_type_name'];
        $_return[$i]['member_address'] = $r_mbr['member_address'];
        $_return[$i]['member_mail_address'] = $r_mbr['member_mail_address'];
        $_return[$i]['member_email'] = $r_mbr['member_email'];
        $_return[$i]['postal_code'] = $r_mbr['postal_code'];
        $_return[$i]['inst_name'] = $r_mbr['inst_name'];
        $_return[$i]['is_new'] = $r_mbr['is_new'];
        $_return[$i]['member_image'] = $r_mbr['member_image'];
        $_return[$i]['pin'] = $r_mbr['pin'];
        $_return[$i]['member_phone'] = $r_mbr['member_phone'];
        $_return[$i]['member_fax'] = $r_mbr['member_fax'];
        $_return[$i]['member_since_date'] = $r_mbr['member_since_date'];
        $_return[$i]['register_date'] = $r_mbr['register_date'];
        $_return[$i]['expire_date'] = $r_mbr['expire_date'];
        $_return[$i]['member_notes'] = $r_mbr['member_notes'];
        $_return[$i]['is_pending'] = $r_mbr['is_pending'];
        $_return[$i]['mpasswd'] = false;
        $_return[$i]['last_login'] = $r_mbr['last_login'];
        $_return[$i]['last_login_ip'] = $r_mbr['last_login_ip'];
        $_return[$i]['hash']['member'] = sha1(urlencode(serialize($_return[$i])));
        $_return[$i]['input_date'] = $r_mbr['input_date'];
        $_return[$i]['last_update'] = $r_mbr['last_update'];
        $i++;
      }
    }
    return $_return;
  }

  /**
   * Convert array to object
   *
   * @param array $array
   * @return object
   */
  public static function to_object($array)
  {
    return json_decode(json_encode($array));
  }

  /**
   * Send to indexing engine (Solr / ElasticSearch) via REST
   *
   * @param array $array
   * @return void
   */
  public static function update_to_index($array_data)
  {
    global $sysconf;
    if ($sysconf['index']['engine']['type'] == 'solr') {
      #$_url = 'http://172.17.0.4:8983/solr/slims/update';
      $_url = $sysconf['index']['engine']['solr_opts']['host'].':'.$sysconf['index']['engine']['solr_opts']['port'].'/solr/'.$sysconf['index']['engine']['solr_opts']['collection'].'/update';
      $_onlydata = json_encode($array_data);
      $json_data = '{"add":{"doc":'.$_onlydata.',"commitWithin": 5000,"overwrite": true}}';
      $ch = curl_init($_url);
      curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "POST");                                                                     
      curl_setopt($ch, CURLOPT_POSTFIELDS, $json_data);                                                                  
      curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);                                                                      
      curl_setopt($ch, CURLOPT_HTTPHEADER, array(                                                                          
        'Content-Type: application/json',                                                                                
        'Content-Length: ' . strlen($json_data))                                                                    
        );
        curl_exec($ch);
    } elseif ($sysconf['index']['engine']['type'] == 'es') {
      #here is the codes for accessing ES
    }
  }

}

require_once 'member_api.inc.php';
require_once 'circulation_api.inc.php';

================================================================================
File: biblio_list_index.inc.php
================================================================================

<?php
/**
 * biblio_list class
 * Class for generating list of bibliographic records from index table
 *
 * Copyright (C) 2010 Arie Nugraha (dicarve@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
  die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
  die("can not access this file directly");
}

class biblio_list extends biblio_list_model
{
  /**
   * Class Constructor
   *
   * @param   object  $obj_db
   * @param   integer	$int_num_show
   */
  public function __construct($obj_db, $int_num_show)
  {
    parent::__construct($obj_db, $int_num_show);
  }


  /**
   * Method to compile SQL statement based on criteria
   *
   * @param   string  $str_criteria
   * @return  void
   */
  protected function compileSQL() {
    global $sysconf;
    // get page number from http get var
    if (!isset($_GET['page']) OR $_GET['page'] < 1){ $_page = 1; } else {
      $_page = (integer)$_GET['page'];
    }
    $this->current_page = $_page;

    // count the row offset
    if ($_page <= 1) { $_offset = 0; } else {
      $_offset = ($_page*$this->num2show) - $this->num2show;
    }

    // init sql string
    $_sql_str = 'SELECT SQL_CALC_FOUND_ROWS index.biblio_id, index.title, index.author, index.topic, index.image, index.isbn_issn, index.publisher, index.publish_place, index.publish_year, index.labels, index.input_date';

    // checking custom frontpage fields file
    $custom_frontpage_record_file = SB.$sysconf['template']['dir'].'/'.$sysconf['template']['theme'].'/custom_frontpage_record.inc.php';
    if (file_exists($custom_frontpage_record_file)) {
      include $custom_frontpage_record_file;
      $this->enable_custom_frontpage = true;
      $this->custom_fields = $custom_fields;
      foreach ($this->custom_fields as $_field => $_field_opts) {
        if ($_field_opts[0] == 1 && !in_array($_field, array('availability', 'isbn_issn'))) {
          $_sql_str .= ", index.$_field";
        }
      }
    }

    // additional SQL string
    $_add_sql_str = ' WHERE';
    // main search criteria
    if (isset($this->criteria['sql_criteria'])) {
      if ($this->criteria['sql_criteria']!='') {
        $_add_sql_str .= ' ('.$this->criteria['sql_criteria'].') AND `index`.`opac_hide`=0 ';
      } else {
        $_add_sql_str .= ' `index`.`opac_hide`=0';
      }
    } else {
      $_add_sql_str .= ' `index`.`opac_hide`=0';      
    }

    // promoted flag
    // if ($this->only_promoted) { $_add_sql_str .= ' AND promoted=1'; }

    $_sql_str .= ' FROM `search_biblio` AS `index` '.$_add_sql_str.' ORDER BY `index`.`last_update` DESC LIMIT '.$_offset.', '.$this->num2show;
    // for debugging purpose only
    // echo "<div style=\"border: 1px solid navy; padding: 5px; color: navy; margin: 5px;\">$_sql_str</div>";
	  return $_sql_str;
  }


  /**
   * Method to set search criteria
   *
   * @param   string  $str_criteria
   * @return  void
   */
  public function setSQLcriteria($str_criteria) {
    if (!$str_criteria)
      return null;
    // defaults
    $_sql_criteria = '';
    $_searched_fields = array();
    $_previous_field = '';
    $_boolean = '';
    // parse query
    $this->orig_query = $str_criteria;
    $_queries = simbio_tokenizeCQL($str_criteria, $this->searchable_fields, $this->stop_words, $this->queries_word_num_allowed);
    // var_dump($_queries);
    if (count($_queries) < 1) {
      return null;
    }
    // loop each query
	  	  // echo '<pre>'; var_dump($_queries); echo '</pre>';
    foreach ($_queries as $_num => $_query) {
      // field
      $_field = $_query['f'];
	    $_is_phrase = isset($_query['is_phrase']);
      //  break the loop if we meet `cql_end` field
      if ($_field == 'cql_end') { break; }
	  	// if field is boolean
	  	if ($_field == 'boolean') {
	  	  if ($_query['b'] == '*') { $_boolean = 'OR'; } else { $_boolean = 'AND'; }
	  	  continue;
	  	} else {
        if ($_boolean) {
          $_sql_criteria .= " $_boolean ";
        } else {
          if ($_query['b'] == '*') {
          $_sql_criteria .= " OR ";
          } else { $_sql_criteria .= " AND "; }
        }
        $_b = $_query['b'];
        $_q = @$this->obj_db->escape_string(trim($_query['q']));
        if (in_array($_field, array('title', 'author', 'subject', 'notes'))) {
          $_q = '+'.( $_is_phrase?'"'.$_q.'"':$_q );
          if (!$_is_phrase) {
            $_q = preg_replace('@\s+@i', ' +', $_q);
          }
        }
        $_boolean = '';
	  	}
			$_searched_word = str_replace(array('+', '-', '*'), '', $_q);
			$this->words[$_searched_word] = $_searched_word;
	    $_searched_fields = $_field;
      // for debugging purpose only
      // echo "<p>$_num. $_field -> $_boolean -> $_sql_criteria</p><p>&nbsp;</p>";

	    // check fields
      switch ($_field) {
        case 'author' :
	  	    if ($_b == '-') { $_sql_criteria .= " NOT (MATCH (index.author) AGAINST ('$_q' IN BOOLEAN MODE))";
	  	    } else { $_sql_criteria .= " (MATCH (index.author) AGAINST ('$_q' IN BOOLEAN MODE))"; }
          break;
        case 'subject' :
	  	    if ($_b == '-') { $_sql_criteria .= " NOT (MATCH (index.topic) AGAINST ('$_q' IN BOOLEAN MODE))";
	  	    } else { $_sql_criteria .= " (MATCH (index.topic) AGAINST ('$_q' IN BOOLEAN MODE))"; }
          break;
        case 'location' :
	  	    if (!$this->disable_item_data) {
	  	  	if ($_b == '-') { $_sql_criteria .= " NOT (MATCH (index.location) AGAINST ('$_q' IN BOOLEAN MODE))";
	  	  	} else { $_sql_criteria .= " (MATCH (index.location) AGAINST ('$_q' IN BOOLEAN MODE))"; }
	  	    } else {
	  	  	if ($_b == '-') { $_sql_criteria .= " index.node !='$_q'";
	  	  	} else { $_sql_criteria .= " index.node = '$_q'"; }
	  	    }
          break;
        case 'colltype' :
          if (!$this->disable_item_data) {
	  	  	if ($_b == '-') { $_sql_criteria .= " NOT (MATCH (index.collection_types) AGAINST ('$_q' IN BOOLEAN MODE))";
	  	  	} else { $_sql_criteria .= " MATCH (index.collection_types) AGAINST ('$_q' IN BOOLEAN MODE)"; }
          }
          break;
        case 'itemcode' :
          if (!$this->disable_item_data) {
	  	  	if ($_b == '-') { $_sql_criteria .= " NOT (MATCH (index.items) AGAINST ('$_q' IN BOOLEAN MODE))";
	  	  	} else { $_sql_criteria .= " MATCH (index.items) AGAINST ('$_q' IN BOOLEAN MODE)"; }
	  	    }
          break;
        case 'callnumber' :
          if ($_b == '-') { $_sql_criteria .= ' biblio.call_number NOT LIKE \''.$_q.'%\'';
          } else { $_sql_criteria .= ' index.call_number LIKE \''.$_q.'%\''; }
          break;
        case 'itemcallnumber' :
	  	    if (!$this->disable_item_data) {
	  	  	if ($_b == '-') { $_sql_criteria .= ' item.call_number NOT LIKE \''.$_q.'%\'';
	  	  	} else { $_sql_criteria .= ' item.call_number LIKE \''.$_q.'%\''; }
	  	    }
          break;
        case 'class' :
          if ($_b == '-') { $_sql_criteria .= ' index.classification NOT LIKE \''.$_q.'%\'';
          } else { $_sql_criteria .= ' index.classification LIKE \''.$_q.'%\''; }
          break;
        case 'isbn' :
          if ($_b == '-') { $_sql_criteria .= ' index.isbn_issn NOT LIKE \''.$_q.'%\'';
          } else { $_sql_criteria .= ' index.isbn_issn LIKE \''.$_q.'%\''; }
          break;
        case 'publisher' :
          if ($_b == '-') { $_sql_criteria .= " index.publisher!='$_q'";
          } else { $_sql_criteria .= " index.publisher LIKE '$_q%'"; }
          break;
        case 'publishyear' :
          if ($_b == '-') { $_sql_criteria .= ' index.publish_year!=\''.$_q.'\'';
          } else { $_sql_criteria .= ' index.publish_year LIKE \''.$_q.'\''; }
          break;
        case 'gmd' :
          if ($_b == '-') { $_sql_criteria .= " index.gmd!='$_q'";
          } else { $_sql_criteria .= " index.gmd='$_q'"; }
          break;
        case 'notes' :
          if ($_b == '-') {
          $_sql_criteria .= " NOT (MATCH (index.notes) AGAINST ('".$_q."' IN BOOLEAN MODE))";
          } else { $_sql_criteria .= " (MATCH (index.notes) AGAINST ('".$_q."' IN BOOLEAN MODE))"; }
          break;
        case 'opengroup' :
          $_sql_criteria .= "(";
          break;
        case 'closegroup' :
          $_sql_criteria .= ")";
          break;
        default :
          if ($_b == '-') { $_sql_criteria .= " NOT (MATCH (index.title, index.series_title) AGAINST ('$_q' IN BOOLEAN MODE))";
          } else { $_sql_criteria .= " (MATCH (index.title, index.series_title) AGAINST ('$_q' IN BOOLEAN MODE))"; }
          break;
      }
    }

    // remove boolean's logic symbol prefix and suffix
    $_sql_criteria = preg_replace('@^(AND|OR|NOT)\s*|\s+(AND|OR|NOT)$@i', '', trim($_sql_criteria));
    // below for debugging purpose only
    // echo "<div style=\"border: 1px solid #f00; padding: 5px; color: #f00; margin: 5px;\">$_sql_criteria</div>";

    $this->criteria = array('sql_criteria' => $_sql_criteria, 'searched_fields' => $_searched_fields);
    return $this->criteria;
  }
}

================================================================================
File: biblio_list_elasticsearch.inc.php
================================================================================

<?php
/**
 * @author              : Waris Agung Widodo
 * @Date                : 25/12/18 15.00
 * @Last Modified by    : ido
 * @Last Modified time  : 25/12/18 15.00
 *
 * Copyright (C) 2017  Waris Agung Widodo (ido.alit@gmail.com)
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
  die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
  die("can not access this file directly");
}

class biblio_list extends biblio_list_model
{
  private $client;

  public function __construct($obj_db, int $int_num_show = 20)
  {
    global $sysconf;

    parent::__construct($obj_db, $int_num_show);
    $this->client = Elasticsearch\ClientBuilder::create()
      ->setHosts($sysconf['index']['engine']['es_opts']['hosts'])
      ->build();
  }

  public function setSQLcriteria($str_criteria)
  {
    global $sysconf;

    // get page number from http get var
    if (!isset($_GET['page']) OR $_GET['page'] < 1){ $_page = 1; } else {
      $_page = (integer)$_GET['page'];
    }
    $this->current_page = $_page;

    // count the row offset
    if ($_page <= 1) { $_offset = 0; } else {
      $_offset = ($_page*$this->num2show) - $this->num2show;
    }

    $params = [
      'index' => $sysconf['index']['engine']['es_opts']['index'],
      'type' => 'bibliography',
      'from' => $_offset,
      'size' => $this->num2show,
      'body' => [
        'query' => []
      ]
    ];

    if (!$str_criteria) {
      $params['body']['query'] = [
        'match_all' => new \stdClass()
      ];
    } else {
      // parse query
      $this->orig_query = $str_criteria;
      $queries = simbio_tokenizeCQL($str_criteria, $this->searchable_fields, $this->stop_words, $this->queries_word_num_allowed);
      // echo '<pre>'; print_r($queries); echo '</pre>';
      if (count($queries) < 1) {
        return null;
      }

      $params['body']['query'] = [
        'bool' => []
      ];

      $bool = isset($_GET['searchtype']) && $_GET['searchtype'] === 'advance' ? 'must' : 'should';

      foreach ($queries as $query) {
        // field
        $_field = $query['f'];
        $_q = isset($query['q']) ? trim($query['q']) : '';

        //  break the loop if we meet `cql_end` field
        if ($_field == 'cql_end') { continue; }

        // if field is boolean
        if ($_field == 'boolean') {
          if ($query['b'] == '*') {
            $bool = 'should';
          } else if ($query['b'] == '-') {
            $bool = 'must_not';
          } else {
            $bool = 'must';
          }
          continue;
        }

        if ($_field === 'author') {
          $params['body']['query']['bool'][$bool][] = ['nested' => [
            'path' => 'authors',
            'query' => [
              'bool' => [
                'should' => [
                  ['match' => ['authors.author_name' => $_q]]
                ]
              ]
            ]
          ]];
        } else if ($_field === 'subject') {
          $params['body']['query']['bool'][$bool][] = ['nested' => [
            'path' => 'subjects',
            'query' => [
              'bool' => [
                'should' => [
                  ['match' => ['subjects.topic' => $_q]]
                ]
              ]
            ]
          ]];
        } else if ($_field === 'colltype') {
          $params['body']['query']['bool'][$bool][] = ['nested' => [
            'path' => 'items',
            'query' => [
              'bool' => [
                'should' => [
                  ['match' => ['items.coll_type_name' => $_q]]
                ]
              ]
            ]
          ]];
        } else if ($_field === 'location') {
          $params['body']['query']['bool'][$bool][] = ['nested' => [
            'path' => 'items',
            'query' => [
              'bool' => [
                'should' => [
                  ['match' => ['items.location_name' => $_q]]
                ]
              ]
            ]
          ]];
        } else {
          switch ($_field) {
            case 'isbn':
              $_fieldTmp = 'isbn_issn';
              break;
            case 'gmd':
              $_fieldTmp = 'gmd_name';
              break;
            default:
              $_fieldTmp = $_field;
              break;
          }
          $params['body']['query']['bool'][$bool][] = ['match' => [$_fieldTmp => $_q]];
        }

      }
    }

    if ($sysconf['enable_search_clustering']) {
      $params['body']['aggs'] = [
        'authors' => [
          'nested' => [
            'path' => 'authors'
          ],
          'aggs' => [
            'authors' => ['terms' => ['field' => 'authors.author_name', 'size' => 10]]
          ]
        ],
        'topics' => [
          'nested' => [
            'path' => 'subjects'
          ],
          'aggs' => [
            'topics' => ['terms' => ['field' => 'subjects.topic', 'size' => 10]]
          ]
        ],
        'gmd' => ['terms' => ['field' => 'gmd_name', 'size' => 10]],
      ];
    }

    $this->criteria = $params;
    // echo '<pre>'; print_r($this->criteria); echo '</pre>';
    return $this->criteria;
  }

  public function getDocumentList($bool_return_output = true)
  {
    // start time
    $_start = function_exists('microtime')?microtime(true):time();

    // result
    $this->resultset = $this->client->search($this->criteria);
    $this->num_rows = $this->resultset['hits']['total'];

    // end time
    $_end = function_exists('microtime')?microtime(true):time();
    $this->query_time = round($_end-$_start, 5);

    // echo '<pre>'; print_r($this->resultset['aggregations']); echo '</pre>';
    if ($bool_return_output) {
      // return the html result
       return $this->makeOutput();
    }
  }

  public function getClustering() {
    global $sysconf;
    $aggs = $sysconf['enable_search_clustering'] ? $this->resultset['aggregations'] : [];
    $buffer = '';
    foreach ($aggs as $k => $agg) {
      $title = '';
      $field = '';
      $array = array();
      switch ($k) {
        case 'topics':
          $title = 'Subject(s)';
          $field = 'subject';
          $array = $agg['topics']['buckets'];
          break;
        case 'authors':
          $title = 'Author(s)';
          $field = 'author';
          $array = $agg['authors']['buckets'];
          break;
        case 'gmd':
          $title = 'GMD';
          $field = 'gmd';
          $array = $agg['buckets'];
          break;
      }
      $buffer .= '<h3 class="cluster-title">'.__($title).'</h3>'."\n";
      $buffer .= '<ul class="cluster-list">'."\n";
      foreach ($array as $item) {
        $buffer .= '<li class="cluster-item"><a href="index.php?'.$field.'='.$item['key'].'&searchtype=advance&search=search">'.$item['key'].' <span class="cluster-item-count">'.$item['doc_count'].'</span></a></li>';
      }
      $buffer .= '</ul>';
    }

    return $buffer;
  }

  protected function makeOutput()
  {
    global $sysconf;
    // init the result buffer
    $_buffer = '';
    // keywords from last search
    $_keywords = '';
    if (!$this->resultset) {
      return '<div class="errorBox">Query error : '.$this->query_error.'</div>';
    }

    if (isset($_GET['keywords'])) {
      $_keywords = urlencode(trim(urldecode($_GET['keywords'])));
    }

    // include biblio list HTML template callback
    include SB.$sysconf['template']['dir'].'/'.$sysconf['template']['theme'].'/biblio_list_template.php';
    $n = 0;
    $settings = get_object_vars($this);
    $settings['keywords'] = $_keywords;
    foreach ($this->resultset['hits']['hits'] as $item) {
      $_buffer .= biblio_list_format($this->obj_db, $item['_source'], $n, $settings);
      $n++;
    }

    // paging
    if (($this->num_rows > $this->num2show)) {
      $_paging = '<div class="biblioPaging">'.simbio_paging::paging($this->num_rows, $this->num2show, 5).'</div>';
    } else {
      $_paging = '';
    }

    $_biblio_list = '';
    $_is_member_logged_in = utility::isMemberLogin() && $this->enable_mark;
    if ($_paging) {
      $_biblio_list .= $_paging;
    }
    if ($_is_member_logged_in) {
      $_submit = '<div class="biblioMarkFormAction"><input type="submit" name="markBiblio" value="'.__('Put marked selection into basket').'" /></div>';
      $_biblio_list .= '<form class="biblioMarkForm" method="post" action="index.php?p=member#biblioBasket">';
      $_biblio_list .= $_submit;
    }
    $_biblio_list .= $_buffer;
    if ($_is_member_logged_in) {
      $_biblio_list .= $_submit;
      $_biblio_list .= '</form>';
    }
    if ($_paging) {
      $_biblio_list .= $_paging;
    }

    return $_biblio_list;
  }


}
================================================================================
File: biblio_list_model.inc.php
================================================================================

<?php
/**
 * biblio_list model
 * Template/Abstract Class for bibliographic records listing
 *
 * Copyright (C) 2010 Arie Nugraha (dicarve@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
  die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
  die("can not access this file directly");
}

abstract class biblio_list_model
{
  /* Public properties */
  public $num_rows = 0;
  public $num2show = 10;
  public $xml_detail = true;
  public $xml_result = true;
  public $only_promoted = false;
  public $show_labels = true;
  public $stop_words = array('a', 'an', 'of', 'the', 'to', 'so', 'as', 'be');
  public $query_time = 0;
  public $disable_item_data = false;
  public $enable_mark = true;
  public $query_error;
  public $current_page = 1;
  public $item_availability_message = 'none copy available';
  public $words = array();
  /* Protected properties */
  protected $obj_db = false;
  protected $resultset = false;
  protected $subquery = array();
  protected $biblio_ids = array();
  protected $emulate_short_word_search = false;
  protected $queries_word_num_allowed = 20;
  protected $criteria = array();
  protected $label_cache = array();
  protected $custom_fields = array();
  protected $enable_custom_frontpage = false;
  protected $orig_query;
  protected $searchable_fields = array('title', 'author', 'subject', 'isbn',
	   'gmd', 'colltype', 'class', 'callnumber', 'notes',
	   'publisher', 'publish_year', 'itemcode', 'location');
  protected $field_join_type = array();

  /**
   * Class Constructor
   *
   * @param   object  $obj_db
   * @param   integer	$int_num_show
   */
  public function __construct($obj_db, $int_num_show = 20) {
	  $this->obj_db = $obj_db;
	  $this->num2show = $int_num_show;
  }


  /**
   * Method to set search criteria
   * Extend this method
   *
   * @param   string  $str_criteria
   * @return  void
   */
  public function setSQLcriteria($str_criteria) { }


  /**
   * Method to compile SQL statement based on criteria
   *
   * @param   string  $str_criteria
   * @return  void
   */
  protected function compileSQL() { }


  /**
   * Method to get string of authors data of bibliographic record
   *
   * @param   object	$obj_db
   * @param   integer	$int_biblio_id
   * @param   boolean	$bool_return_array
   * @return  mixed
   */
  public static function getAuthors($obj_db, $int_biblio_id, $bool_return_array = false) {
	$_authors = '';
	$_authors_arr = array();
	$_sql_str = 'SELECT a.author_name, a.author_id FROM biblio_author AS ba
      LEFT JOIN biblio AS b ON ba.biblio_id=b.biblio_id
      LEFT JOIN mst_author AS a ON ba.author_id=a.author_id WHERE ba.biblio_id='.$int_biblio_id;
    // query the author
    $_author_q = $obj_db->query($_sql_str);
    // concat author data
    while ($_author_d = $_author_q->fetch_row()) {
      $counter = count ($_author_d);
      $_authors .= $_author_d[0];
	  if ($bool_return_array) {
		$_authors_arr[] = $_author_d[0];
	  }
      $_authors .= ' - ';
    }
	if ($bool_return_array) {
	  return $_authors_arr;
	} else {
	  return $_authors;
	}
  }


  /**
   * Method to get list of document IDs of result
   *
   * @return  mixed
   */
  public function getDocumentIds() {
    $_temp_resultset = $this->resultset;
    while ($_biblio_d = $_temp_resultset->fetch_assoc()) { $this->biblio_ids[] = $_biblio_d['biblio_id']; }
    unset($_temp_resultset);
    return $this->biblio_ids;
  }


  /**
   * Method to print out document records
   *
   * @param   object  $obj_db
   * @param   integer $int_num2show
   * @param   boolean $bool_return_output
   * @return  string
   */
  public function getDocumentList($bool_return_output = true) {
    global $sysconf;
    $_sql_str = $this->compileSQL();
    // start time
    $_start = function_exists('microtime')?microtime(true):time();
    // execute query
    $this->resultset = $this->obj_db->query($_sql_str);
    if ($this->obj_db->error) {
      $this->query_error = $this->obj_db->error;
    }
    // get total number of rows from query
    $_total_q = $this->obj_db->query('SELECT FOUND_ROWS()');
    $_total_d = $_total_q->fetch_row();
    $this->num_rows = $_total_d[0];
    // end time
    $_end = function_exists('microtime')?microtime(true):time();
    $this->query_time = round($_end-$_start, 5);
    if ($bool_return_output) {
      // return the html result
      return $this->makeOutput();
    }
  }


  /**
   * Method to make an output of document records
   *
   * @return  string
   */
  protected function makeOutput() {
    global $sysconf;
    // init the result buffer
    $_buffer = '';
    // keywords from last search
    $_keywords = '';
    // loop data
    $_i = 0;
    if (!$this->resultset) {
      return '<div class="errorBox">Query error : '.$this->query_error.'</div>';
    }

    if (isset($_GET['keywords'])) {
      $_keywords = urlencode(trim(urldecode($_GET['keywords'])));
    }

    // include biblio list HTML template callback
    include SB.$sysconf['template']['dir'].'/'.$sysconf['template']['theme'].'/biblio_list_template.php';
    $settings = '';
    $settings = get_object_vars($this);
    $settings['keywords'] = $_keywords;
    while ($_biblio_d = $this->resultset->fetch_assoc()) {
      $_buffer .= biblio_list_format($this->obj_db, $_biblio_d, $_i, $settings, $return_back);
      $_i++;
    }

    // free resultset memory
    $this->resultset->free_result();

    // paging
    if (($this->num_rows > $this->num2show)) {
      $_paging = '<div class="biblioPaging">'.simbio_paging::paging($this->num_rows, $this->num2show, 5).'</div>';
    } else {
      $_paging = '';
    }

    $_biblio_list = '';
    $_is_member_logged_in = utility::isMemberLogin() && $this->enable_mark;
    if ($_paging) {
    	$_biblio_list .= $_paging;
    }
    if ($_is_member_logged_in) {
      $_submit = '<div class="biblioMarkFormAction"><input type="submit" name="markBiblio" value="'.__('Put marked selection into basket').'" /></div>';
      $_biblio_list .= '<form class="biblioMarkForm" method="post" action="index.php?p=member#biblioBasket">';
      $_biblio_list .= $_submit;
    }
    $_biblio_list .= $_buffer;
    if ($_is_member_logged_in) {
      $_biblio_list .= $_submit;
      $_biblio_list .= '</form>';
    }
    if ($_paging) {
      $_biblio_list .= $_paging;
    }
    return $_biblio_list;
  }



  /**
   * Method to make an output of document records in simple XML format
   *
   * @return  string
   */
  public function XMLresult() {
    global $sysconf;
    $mods_version = '3.3';
	$_buffer = '';
    // loop data
    $xml = new XMLWriter();
    $xml->openMemory();
    $xml->setIndent(true);
	$xml->startElement('modsCollection');
	$xml->writeAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
	$xml->writeAttribute('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
	$xml->writeAttribute('xmlns', 'http://www.loc.gov/mods/v3');
	$xml->writeAttribute('xmlns:slims', 'http://slims.web.id');
	$xml->writeAttribute('xsi:schemaLocation', 'http://www.loc.gov/mods/v3 http://www.loc.gov/standards/mods/v3/mods-3-3.xsd');
    // $_buffer = '<modsCollection xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.loc.gov/mods/v3" xmlns:slims="http://slims.web.id" xsi:schemaLocation="http://www.loc.gov/mods/v3 http://www.loc.gov/standards/mods/v3/mods-3-3.xsd">'."\n";

    $xml->startElementNS('slims', 'resultInfo', null);
    $xml->startElementNS('slims', 'modsResultNum', null); $this->xmlWrite($xml, $this->num_rows); $xml->endElement();
    $xml->startElementNS('slims', 'modsResultPage', null); $this->xmlWrite($xml, $this->current_page); $xml->endElement();
    $xml->startElementNS('slims', 'modsResultShowed', null); $this->xmlWrite($xml, $this->num2show); $xml->endElement();
    $xml->endElement();

    while ($_biblio_d = $this->resultset->fetch_assoc()) {
      $xml->startElement('mods');
      $xml->writeAttribute('version', $mods_version);
      $xml->writeAttribute('ID', $_biblio_d['biblio_id']);

      // parse title
      $_title_sub = '';
      if (stripos($_biblio_d['title'], ':') !== false) {
        $_title_main = trim(substr_replace($_biblio_d['title'], '', stripos($_biblio_d['title'], ':')+1));
        $_title_sub = trim(substr_replace($_biblio_d['title'], '', 0, stripos($_biblio_d['title'], ':')+1));
      } else {
        $_title_main = trim($_biblio_d['title']);
      }

      // parse title
      $_title_main = trim($_biblio_d['title']);
      $_title_sub = '';
      $_title_statement_resp = '';
      if (stripos($_biblio_d['title'], '/') !== false) {
          $_title_main = trim(substr_replace($_biblio_d['title'], '', stripos($_biblio_d['title'], '/')+1));
	  $_title_statement_resp = trim(substr_replace($_biblio_d['title'], '', 0, stripos($_biblio_d['title'], '/')+1));
      }
      if (stripos($_biblio_d['title'], ':') !== false) {
          $_title_main = trim(substr_replace($_biblio_d['title'], '', stripos($_biblio_d['title'], ':')+1));
          $_title_sub = trim(substr_replace($_biblio_d['title'], '', 0, stripos($_biblio_d['title'], ':')+1));
      }

      $xml->startElement('titleInfo');
      $xml->startElement('title');
      $this->xmlWrite($xml, $_title_main);
      $xml->endElement();
      if ($_title_sub) {
          // $_xml_output .= '<subTitle><![CDATA['.$_title_sub.']]></subTitle>'."\n";
          $xml->startElement('subTitle');
          $this->xmlWrite($xml, $_title_sub);
          $xml->endElement();
      }
      // $_xml_output .= '</titleInfo>'."\n";
      $xml->endElement();

      // get the authors data
      $_biblio_authors_q = $this->obj_db->query('SELECT a.*,ba.level FROM mst_author AS a'
        .' LEFT JOIN biblio_author AS ba ON a.author_id=ba.author_id WHERE ba.biblio_id='.$_biblio_d['biblio_id']);
      while ($_auth_d = $_biblio_authors_q->fetch_assoc()) {
        // some rules to set name type in mods standard
        if (isset($sysconf['authority_type'][$_auth_d['authority_type']]) && $sysconf['authority_type'][$_auth_d['authority_type']] == 'Personal Name') {
          $sysconf['authority_type'][$_auth_d['authority_type']] = 'personal';
        } elseif (isset($sysconf['authority_type'][$_auth_d['authority_type']]) && $sysconf['authority_type'][$_auth_d['authority_type']] == 'Organizational Body') {
          $sysconf['authority_type'][$_auth_d['authority_type']] = 'corporate';
        } elseif (isset($sysconf['authority_type'][$_auth_d['authority_type']]) && $sysconf['authority_type'][$_auth_d['authority_type']] == 'Conference') {
          $sysconf['authority_type'][$_auth_d['authority_type']] = 'conference';
        } else {
          $sysconf['authority_type'][$_auth_d['authority_type']] = 'personal';
        }
        $xml->startElement('name'); $xml->writeAttribute('type', $sysconf['authority_type'][$_auth_d['authority_type']]); $xml->writeAttribute('authority', $_auth_d['auth_list']);
        $xml->startElement('namePart'); $this->xmlWrite($xml, $_auth_d['author_name']); $xml->endElement();
        $xml->startElement('role');
            $xml->startElement('roleTerm'); $xml->writeAttribute('type', 'text');
            $this->xmlWrite($xml, $sysconf['authority_level'][$_auth_d['level']]);
            $xml->endElement();
        $xml->endElement();
        $xml->endElement();
      }

      $_biblio_authors_q->free_result();
      $xml->startElement('typeOfResource'); $xml->writeAttribute('collection', 'yes'); $this->xmlWrite($xml, 'mixed material'); $xml->endElement();
      $xml->startElement('identifier'); $xml->writeAttribute('type', 'isbn'); $this->xmlWrite($xml, str_replace(array('-', ' '), '', $_biblio_d['isbn_issn'])); $xml->endElement();

      // imprint/publication data
      $xml->startElement('originInfo');
      $xml->startElement('place');
          $xml->startElement('placeTerm'); $xml->writeAttribute('type', 'text'); $this->xmlWrite($xml, $_biblio_d['publish_place']); $xml->endElement();
          $xml->startElement('publisher'); $this->xmlWrite($xml, $_biblio_d['publisher']); $xml->endElement();
          $xml->startElement('dateIssued'); $this->xmlWrite($xml, $_biblio_d['publish_year']); $xml->endElement();
      $xml->endElement();
      $xml->endElement();

      // digital files
      $attachment_q = $this->obj_db->query('SELECT att.*, f.* FROM biblio_attachment AS att
          LEFT JOIN files AS f ON att.file_id=f.file_id WHERE att.biblio_id='.$_biblio_d['biblio_id'].' AND att.access_type=\'public\' LIMIT 20');
      if ($attachment_q->num_rows > 0) {
          $xml->startElementNS('slims','digitals', null);
          while ($attachment_d = $attachment_q->fetch_assoc()) {
              // check member type privileges
              if ($attachment_d['access_limit']) { continue; }
              $xml->startElementNS('slims','digital_item', null);
              $xml->writeAttribute('id', $attachment_d['file_id']);
              $xml->writeAttribute('url', trim($attachment_d['file_url']));
              $xml->writeAttribute('path', $attachment_d['file_dir'].'/'.$attachment_d['file_name']);
              $xml->writeAttribute('mimetype', $attachment_d['mime_type']);
              $xml->writeCData($attachment_d['file_title']);
              $xml->endElement();
          }
          $xml->endElement();
      }

      // images
      $_image = '';
      if (!empty($_biblio_d['image'])) {
        $_image = urlencode($_biblio_d['image']);
	    $xml->startElementNS('slims', 'image', null); $this->xmlWrite($xml, $_image); $xml->endElement();
      }

      $xml->endElement(); // MODS
    }
    // free resultset memory
    $this->resultset->free_result();

	$xml->endElement();
    $_buffer .= $xml->flush();
    // $_buffer .= '</modsCollection>';

    return $_buffer;
  }


  /**
   * Method to make an output of document records in JSON-LD format
   *
   * @return  string
   */
  public function JSONLDresult() {
    global $sysconf;
    $jsonld['@context'] = 'http://schema.org';
    $jsonld['@type'] = 'Book';

    // loop data
    $jsonld['total_rows'] = $this->num_rows;
    $jsonld['page'] = $this->current_page;
    $jsonld['records_each_page'] = $this->num2show;
    $jsonld['@graph'] = array();
	while ($_biblio_d = $this->resultset->fetch_assoc()) {
      $record = array();
      $record['@id'] = 'http://'.$_SERVER['SERVER_NAME'].SWB.'index.php?p=show_detail&id='.$_biblio_d['biblio_id'];
      $record['name'] = trim($_biblio_d['title']);

      // get the authors data
      $_biblio_authors_q = $this->obj_db->query('SELECT a.*,ba.level FROM mst_author AS a'
        .' LEFT JOIN biblio_author AS ba ON a.author_id=ba.author_id WHERE ba.biblio_id='.$_biblio_d['biblio_id']);
	  $record['author'] = array();
      while ($_auth_d = $_biblio_authors_q->fetch_assoc()) {
		$record['author']['name'][] = trim($_auth_d['author_name']);
      }
      $_biblio_authors_q->free_result();

	  // ISBN
	  $record['isbn'] = $_biblio_d['isbn_issn'];

	  // publisher
	  $record['publisher'] = $_biblio_d['publisher'];

	  // publish date
	  $record['dateCreated'] = $_biblio_d['publish_year'];

			// doc images
      $_image = '';
      if (!empty($_biblio_d['image'])) {
        $_image = urlencode($_biblio_d['image']);
		$record['image'] = $_image;
      }

	  $jsonld['@graph'][] = $record;
    }

    // free resultset memory
    $this->resultset->free_result();

    return str_ireplace('\/', '/', json_encode($jsonld));
  }



  /**
   * Method to make an output of document records in simple XML format
   *
   * @return  string
   */
  public function RSSresult() {
    global $sysconf;
    // loop data
    $_buffer = '<rss version="2.0">'."\n";
    $_buffer .= '<channel>'."\n";
    $_buffer .= '<title><![CDATA[Collection of '.$sysconf['library_name'].']]></title>'."\n";
    $_buffer .= '<link><![CDATA[http://'.$_SERVER['SERVER_NAME'].SWB.']]></link>'."\n";
    $_buffer .= '<description><![CDATA[New collection of '.$sysconf['library_name'].']]></description>'."\n";
    $_buffer .= "\n";

    while ($_biblio_d = $this->resultset->fetch_assoc()) {
      $_buffer .= '<item>'."\n";
      $_buffer .= ' <title><![CDATA['.trim($_biblio_d['title']).']]></title>'."\n";
      $_buffer .= ' <link><![CDATA[http://'.$_SERVER['SERVER_NAME'].SWB.'/index.php?p=show_detail&id='.$_biblio_d['biblio_id'].']]></link>'."\n";
      $_buffer .= ' <pubDate><![CDATA['.date('D, d F Y H:i:s', strtotime($_biblio_d['input_date'])).']]></pubDate>'."\n";

      // get the authors data
      $_authors = $this->getAuthors($this->obj_db, $_biblio_d['biblio_id']);
			// remove last comma
      $_buffer .= ' <author><![CDATA['.$_authors.']]></author>'."\n";

      $_buffer .= '<description><![CDATA[Author: '.$_authors.' ISBN: '.$_biblio_d['isbn_issn'].']]></description>'."\n";
      $_buffer .= '</item>'."\n";
    }
    $_buffer .= '</channel>';
    $_buffer .= '</rss>';

    // free resultset memory
    $this->resultset->free_result();

    return $_buffer;
  }

  private function xmlWrite(&$xmlwriter, $data, $mode = 'Text') {
	if ($mode == 'CData') {
	  $xmlwriter->writeCData($data);
	} else {
	  $xmlwriter->text($data);
	}
  }
}

================================================================================
File: biblio_list_sphinx.inc.php
================================================================================

<?php
/**
 * biblio_list class
 * Class for generating list of bibliographic records from SPHINX index
 *
 * Copyright (C) 2010 Arie Nugraha (dicarve@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

class biblio_list extends biblio_list_model
{
    protected $options = array('host' => '127.0.0.1', 'port' => 9312, 'index' => 'slims',
	    'mode' => null, 'timeout' => 0, 'filter' => '@last_update desc',
	    'filtervals' => array(), 'groupby' => null, 'groupsort' => null,
	    'sortby' => null, 'sortexpr' => null, 'distinct' => 'biblio_id',
	    'select' => null, 'limit' => 20, 'max_limit' => 500000,
	    'ranker' => null);
    protected $offset = 0;
    private $sphinx = null;
    private $sphinx_error = false;
    private $no_query = false;
    private $sphinx_no_result = false;

    /**
     * Class Constructor
     *
     * @param   object  $obj_db
     * @param   integer	$int_num_show
     */
    public function __construct($obj_db, $int_num_show) {
      parent::__construct($obj_db, $int_num_show);
	    if (!class_exists('SphinxClient')) {
	      throw new Exception('SPHINX API Library is not installed yet!');
	    } else {
	      $this->sphinx = new SphinxClient();
	      // check searchd status
	      $_sphinx_status = $this->sphinx->Status();
	      if (!$_sphinx_status) {
		      throw new Exception('SPHINX Server is not running! Please
			      check if it already configured correctly.');
	      }

	      // defaults
	      $this->options['mode'] = SPH_MATCH_EXTENDED2;
	      $this->options['ranker'] = SPH_RANK_PROXIMITY_BM25;

	      // get page number from http get var
	      if (!isset($_GET['page']) OR $_GET['page'] < 1){ $_page = 1; } else {
		      $_page = (integer)$_GET['page'];
	      }
  	    $this->current_page = $_page;

	      // count the row offset
	      if ($this->current_page <= 1) { $_offset = 0; } else {
		      $this->offset = ($this->current_page*$this->num2show) - $this->num2show;
	      }
	    }
    }


    /**
     * Compile SQL
     *
     * @return  string
     */
    public function compileSQL()
    {
	     $_sql_str = 'SELECT SQL_CALC_FOUND_ROWS index.biblio_id, index.title,
	     	 index.author, index.image, index.isbn_issn, index.labels, index.publisher, index.publish_place, index.publish_year
	     	 FROM search_biblio AS `index`';
	     if (isset($this->criteria['sql_criteria'])) {
	     	 $_sql_str .= ' WHERE '.$this->criteria['sql_criteria'];
	     } else if ($this->sphinx_no_result) {
	     	 $_sql_str .= " WHERE index.biblio_id<0";
	     } else {
	     	 $this->no_query = true;
	     	 $_sql_str .= " WHERE index.biblio_id IS NOT NULL";
	     }
	     // ordering
	     $_sql_str .= ' ORDER BY index.last_update DESC ';
	     // set limit when query is empty
	     if (!isset($this->criteria['sql_criteria']) || $this->no_query) {
	     	 $_sql_str .= ' LIMIT '.$this->offset.','.$this->num2show;
	     }
	     return $_sql_str;
    }


    /**
     * Method to print out document records
     *
     * @param   object  $obj_db
     * @param   integer $int_num2show
     * @param   boolean $bool_return_output
     * @return  string
     */
    public function getDocumentList($bool_return_output = true) {
	    global $sysconf;
	    if ($this->sphinx_error) {
	    	$this->resultset = false;
	    } else {
	        $_sql_str = $this->compileSQL();
	        if ($this->no_query) {
	    	  // start time
	    	  $_start = function_exists('microtime')?microtime(true):time();
	    	  // execute query
	    	  $this->resultset = $this->obj_db->query($_sql_str);
	    	  if ($this->obj_db->error) {
	    	      $this->query_error = $this->obj_db->error;
	    	  }
	    	  // get total number of rows from query
	    	  $_total_q = $this->obj_db->query('SELECT FOUND_ROWS()');
	    	  $_total_d = $_total_q->fetch_row();
	    	  $this->num_rows = $_total_d[0];
	    	  // end time
	    	  $_end = function_exists('microtime')?microtime(true):time();
	    	  $this->query_time = round($_end-$_start, 5);
	        } else {
	    	    $this->resultset = $this->obj_db->query($_sql_str);
	        }

	        if ($this->obj_db->error) {
	    	    $this->query_error = $this->obj_db->error;
	        }
	    }

	    if ($bool_return_output) {
	      // return the html result
	      return $this->makeOutput();
	    }
    }


    /**
     * Set sphinx search option
     *
     * @param	array  $arr_options
     * @return	void
     */
    public function setOptions($arr_options) {
	    $this->options = $arr_options;
    }


    /**
     * Method to set search criteria
     *
     * @param   string  $str_criteria
     * @return  void
     */
    public function setSQLcriteria($str_criteria) {
      if (!$str_criteria) return null;
      // defaults
      $_query_str = '';
      $_searched_fields = array();
      $_previous_field = '';
      $_boolean = '';
			$_b = '';
      // parse query
      $this->orig_query = $str_criteria;
      $_queries = simbio_tokenizeCQL($str_criteria, $this->searchable_fields, $this->stop_words, $this->queries_word_num_allowed);
      // var_dump($_queries);
      if (count($_queries) < 1) { return null; }
      // loop each query
	    // echo '<pre>'; var_dump($_queries); echo '</pre>';
      foreach ($_queries as $_num => $_query) {
        // field
        $_field = $_query['f'];
				if ($_previous_field <> $_field) {
						if ($_field != 'boolean') {
						  $_query_str .= '';
						} else {
						  $_query_str .= ')';
						}
				}

        //  break the loop if we meet `cql_end` field
        if ($_field == 'cql_end') { continue; }
	      // if field is boolean
	      if ($_field == 'boolean') {
		      if ($_query['b'] == '*') { $_query_str .= ' | '; } else { $_query_str .= ' & '; }
		      continue;
	      } else {
		      if ($_query['b'] == '-') {
						$_query_str .= ' -';
				  } else if ($_query['b'] == '*') {
						$_query_str .= ' | ';
				  } else {
						$_query_str .= ' ';
					}
		      $_q = @$this->obj_db->escape_string($_query['q']);
		      $_q = isset($_query['is_phrase'])?'"'.$_q.'"':$_q;
		      $_boolean = '';
	      }
				if ($_previous_field == $_field) {
          $_query_str .= $_q;
					continue;
				}
				$_previous_field = $_field;
        // for debugging purpose only
        // echo "<p>$_num. $_field -> $_boolean -> $_query_str</p><p>&nbsp;</p>";

	      // check fields
				$_q = $_b.$_q;
        switch ($_field) {
          case 'author' :
		      $_query_str .= " (@author $_q";
          break;
          case 'subject' :
		      $_query_str .= " (@topic $_q";
          break;
          case 'location' :
		      $_query_str .= " (@location $_q";
          break;
          case 'colltype' :
		      $_query_str .= " (@collection_types $_q";
          break;
          case 'itemcode' :
		      $_query_str .= " (@items $_q";
          break;
          case 'callnumber' :
		      $_query_str .= " (@call_number $_q";
          break;
          case 'itemcallnumber' :
		      $_query_str .= " (@item_call_number $_q";
          break;
          case 'class' :
		      $_query_str .= " (@classification $_q";
          break;
          case 'isbn' :
		      $_query_str .= " (@isbn_issn $_q";
          break;
          case 'publisher' :
		      $_query_str .= " (@publisher $_q";
          break;
          case 'publishyear' :
		      $_query_str .= " (@publish_year $_q";
          break;
          case 'gmd' :
		      $_query_str .= " (@gmd $_q";
          break;
          case 'notes' :
		      $_query_str .= " (@notes $_q";
          break;
          default :
		      $_query_str .= " (@title $_q";
          break;
        }
      }

      $_query_str .= ')';
	  
	    // check if query is empty
	    if (!$_query_str) {
	      $this->no_query = true;
	      $_sql_criteria = 'index.biblio_id IS NOT NULL';
	      $this->criteria = array('sql_criteria' => $_sql_criteria, 'searched_fields' => $_searched_fields);
	      return $this->criteria;
	    }

	    // set options
	    $this->sphinx->SetServer ( $this->options['host'], $this->options['port'] );
	    $this->sphinx->SetConnectTimeout ( $this->options['timeout'] );
	    $this->sphinx->SetArrayResult ( true );
	    $this->sphinx->SetWeights ( array ( 100, 1 ) );
	    $this->sphinx->SetMatchMode ( $this->options['mode'] );
	    if (count($this->options['filtervals'])) { $this->sphinx->SetFilter ( $this->options['filter'], $this->options['filtervals'] ); }
	    if ($this->options['groupby']) { $this->sphinx->SetGroupBy ( $this->options['groupby'], SPH_GROUPBY_ATTR, $this->options['groupsort'] ); }
	    if ($this->options['sortby']) {
	      $this->sphinx->SetSortMode ( SPH_SORT_EXTENDED, $this->options['sortby'] );
	      $this->sphinx->SetSortMode ( SPH_SORT_EXPR, $this->options['sortexpr'] );
	    }
	    $this->sphinx->SetGroupDistinct ( $this->options['distinct'] );
	    if ($this->options['select']) { $this->sphinx->SetSelect ( $this->options['select'] ); }
	    $this->sphinx->SetLimits ( $this->offset, $this->num2show?$this->num2show:$this->options['limit'], $this->options['max_limit'] );
	    $this->sphinx->SetRankingMode ( $this->options['ranker'] );

	    // invoke sphinx query
	    $_search_result = $this->sphinx->Query($_query_str, $this->options['index']);

	    // echo '<pre>'; var_dump($_search_result); echo '</pre>'; die();
	    if ($_search_result === false) {
	      $this->sphinx_error = true;
	      $this->query_error = $this->sphinx->GetLastError();
	      return false;
	    }

	    if (isset($_search_result['matches']) && is_array($_search_result['matches'])) {
	      $_matched_ids = '(';
	      foreach ($_search_result['matches'] as $_match) {
	    	  $_matched_ids .= $_match['id'].',';
	      }
	      // remove last comma
	      $_matched_ids = substr_replace($_matched_ids, '', -1);
	      $_matched_ids .= ')';
	      $_sql_criteria = "index.biblio_id IN $_matched_ids";

	      $this->num_rows = $_search_result['total_found'];
	      $this->query_time = $_search_result['time'];
	      $this->criteria = array('sql_criteria' => $_sql_criteria, 'searched_fields' => $_searched_fields);

	      return $this->criteria;
	    } else {
	      $this->sphinx_no_result = true;
	      return false;
	    }
    }
}

================================================================================
File: biblio_list_sqlite.inc.php
================================================================================

<?php
/**
 * biblio_list class
 * Class for generating list of bibliographic records from sqlite
 *
 * Copyright (C) 2009 Arie Nugraha (dicarve@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
  die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
  die("can not access this file directly");
}

class biblio_list extends biblio_list_model {
  /**
   * Class Constructor
   *
   * @param   object  $obj_db
   * @param   integer	$int_num_show
   */
  public function __construct($obj_db, $int_num_show) {
    parent::__construct($obj_db, $int_num_show);
  }


  /**
   * Method to set search criteria
   *
   * @param   string  $str_criteria
   * @return  void
   */
  public function setSQLcriteria($str_criteria) {
    if (!$str_criteria) return null;
    // defaults
    $_sql_criteria = '';
    $_searched_fields = array();
    $_title_buffer = '';
    $_previous_field = '';
    $_boolean = '';
    // parse query
    $this->orig_query = $str_criteria;
    $_queries = simbio_tokenizeCQL($str_criteria, $this->searchable_fields, $this->stop_words, $this->queries_word_num_allowed);
    // echo '<pre>'; var_dump($_queries); echo '</pre>';
    if (count($_queries) < 1) {
      return null;
    }
    // loop each query
    foreach ($_queries as $_num => $_query) {
      // field
      $_field = $_query['f'];
      // boolean
      if ($_title_buffer == '' && $_field != 'boolean') {
        $_sql_criteria .= " $_boolean ";
      }
      //  break the loop if we meet `cql_end` field
      if ($_field == 'cql_end') { break; }
      // boolean mode
      $_b = isset($_query['b'])?$_query['b']:$_query;
      if ($_b == '*') {
        $_boolean = 'OR';
      } else { $_boolean = 'AND'; }
      // search value
      $_q = @$this->obj_db->escape_string($_query['q']);
      // searched fields flag set
      $_searched_fields[$_field] = 1;
      $_previous_field = $_field;
      switch ($_field) {
      case 'location' :
			  if (!$this->disable_item_data) {
			    if ($_b == '-') {
			  	  $_sql_criteria .= " biblio.location NOT LIKE '%$_q%'";
			    } else { $_sql_criteria .= " biblio.location LIKE '%$_q%'"; }
			  }
        break;
      case 'colltype' :
			  if (!$this->disable_item_data) {
			    if ($_b == '-') {
			  	  $_sql_criteria .= " biblio.collection_types NOT LIKE '%$_q%'";
			    } else { $_sql_criteria .= " biblio.collection_types NOT LIKE ($_subquery)"; }
			  }
        break;
      case 'itemcode' :
			  if (!$this->disable_item_data) {
			    if ($_b == '-') {
			  	$_sql_criteria .= " biblio.items NOT LIKE '%$_q%'";
			    } else { $_sql_criteria .= " biblio.items LIKE '%$_q%'"; }
			  }
        break;
      case 'callnumber' :
            if ($_b == '-') {
              $_sql_criteria .= ' biblio.call_number NOT LIKE \''.$_q.'%\'';
            } else { $_sql_criteria .= ' biblio.call_number LIKE \''.$_q.'%\''; }
            break;
      case 'itemcallnumber' :
			if (!$this->disable_item_data) {
			  if ($_b == '-') {
				  $_sql_criteria .= ' item.call_number NOT LIKE \''.$_q.'%\'';
			  } else { $_sql_criteria .= ' item.call_number LIKE \''.$_q.'%\''; }
			}
            break;
          case 'class' :
            if ($_b == '-') {
              $_sql_criteria .= ' biblio.classification NOT LIKE \''.$_q.'%\'';
            } else { $_sql_criteria .= ' biblio.classification LIKE \''.$_q.'%\''; }
            break;
          case 'isbn' :
            if ($_b == '-') {
              $_sql_criteria .= ' biblio.isbn_issn!=\''.$_q.'\'';
            } else { $_sql_criteria .= ' biblio.isbn_issn=\''.$_q.'\''; }
            break;
          case 'publisher' :
            $_subquery = 'SELECT publisher_id FROM mst_publisher WHERE publisher_name LIKE \'%'.$_q.'%\'';
            if ($_b == '-') {
              $_sql_criteria .= " biblio.publisher_id NOT IN ($_subquery)";
            } else { $_sql_criteria .= " biblio.publisher_id IN ($_subquery)"; }
            break;
          case 'publishyear' :
            if ($_b == '-') {
              $_sql_criteria .= ' biblio.publish_year!=\''.$_q.'\'';
            } else { $_sql_criteria .= ' biblio.publish_year=\''.$_q.'\''; }
            break;
          case 'gmd' :
            $_subquery = 'SELECT gmd_id FROM mst_gmd WHERE gmd_name=\''.$_q.'\'';
            if ($_b == '-') {
              $_sql_criteria .= " biblio.gmd_id NOT IN ($_subquery)";
            } else { $_sql_criteria .= " biblio.gmd_id IN ($_subquery)"; }
            break;
          case 'notes' :
			$_q = isset($_query['is_phrase'])?'"'.$_q.'"':$_q;
            if ($_b == '-') {
              $_sql_criteria .= " NOT (MATCH (biblio.notes) AGAINST ('".$_q."' IN BOOLEAN MODE))";
            } else { $_sql_criteria .= " (MATCH (biblio.notes) AGAINST ('".$_q."' IN BOOLEAN MODE))"; }
            break;
        }
    }

    // remove boolean's logic symbol prefix and suffix
    $_sql_criteria = preg_replace('@^(AND|OR|NOT)\s*|\s+(AND|OR|NOT)$@i', '', trim($_sql_criteria));
    // below for debugging purpose only
    // echo "<div style=\"border: 1px solid #f00; padding: 5px; color: #f00; margin: 5px;\">$_sql_criteria</div>";

    $this->criteria = array('sql_criteria' => $_sql_criteria, 'searched_fields' => $_searched_fields);
    return $this->criteria;
  }


  /**
   * Method to print out document records
   *
   * @param   object  $obj_db
   * @param   integer $int_num2show
   * @param   boolean $bool_return_output
   * @return  string
   */
  public function compileSQL() {
    global $sysconf;
    // get page number from http get var
    if (!isset($_GET['page']) OR $_GET['page'] < 1){
      $_page = 1;
    } else{
      $_page = (integer)$_GET['page'];
    }
    $this->current_page = $_page;

    // count the row offset
    if ($_page <= 1) {
      $_offset = 0;
    } else {
      $_offset = ($_page*$this->num2show) - $this->num2show;
    }

    // init sql string
    $_sql_str = 'SELECT SQL_CALC_FOUND_ROWS biblio.biblio_id, biblio.title, biblio.image, biblio.isbn_issn,
			biblio.publish_year, pbl.publisher_name AS `publisher`, pplc.place_name AS `publish_place`, biblio.labels, biblio.input_date';

    // checking custom frontpage fields file
    $custom_frontpage_record_file = SB.$sysconf['template']['dir'].'/'.$sysconf['template']['theme'].'/custom_frontpage_record.inc.php';
    if (file_exists($custom_frontpage_record_file)) {
      include $custom_frontpage_record_file;
      $this->enable_custom_frontpage = true;
      $this->custom_fields = $custom_fields;
      foreach ($this->custom_fields as $_field => $_field_opts) {
        if ($_field_opts[0] == 1 && !in_array($_field, array('availability', 'isbn_issn'))) {
          $_sql_str .= ", biblio.$_field";
        }
      }
    }

    // additional SQL string
    $_add_sql_str = ' LEFT JOIN mst_publisher AS pbl ON biblio.publisher_id=pbl.publisher_id ';
    $_add_sql_str .= ' LEFT JOIN mst_place AS pplc ON biblio.publish_place_id=pplc.place_id ';

    // location
    if ($this->criteria) {
      if (isset($this->criteria['searched_fields']['location']) || isset($this->criteria['searched_fields']['colltype'])) {
        if (!$this->disable_item_data) {
				  $_add_sql_str .= ' LEFT JOIN item ON biblio.biblio_id=item.biblio_id ';
				}
      }
    }

    $_add_sql_str .= ' WHERE opac_hide=0 ';
    // promoted flag
    if ($this->only_promoted) { $_add_sql_str .= ' AND promoted=1'; }
    // main search criteria
    if ($this->criteria) {
      $_add_sql_str .= ' AND ('.$this->criteria['sql_criteria'].') ';
    }

    $_sql_str .= ' FROM biblio '.$_add_sql_str.' ORDER BY biblio.last_update DESC LIMIT '.$_offset.', '.$this->num2show;
    // for debugging purpose only
    // echo "<div style=\"border: 1px solid navy; padding: 5px; color: navy; margin: 5px;\">$_sql_str</div>";
	  return $_sql_str;
  }
}

================================================================================
File: biblio_list_mongodb.inc.php
================================================================================

<?php
/**
 * biblio_list class
 * Class for generating list of bibliographic records from MongoDB
 *
 * Copyright (C) 2013 Arie Nugraha (dicarve@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

/**
 * Work around for fetch_assoc method invoked in makeOutput method
 */
class biblio_mongodb_result {
  private $nosql_cursor = false;
	public function __construct(&$obj_nosql_cursor) {
    $this->nosql_cursor = $obj_nosql_cursor;
	}

  public function fetch_assoc() {
    return $this->nosql_cursor->getNext();
	}

  public function free_result() {
    return $this->nosql_cursor->reset();
	}
}

class biblio_list extends biblio_list_model
{
  protected $options = array();
	protected $Biblio = false;
	protected $offset = 0;
	protected $cursor = 0;
	public $current_page = 1;
	public $num2show = 1;

  /**
   * Class Constructor
   *
   * @param   object  $obj_db
   * @param   integer	$int_num_show
   */
  public function __construct($obj_db, $int_num_show) {
    parent::__construct($obj_db, $int_num_show);
	  if (!class_exists('MongoClient')) {
	    throw new Exception('PHP Mongodb extension library is not installed yet!');
	  } else {
	    $Mongo = new MongoClient();
			// select database
			$this->Biblio = $Mongo->slims->biblio;

	    // get page number from http get var
	    if (!isset($_GET['page']) OR $_GET['page'] < 1){ $_page = 1; } else {
	      $_page = (integer)$_GET['page'];
	    }
	    $this->current_page = $_page;

	    // count the row offset
	    if ($this->current_page <= 1) { $_offset = 0; } else {
	      $this->offset = ($this->current_page*$this->num2show) - $this->num2show;
	    }
	  }
  }


  /**
   * Method to print out document records
   *
   * @param   object  $obj_db
   * @param   integer $int_num2show
   * @param   boolean $bool_return_output
   * @return  string
   */
  public function getDocumentList($bool_return_output = true) {
	  global $sysconf;
	  // start time
	  $_start = function_exists('microtime')?microtime(true):time();
	  // execute query
    $this->cursor = $this->Biblio->find($this->criteria['sql_criteria'])->limit($this->num2show);
    $this->cursor->skip($this->offset);
	  // get total number of rows from query
	  $this->num_rows = $this->cursor->count();
		$this->resultset = new biblio_mongodb_result($this->cursor);
	  // end time
	  $_end = function_exists('microtime')?microtime(true):time();
	  $this->query_time = round($_end-$_start, 5);

	  if ($bool_return_output) {
	    // return the html result
	    return $this->makeOutput();
	  }
  }


  /**
   * Set options
   *
   * @param	array  $arr_options
   * @return	void
   */
  public function setOptions($arr_options) {
	  $this->options = $arr_options;
  }


  /**
   * Method to set search criteria
   *
   * @param   string  $str_criteria
   * @return  void
   */
  public function setSQLcriteria($str_criteria) {
    if (!$str_criteria) return null;
    // defaults
    $_query_str = '';
    $_searched_fields = array();
    $_previous_field = '';
    $_boolean = '';
    $_last_field = 'title';
    $_field = 'title';
		$_field_str = '';
		$_mongo_boolean_top = false;
		// parse query
    $this->orig_query = $str_criteria;
    $_queries = simbio_tokenizeCQL($str_criteria, $this->searchable_fields, $this->stop_words, $this->queries_word_num_allowed);
    if (count($_queries) < 1) {
      return null;
    }
    // loop each query
	  // echo '<pre>'; var_dump($_queries); echo '</pre>';
		$_mongo_search = array();
    foreach ($_queries as $_num => $_query) {
      // field
      $_field = $_query['f'];
			$_q = trim($_query['q']);

      //  break the loop if we meet `cql_end` field
      if ($_field == 'cql_end') { continue; }
	    // if field is boolean
	    if ($_field == 'boolean') {
				if ($_query['b'] == '*') {
				  $_mongo_boolean_top ='$or';
				} else if ($_query['b'] == '-') {
          $_mongo_boolean_top ='$not';
				} else {
				  $_mongo_boolean_top = '$and';
				}
				continue;
	    }
			if ($_query['b'] == '*') {
			  $_mongo_boolean_field ='$or';
			} else if ($_query['b'] == '-') {
        $_mongo_boolean_field ='$not';
			} else {
			  $_mongo_boolean_field = '$and';
			}

      $_mongo_search[$_field][$_mongo_boolean_field][] = array($_field => array('$regex' => new MongoRegex('/.*'.$_q.'.*/i')));
		  $_searched_fields[$_field] = $_field;
    }

		// preproccess search criteria to match Mongodb arrays
		$_mongo_search_tmp = $_mongo_search;
		$_mongo_search = array();
    if ($_mongo_boolean_top) {
			foreach ($_mongo_search_tmp as $_search_field => $_search_criteria) {
        foreach ($_search_criteria as $_logic => $_search_expr) {
          $_mongo_search[$_mongo_boolean_top][][$_logic] = $_search_expr;
				}
			}
		} else {
			foreach ($_mongo_search_tmp as $_search_field => $_search_criteria) {
        foreach ($_search_criteria as $_logic => $_search_expr) {
          $_mongo_search[$_logic][] = $_search_expr;
				}
			}
		}
		unset($_mongo_search_tmp);

		// echo '<pre>'; var_dump($_mongo_search); echo '</pre>';
	  // check if query is empty
	  if (!$_mongo_search) {
	    $this->no_query = true;
	    $_mongo_search['biblio_id'] = array('$gt' => 0);
	  }

	  $this->criteria = array('sql_criteria' => $_mongo_search, 'searched_fields' => $_searched_fields);
	  return $this->criteria;
  }
}

================================================================================
File: Cache.php
================================================================================

<?php
/**
 * @author Drajat Hasan
 * @email drajathasan20@gmail.com
 * @create date 2022-11-13 11:33:08
 * @modify date 2022-11-13 23:53:33
 * @license GPLv3
 * @desc
 */

namespace SLiMS;

use Exception;
use SLiMS\Cache\Contract;

class Cache
{
    private object $provider;
    private array $options;
    private static $instance = null;

    /**
     * Cache initialization
     * with some provider like Files, Redis etc
     *
     * @param string $provider
     * @param array $options
     * @return void
     */
    private function __construct(string $provider, array $options)
    {
        if (!$this->isProviderExists($provider)) throw new Exception("Provider {$provider} is not exists!");

        $this->provider = new $provider(...array_values($options));

        if (!$this->isProviderUseStandart()) throw new Exception("Provider {$provider} is not use Contract class");
    }

    public static function getInstance(string $provider, array $options)
    {
        if (is_null(self::$instance)) self::$instance = new Cache($provider, $options);
        return self::$instance;
    }

    /**
     * @param string $provider
     * @return boolean
     */
    public function isProviderExists(string $provider)
    {
        return class_exists($provider);
    }

    /**
     * Make sure provider is use
     * cache contract
     *
     * @return bool
     */
    public function isProviderUseStandart()
    {
        return $this->provider instanceof Contract;
    }

    public static function init(string $cacheProviderName = '')
    {
        $cacheConfig = config('cache');

        if (is_null($cacheConfig)) throw new Exception("Cache config isn't exists!");

        if (empty($cacheProviderName)) $cacheProviderName = $cacheConfig['default']??'Files';
        
        $cacheProviderDetail = $cacheConfig['providers'][$cacheProviderName];
        
        return self::getInstance($cacheProviderDetail['class'], $cacheProviderDetail['options']);
    }

    /**
     * Magic function to communicated
     * with cache provider with static class call
     *
     * @param string $method
     * @param array $arguments
     * @return void
     */
    public static function __callStatic($method, $arguments)
    {
        return self::init()->provider->{$method}(...$arguments);
    }

    /**
     * Magic function to communicated
     * with cache provider with static class call
     *
     * @param string $method
     * @param array $arguments
     * @return void
     */
    public function __call($method, $arguments)
    {
        return self::init()->provider->{$method}(...$arguments);
    }
}
================================================================================
File: circulation_api.inc.php
================================================================================

<?php
/**
 * API class
 * A Collection of API static utility methods
 *
 * Copyright (C) 2016  Hendro Wicaksono (hendrowicaksono@gmail.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

class circapi
{
  public static function loan_load($obj_db, $member_id, $onloan = FALSE)
  {
    $s_loa = 'SELECT * ';
    $s_loa .= 'FROM loan AS l ';
    $s_loa .= 'WHERE l.member_id=\''.$member_id.'\'';
    if ($onloan) {
      $s_loa .= ' AND l.is_return=\'0\')';
    }
    $q_loa = $obj_db->query($s_loa);
    $_return = NULL;
    if (!$obj_db->errno) {
      $i = 0;
      while ($r_loa = $q_loa->fetch_assoc()) {
        $_return[$i]['loan_id'] = $r_loa['loan_id'];
        $_return[$i]['item_code'] = $r_loa['item_code'];
        $_return[$i]['member_id'] = $r_loa['member_id'];
        $_return[$i]['loan_date'] = $r_loa['loan_date'];
        $_return[$i]['due_date'] = $r_loa['due_date'];
        $_return[$i]['renewed'] = $r_loa['renewed'];
        $_return[$i]['loan_rules_id'] = $r_loa['loan_rules_id'];
        $_return[$i]['actual'] = $r_loa['actual'];
        $_return[$i]['is_lent'] = $r_loa['is_lent'];
        $_return[$i]['is_return'] = $r_loa['is_return'];
        $_return[$i]['return_date'] = $r_loa['return_date'];
        $i++;
      }
    }
    return api::to_object($_return);
  }

  public static function loan_extended($obj_db, $member_id, $loan_id)
  {
    $_sql_loaninfo = 'SELECT l.* FROM loan AS l
      WHERE loan_id=\''.$loan_id.'\'
      ';
    $_stmt_loaninfo = $obj_db->query($_sql_loaninfo);
    $_count_loaninfo = mysqli_num_rows($_stmt_loaninfo);
    if ($_count_loaninfo === 1) {
      while($row_loaninfo = $_stmt_loaninfo->fetch_assoc()) {
        $_loan_rules_id = $row_loaninfo['loan_rules_id'];
      }
    }
    $_today = date('Y-m-d');
    if ($_loan_rules_id === '0') {
      $_sql_llist = ' SELECT l.*, m.*, i.*, b.*, mmt.* 
        FROM loan AS l, member AS m, item AS i, biblio AS b, mst_member_type AS mmt
        WHERE
        l.member_id=m.member_id
        AND l.item_code=i.item_code 
        AND i.biblio_id=b.biblio_id
        AND m.member_type_id=mmt.member_type_id
        AND is_lent=1
        AND is_return=0
        AND l.loan_id=\''.$loan_id.'\'
        AND l.renewed < mmt.reborrow_limit 
        AND m.expire_date > '.$_today.'
        AND l.member_id=\''.$member_id.'\'';
    } else {
      $_sql_llist = ' SELECT l.*, m.*, i.*, b.*, mlr.* 
        FROM loan AS l, member AS m, item AS i, biblio AS b, mst_loan_rules AS mlr
        WHERE
        l.member_id=m.member_id
        AND l.item_code=i.item_code 
        AND i.biblio_id=b.biblio_id
        AND is_lent=1
        AND is_return=0
        AND l.loan_id=\''.$_POST['loan_id'].'\'
        AND l.renewed < mlr.reborrow_limit 
        AND m.expire_date > '.$vars['global']['today'].'
        AND l.member_id=\''.$_SESSION['member_id'].'\'';
    }
    $_stmt_llist = $obj_db->query($_sql_llist);
    $_count_llist = mysqli_num_rows($_stmt_llist);
    if ($_count_llist === 1) {
      while($row = $_stmt_llist->fetch_assoc()) {
        $_old_dd = $row['due_date'];
        $_loan_periode = $row['loan_periode'];
        $_renewed = $row['renewed'];
        $_fine_each_day = $row['fine_each_day'];
        $_member_id = $row['member_id'];
        $_title = $row['title'];
        $_item_code = $row['item_code'];
      }
      $_new_dd = date('Y-m-d', strtotime('+'.$_loan_periode.' day'));
      $_new_dd_name = strtolower(date('D', strtotime('+'.$_loan_periode.' day')));
      do {
        $_sql_holiday = 'SELECT * FROM holiday WHERE holiday_date=\''.$_new_dd.'\'';
        $_stmt_holiday = $obj_db->query($_sql_holiday);
        $_counter = mysqli_num_rows($_stmt_holiday);
        $_sql_aholiday = 'SELECT * FROM holiday WHERE holiday_date IS NULL AND holiday_dayname=\''.$_new_dd_name.'\'';
        $_stmt_aholiday = $obj_db->query($_sql_aholiday);
        $_countera = mysqli_num_rows($_stmt_aholiday);
        if ( ($_counter > 0) OR ($_countera > 0) ){
          $_loan_periode = $_loan_periode + 1;
          $_new_dd = date('Y-m-d', strtotime('+'.$_loan_periode.' day'));
          $_new_dd_name = strtolower(date('D', strtotime('+'.$_loan_periode.' day')));
        }
        $i = 0;
      } while ( ($_counter > 0) OR ($_countera > 0) );
      $_renewed = $_renewed + 1;
      $_sql_doextend = 'UPDATE loan SET due_date=\''.$_new_dd.'\', renewed=\''.$_renewed.'\' WHERE loan_id='.$loan_id;
      $_stmt_doextend = $obj_db->query($_sql_doextend);
      if ($_today > $_old_dd) {
        $_uts_duedate = DateTime::createFromFormat('Y-m-d', $_old_dd);
        $uts_duedate = (int) $_uts_duedate->format('U');
        $_uts_today = DateTime::createFromFormat('Y-m-d', $_today);
        $uts_today = (int) $_uts_today->format('U');
        $late_days = ($uts_today - $uts_duedate) / 86400;
        $total_fines = $late_days * $_fine_each_day;
        $_sql_fines = 'INSERT INTO fines VALUES (NULL, \''.$_today.'\', \''.$member_id.'\', \''.$total_fines.'\', \'0\', \'Overdue fines for item '.$_item_code.'\')';
        $_stmt_fines = $obj_db->query($_sql_fines);
      }
      if ($_stmt_doextend) {
        return TRUE;
      }
    }
    return FALSE;
  }

  public static function is_any_active_loanrules($obj_db, $loan_rules_id)
  {
    $s_lr = 'SELECT l.loan_id ';
    $s_lr .= 'FROM loan AS l ';
    $s_lr .= 'WHERE l.loan_rules_id=\''.$loan_rules_id.'\'';
    $s_lr .= ' AND ';
    $s_lr .= 'l.is_return=\'0\'';
    $s_lr .= ' AND ';
    $s_lr .= 'l.is_lent=\'1\'';
    $q_lr = $obj_db->query($s_lr);
    $c_lr = mysqli_num_rows($q_lr);
    if ($c_lr > 0) {
      return TRUE;
    } else {
      return FALSE;
    }
  }

  public static function is_any_active_membershipType($obj_db, $member_type_id)
  {
    $s_lr = 'SELECT mmt.member_type_id, m.member_id, l.loan_id ';
    $s_lr .= 'FROM mst_member_type AS mmt, member AS m, loan AS l ';
    $s_lr .= 'WHERE ';
    $s_lr .= 'mmt.member_type_id=m.member_type_id ';
    $s_lr .= ' AND ';
    $s_lr .= 'm.member_id=l.member_id ';
    $s_lr .= ' AND ';
    $s_lr .= 'mmt.member_type_id=\''.$member_type_id.'\'';
    $s_lr .= ' AND ';
    $s_lr .= 'l.is_return=\'0\'';
    $s_lr .= ' AND ';
    $s_lr .= 'l.is_lent=\'1\'';
    $q_lr = $obj_db->query($s_lr);
    $c_lr = mysqli_num_rows($q_lr);
    if ($c_lr > 0) {
      return TRUE;
    } else {
      return FALSE;
    }
  }

  public static function loan_load_by_id($obj_db, $loan_id)
  {
    $s_loa = 'SELECT * ';
    $s_loa .= 'FROM loan AS l ';
    $s_loa .= 'WHERE l.loan_id=\''.$loan_id.'\'';
    $q_loa = $obj_db->query($s_loa);
    $_return = NULL;
    if (!$obj_db->errno) {
      $i = 0;
      while ($r_loa = $q_loa->fetch_assoc()) {
        $_return['loan_id'] = $r_loa['loan_id'];
        $_return['item_code'] = $r_loa['item_code'];
        $_return['member_id'] = $r_loa['member_id'];
        $_return['loan_date'] = $r_loa['loan_date'];
        $_return['due_date'] = $r_loa['due_date'];
        $_return['renewed'] = $r_loa['renewed'];
        $_return['loan_rules_id'] = $r_loa['loan_rules_id'];
        $_return['actual'] = $r_loa['actual'];
        $_return['is_lent'] = $r_loa['is_lent'];
        $_return['is_return'] = $r_loa['is_return'];
        $_return['return_date'] = $r_loa['return_date'];
        $_return['input_date'] = $r_loa['input_date'];
        $_return['last_update'] = $r_loa['last_update'];
        $_return['uid'] = $r_loa['uid'];
        $i++;
      }
    }
    return api::to_object($_return);
  }

}

================================================================================
File: comment.inc.php
================================================================================

<?php
/**
 * Comment class
 * Class for record comment
 *
 * Copyright (C) 2007,2008  Arie Nugraha (dicarve@yahoo.com)
 * Some security patches by Hendro Wicaksono (hendrowicaksono@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

function showComment($_detail_id)
    {
		global $dbs;
        require SIMBIO.'simbio_GUI/paging/simbio_paging.inc.php';
		$_list_comment = '';
		if (!is_null(config('3rd_party_comment')))
		{
			// execute registered hook for 3rd party comment management
			\SLiMS\Plugins::getInstance()->execute('comment_init', [&$_list_comment]);
			return $_list_comment;
		}
		$_recs_each_page = 3;
		$_pages_each_set = 10;
		$_all_recs = 0;
		$_detail_id = (int)$_detail_id;
		
		if (ISSET($_GET['page']) && $_GET['page']>1) {
			$page = (int)$_GET['page'];
		} else {
			$page  = 1;
		}
		$_sql = "Select c.comment, m.member_name, c.input_date from comment AS c
		 LEFT JOIN biblio AS b ON b.biblio_id = c.biblio_id
		 LEFT JOIN member AS m ON m.member_id = c.member_id
		 WHERE b.biblio_id =".$_detail_id.
		 " ORDER BY c.last_update DESC";
		$commlist = $dbs->query($_sql);
		if ($commlist) {
			$_all_recs = $commlist->num_rows;
		}
		if ($_all_recs >0) {
			$_page = ($page -1) * $_recs_each_page;
			$_sql .= " Limit " . $_page. ", " . $_recs_each_page;
			$commlist = $dbs->query($_sql);
			$_list_comment .= '<div class="comment-found">'. $_all_recs . __(' comments available'). '</div>'; 
			while ($_data = $commlist->fetch_assoc()) {
				$_list_comment .= '<div class="comments">';
				$_list_comment .= '<div class="comment-member">'.$_data['member_name']. __(' at ') . $_data['input_date']. __(' write'). '</div>';
				$_list_comment .= '<div class="comment-content mt-2">'. $_data['comment'] . '</div>';
				$_list_comment .= '</div>';		
			}
			$_list_comment .= '<div class="comment-found">'.simbio_paging::paging($_all_recs, $_recs_each_page, $int_pages_each_set = 10, '', '_self').'</div>';
		}

		if (ISSET($_SESSION['mid'])) {
		// Comment form
			$_forms  = '<form method="post" id="mainForm" action="index.php?p=show_detail&id='.$_detail_id.'" class="comment-form">';
			//$_forms .=  simbio_form_element::textField('textarea','comment','','placeholder="Add your comment" class="comment-input form-control ckeditor"'). '<br />';
			$_forms .= '<div id="container0" class="mb-3" data-field="comment"><div id="ckeditor-toolbar0"></div><div id="ckeditor-content0" style="min-height: 150px"></div></div>';
			$_forms .= '<input type="submit" name="SaveComment" value="Save comment" class="s-btn btn btn-primary">';
			$_forms .= \Volnix\CSRF\CSRF::getHiddenInputString();
			$_forms .= '</form>';
			// ckeditor for rich feature
			$js = '<script type="text/javascript" src="'.JWB.'/ckeditor5/ckeditor.js"></script>';
			$js .= '<script type="text/javascript" src="'.JWB.'/ckeditor5/ckeditor.tinfo.js"></script>';
			$js .= "<script>createMultiEditor('1', '#mainForm', ['bold','italic','bulletedList','numberedList'])</script>";
			// $js .= "<script type=\"text/javascript\">CKEDITOR.config.toolbar = [['Bold','Italic','Underline','StrikeThrough','NumberedList','BulletedList','-','JustifyLeft','JustifyCenter','JustifyRight','JustifyBlock']] ;</script>";

			return $_list_comment.$_forms.$js;
		} else  {
			return $_list_comment;
		}
    }

================================================================================
File: Config.php
================================================================================

<?php
/**
 * @CreatedBy          : Waris Agung Widodo (ido.alit@gmail.com)
 * @Date               : 2020-11-28  20:19:45
 * @FileName           : Config.php
 * @Project            : slims9_bulian
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

namespace SLiMS;


use PDO;

class Config
{
    private static $instance = null;
    private $configs = [];

    public function __construct()
    {
        // load default config folder
        $this->load(__DIR__ . '/../config', ['env.php', 'env.sample.php']);
    }

    /**
     * Get instance of this class
     *
     * @return static|null
     */
    public static function getInstance()
    {
        if (is_null(self::$instance)) self::$instance = new static();
        return self::$instance;
    }

    /**
     * Load configuration files
     *
     * @param $directory
     * @param array $ignore
     */
    function load($directory, $ignore = [])
    {
        $ignore = array_unique(array_merge(['..', '.', 'index.html', 'index.php'], $ignore));
        $scanned_directory = array_diff(scandir($directory), $ignore);
        foreach ($scanned_directory as $file) {
            if (strpos($file, '.php')) {
                $file_path = $directory . DIRECTORY_SEPARATOR . $file;
                $this->configs[basename($file_path, '.php')] = require $file_path;
            }
        }

        // load config from database
        // this will override config file
        $this->loadFromDatabase();
    }

    /**
     * Load app preferences from database
     */
    function loadFromDatabase()
    {
        if (self::getFile('database') === null) return;
        
        $query = DB::getInstance()->query('SELECT setting_name, setting_value FROM setting');
        while ($data = $query->fetch(PDO::FETCH_OBJ)) {
            $value = @unserialize($data->setting_value);
            if (is_array($value)) {
                foreach ($value as $id => $current_value) {
                    $this->configs[$data->setting_name][$id] = $current_value;
                }
            } else {
                $this->configs[$data->setting_name] = stripslashes($value??'');
            }
        }
    }

    /**
     * Get config with dot separator
     *
     * @param $key
     * @param null $default
     * @return mixed|null
     */
    public function get($key, $default = null)
    {
        $keys = explode('.', $key);
        $config = $default;
        foreach ($keys as $index => $_key) {
            if ($index < 1) {
                $config = $this->configs[$_key] ?? $default;
                continue;
            }
            if ($config === $default) break;
            if (isset($config[$_key])) {
                $config = $config[$_key];
            } else {
                $config = $default;
            }
        }

        // if result is null, try to get global $sysconf
        if (is_null($config)) $config = $this->getGlobal($key, $default);

        return $config;
    }

    /**
     * Get data with dot separator
     *
     * @param string $key
     * @param stirng $default
     * @return array|null
     */
    public function getGlobal($key, $default = null)
    {
        global $sysconf;
        $keys = explode('.', $key);
        $config = $default;
        foreach ($keys as $index => $_key) {
            if ($index < 1) {
                $config = $sysconf[$_key] ?? $default;
                continue;
            }
            if ($config === $default) break;
            if (isset($config[$_key])) {
                $config = $config[$_key];
            } else {
                $config = $default;
            }
        }
        return $config;
    }

    /**
     * Get config as plain text
     */
    public static function getFile(string $filename)
    {
        return file_exists($path = SB . 'config/' . $filename . '.php') ? file_get_contents($path) : null;
    }

    /**
     * Create some configuration file
     * into <slims-root>/config/
     *
     * @param string $filename
     * @param string $content
     * @return void
     */
    public static function create(string $filename, $content = '')
    {
        if (is_callable($content)) $content = $content($filename);
        file_put_contents(SB . 'config/' . basename($filename) . '.php', $content);
    }

    /**
     * Create or update SLiMS configuration
     * to database
     *
     * @param string $name
     * @param mixed $value
     * @return bool
     */
    public static function createOrUpdate(string $name, $value)
    {
        require_once SIMBIO.'simbio_DB/simbio_dbop.inc.php';
        $sql_op = new \simbio_dbop($dbs = DB::getInstance('mysqli'));
        $name = $dbs->escape_string($name);
        $data['setting_value'] = $dbs->escape_string(serialize($value));

        $query = $dbs->query("SELECT setting_value FROM setting WHERE setting_name = '{$name}'");
        if ($query->num_rows > 0) {
            // update
            $status = $sql_op->update('setting', $data, "setting_name='{$name}'");
        } else {
            // insert
            $data['setting_name'] = $name;
            $status = $sql_op->insert('setting', $data);
        }

        return $status;
    }
}
================================================================================
File: content.inc.php
================================================================================

<?php
/**
 * Content class
 * Class for showing content from database
 *
 * Copyright (C) 2007,2008  Arie Nugraha (dicarve@yahoo.com), Hendro Wicaksono (hendrowicaksono@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

class Content
{
    public $strip_html = false;
    public $allowed_tags = null;

    public static function createSummary($text, $max_chars = 300)
    {
        $summary = strip_tags($text);
        // $summary = substr($summary, 0, $max_chars);

        // making sure substr finishes on a word
        if (preg_match('/^.{1,'.$max_chars.'}\b/s', $summary, $match)) {
            $summary= $match[0];
        }
        
        return $summary;
    }
    
    public function getContents($obj_db, $max_each_page = 10, &$total = 0, $search_query = '')
    {
        global $sysconf;
        $contents = array();
        $page = 1;
        $offset = 0;
        if (isset($_GET['page'])) {
            $page = (integer)$_GET['page'];
        }
        if ($page > 1) {
            $offset = ($page*$max_each_page)-$max_each_page;
        }
        
        // language
        $_lang = strtolower($sysconf['default_lang']);

        // query content
        $_sql_content = "SELECT SQL_CALC_FOUND_ROWS * FROM content WHERE is_news=1 AND is_draft=0";
        if ($search_query) {
            $search_query = $obj_db->escape_string(trim($search_query));
            $_sql_content .= " AND MATCH(`content_title`, `content_desc`) AGAINST('$search_query' IN BOOLEAN MODE)";
        }
        $_sql_content .= " ORDER BY `last_update` DESC";
        $_sql_content .= " LIMIT $max_each_page OFFSET $offset";
        
        $_content_q = $obj_db->query($_sql_content);
        // echo $_sql_content;
        
        // get total rows
        $_total_rows = $obj_db->query('SELECT FOUND_ROWS()');
        $_total_rows_d = $_total_rows->fetch_row();
        $total = $_total_rows_d[0];
        
        // get content data
        while ($_content_d = $_content_q->fetch_assoc()) {
            $contents[] = $_content_d;
        }
        
        return $contents;
    }
    
    public function get($obj_db, $str_path = '')
    {
        global $sysconf;
        $_path = strtolower(trim($str_path));
        if (!$_path) {
            return;
        }

        if (preg_match('@^admin.+@i', $_path)) {
            $_unauthorized = !isset($_SESSION['uid']) AND !isset($_SESSION['uname']) AND !isset($_SESSION['realname']);
            if ($_unauthorized) {
                return;
            }
        }

        // language
        $_lang = strtolower($sysconf['default_lang']);
        $_path_lang = $_path.'_'.$_lang;

        // check for language
        $_sql_check = sprintf('SELECT COUNT(*) FROM content WHERE content_path=\'%s\' AND is_draft = 0', $obj_db->escape_string($_path_lang));
        $_check_q = $obj_db->query($_sql_check);
        $_check_d = $_check_q->fetch_row();
        if ($_check_d[0] > 0) {
          $_path = $_path_lang;
        }

        // query content
        $_sql_content = sprintf('SELECT * FROM content WHERE content_path=\'%s\' AND is_draft = 0', $obj_db->escape_string($_path));
        $_content_q = $obj_db->query($_sql_content);
        // get content data
        $_content_d = $_content_q->fetch_assoc();
        if (!isset($_content_d['content_title']) OR !isset($_content_d['content_path'])) {
            return false;
        } else {
            $_content['Title'] = $_content_d['content_title'];
            $_content['Path'] = $_content_d['content_path'];
            $_content['Content'] = '<div class="ck-content p-5">' . $_content_d['content_desc'] . '</div>';
            // strip html
            if ($this->strip_html) {
                $_content['Content'] = '<div class="ck-content p-5">' . strip_tags($_content['Content'], $this->allowed_tags) . '</div>';
            }

            return $_content;
        }
    }
}

================================================================================
File: content_custom.inc.php
================================================================================

<?php

/**
 * contentFromDb class
 * Class for getting content
 *
 * Copyright (C) 2010  Hendro Wicaksono (hendrowicaksono@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

class content_custom
{
    protected $content_path = NULL;
    protected $link;
    protected $db;
    protected $sql = '';
    protected $query;
    protected $url = NULL;
    protected $content_title = NULL;
    protected $content_desc = NULL;
    protected $page = '';
    protected $page_assigned = array('all');

    function do_content_custom($content_path)
    {
        $this->link = new mysqli_connect(DB_HOST, DB_USERNAME, DB_PASSWORD);
        $this->db = mysql_select_db(DB_NAME);
        $this->sql = "SELECT * FROM content WHERE content_path='$content_path'";
        $this->query = mysql_query($this->sql);
        while ($result = mysql_fetch_array($this->query)) {
            $this->content_title = $result['content_title'];
            $this->content_desc = $result['content_desc'];
            $this->content_path = $result['content_path'];
            $this->url = SWB.'index.php?p='.$this->content_path;
        }
    }

    public function get_between($start, $end)
    {
        $r = explode($start, $this->content_desc);
        if (isset($r[1])){
            $r = explode($end, $r[1]);
            return $r[0];
        }
        return '';
    }


    public function is_page($dest = 'frontpage')
    {
        if (!isset($_GET['p'])) {
            if ((!isset($_GET['keywords'])) AND (!isset($_GET['page'])) AND (!isset($_GET['title'])) AND (!isset($_GET['author'])) AND (!isset($_GET['subject'])) AND (!isset($_GET['location']))) {
                $page = 'frontpage';
            } else {
                $page = 'detail';
            }
        } else {
            $page = $_GET['p'];
        }
        if ($dest === $page) {
            return 1;
        } elseif ($dest === 'all') {
            return 1;
        } else {
            return 0;
        }
    }


    public function get_url()
    {

        return $this->url;
    }

    public function get_content_title()
    {
        return $this->content_title;
    }

    public function get_content_desc()
    {
        return $this->content_desc;
    }

}

================================================================================
File: content_list.inc.php
================================================================================

<?php
/**
 * content_list class
 * Class for generating a list of records
 *
 * Copyright (C) 2007,2008  Arie Nugraha (dicarve@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

class content_list
{
    protected $list_template;
    protected $paging_enable = false;
    protected $criteria;
    protected $order;
    public $num_rows = 0;


    /**
     * Method to set list template
     *
     * @param   string  $str_template
     * @return  void
     */
    public function setListTemplate($str_template)
    {
        $this->list_template = $str_template;
    }


    /**
     * Method to set SQL criteria of list
     *
     * @param   string  $str_criteria
     * @return  void
     */
    public function setSQLcriteria($str_criteria)
    {
        $this->criteria = $str_criteria;
    }


    /**
     * Method to set SQL field ordering of list
     *
     * @param   string  $str_order
     * @return  void
     */
    public function setSQLorder($str_order)
    {
        $this->order = $str_order;
    }


    /**
     * Method to enable or disable list paging
     *
     * @param   boolean $bool_enable
     * @return  void
     */
    public function pagingEnable($bool_enable)
    {
        $this->paging_enable = $bool_enable;
    }


    /**
     * Method to parse list template
     *
     * @param   array   $array_associative_data
     * @return  string
     */
    protected function parseListTemplate($array_associative_data)
    {
        if (!$this->list_template) {
            echo 'There is no template for content list yet';
            return;
        }

        // get the template markers from regular expression
        preg_match_all("/\{[a-z_]+?\}/", $this->list_template, $matches);
        $_markers = $matches[0];

        // result buffer var
        $_result = $this->list_template;
        foreach ($_markers as $_each_marker) {
            $_index = str_replace(array('{','}'), '', $_each_marker);
            if (isset($array_associative_data[$_index]) AND $array_associative_data[$_index]) {
                $_result = str_replace($_each_marker, $array_associative_data[$_index], $_result);
            } else {
                $_result = str_replace($_each_marker, '', $_result);
            }
        }

        return $_result;
    }
}

================================================================================
File: Currency.php
================================================================================

<?php
/**
 * @author Drajat Hasan
 * @email drajathasan20@gmail.com
 * @create date 2022-10-10 23:32:04
 * @modify date 2022-10-23 16:02:21
 * @license GPLv3
 * @desc [description]
 */

namespace SLiMS;

class Currency
{
    private $input;
    private ?object $formatter = null;

    public function __construct($input = 0)
    {
        $this->input = $input;
        if ($this->isSupport()) $this->formatter = new \NumberFormatter(config('custom_currency_locale.region', config('default_lang')), \NumberFormatter::CURRENCY);
    }

    /**
     * Check if Locale class is enable
     * or not. 
     *
     * @return noolean
     */
    public function isSupport()
    {
        return class_exists('Locale');
    }

    /**
     * Get currency data
     *
     * @return string
     */
    public function get()
    {
        if (!$this->isSupport()) return $this->input;
        
        // override default value
        $custom = config('custom_currency_locale');

        // enable or not
        if (isset($custom['enable']) && !(bool)$custom['enable']) return $this->input;

        if (!is_null($custom))
        {
            foreach ($custom['detail']??[] as $property => $data) {
                foreach ($data as $const => $value) {
                    call_user_func_array([$this->formatter, 'set' . ucfirst($property)], [constant('\NumberFormatter::'. $const), $value]);
                }
            }
        }

        return $this->formatter->formatCurrency($this->input??0, $this->formatter->getTextAttribute(\NumberFormatter::CURRENCY_CODE));
    }

    /**
     * Get number formatter instance
     *
     * @return NumberFormatter
     */
    public function getFormatter()
    {
        return $this->formatter;
    }

    /**
     * Get currency based on ISO 4217
     * 
     * @source https://stackoverflow.com/questions/4299099/get-currency-iso-4217-code-based-on-locale#answer-47331489
     * @return array
     */
    public function getIsoCode()
    {
        if (!$this->isSupport()) return [['0', 'Extension Intl must be enable first']];

        // return list
        $list = array_filter(array_reduce(\ResourceBundle::getLocales(''), function (array $currencies, string $locale) {
            $code = \NumberFormatter::create(
                $locale,
                \NumberFormatter::CURRENCY
            )->getTextAttribute(\NumberFormatter::CURRENCY_CODE);
            $currencies[$locale] = [$locale, locale_get_display_region($locale) . ' - ' . $locale . ' - ' . $code];
        
            return $currencies;
        },[]), fn($code) => (!preg_match('/XXX/i', $code[1])));

        sort($list);

        return $list;
    }

    /**
     * Convert object to string
     *
     * @return string
     */
    public function __toString()
    {
        return (string)$this->get();
    }
}
================================================================================
File: DB.php
================================================================================

<?php
/**
 * @Created by          : Waris Agung Widodo (ido.alit@gmail.com)
 * @Date                : 01/10/20 02.07
 * @File name           : DB.php
 */

namespace SLiMS;


use PDO;
use PDOException;
use PHPMailer\PHPMailer\Exception;
use Ifsnop\Mysqldump as IMysqldump;

class DB
{
    /**
     * PDO instance
     * @var null
     */
    private static $instance = null;

    /**
     * MySQLi Instance
     * @var null
     */
    private static $instance_mysqli = null;

    /**
     * Backup const
     */
    const BACKUP_BASED_ON_DAY = 1;
    const BACKUP_BASED_ON_LAST_ITEM = 2;

    /**
     * Intial database instance
     *
     * @param string $driver
     */
    private function __construct($driver = 'pdo')
    {
        try {

            if ($driver === 'mysqli') {
                self::$instance_mysqli = new \mysqli(...$this->getProfile($driver));
            } else {
                self::$instance = new PDO(...$this->getProfile($driver));
                self::$instance->setAttribute(PDO::ATTR_ERRMODE, ENVIRONMENT == 'development' ? PDO::ERRMODE_EXCEPTION : PDO::ERRMODE_SILENT);
                self::$instance->query('SET NAMES utf8');
                self::$instance->query('SET CHARACTER SET utf8');
            }

        } catch(PDOException $error) {
            echo $error->getMessage();
        } catch (Exception $error) {
            echo $error->getMessage();
        }
    }

    /**
     * An method to get database instance
     * based on database driver PDO | MySQLi
     *
     * @param string $driver
     * @return PDO|MySQLi
     */
    public static function getInstance($driver = 'pdo')
    {
        if ($driver === 'mysqli') {
            if (is_null(self::$instance_mysqli)) new DB('mysqli');
            return self::$instance_mysqli;
        } else {
            if (is_null(self::$instance)) new DB();
            return self::$instance;
        }
    }

    /**
     * Create MySQLDump instance 
     * with default profile provide by
     * this Object.
     *
     * @param array $settings
     * @return IMysqldump\Mysqldump
     */
    public static function backup()
    {
        $static = new static;
        return new IMysqldump\Mysqldump(...array_merge($static->getProfile('pdo'), [config('database_backup.options')]));
    }

    /**
     * Undocumented function
     *
     * @return boolean
     */
    public static function hasBackup($by = self::BACKUP_BASED_ON_DAY)
    {
        $criteria = "substring(backup_time, 1,10) = '" . date('Y-m-d') . "'";

        if ($by === self::BACKUP_BASED_ON_LAST_ITEM) $criteria = 'backup_time >= (SELECT last_update FROM item ORDER BY last_update DESC LIMIT 1)';

        $state = self::getInstance()->query(<<<SQL
            SELECT backup_log_id FROM backup_log WHERE {$criteria}
        SQL);

        return (bool)$state->rowCount();
    }

    /**
     * Retrive database profile 
     * from database.php and 
     * return database parameter as splat
     *
     * @param string $driver
     * @return array
     */
    private function getProfile($driver = 'pdo')
    {
        $config = $this->getConfig();
        $defaultProfile = $config['default_profile'];

        if ($config['proxy']) $defaultProfile = $this->setProxy();

        extract($config['nodes'][$defaultProfile]??[]);

        if (!isset($host)) throw new \Exception("Database " . $defaultProfile . " is not valid!");

        // Casting $port as integer
        $port = (int)$port;

        return $driver === 'pdo' ? 
                ['mysql:host=' . $host . ';port=' . $port . ';dbname=' . $database, $username, $password] 
                :
                [$host, $username, $password, $database, $port];
    }

    /**
     * Get database credential
     *
     * @param string $nodeName
     * @return array
     */
    private function getNode(string $nodeName)
    {
        return $this->getConfig()['nodes'][$nodeName]??[];
    }

    /**
     * @return array
     */
    private function getConfig()
    {
        return require SB . 'config/database.php';
    }

    /**
     * Load proxy validator
     * to manage database connection
     *
     * @return string
     */
    private function setProxy()
    {
        if (!file_exists($dbProxy = SB . 'config/database_proxy.php')) return [];
        include $dbProxy;
        return $defaultProfile;
    }
}
================================================================================
File: detail.inc.php
================================================================================

<?php
/**
 * detail class
 * Class for document/record detail
 *
 * Copyright (C) 2015  Arie Nugraha (dicarve@yahoo.com)
 * Some security patches by Hendro Wicaksono (hendrowicaksono@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

// require 'content_list.inc.php';

// class detail extends content_list
class detail
{
    private $db = false;
    private $biblio = false;
    private $record_detail = array();
    private $detail_id = 0;
    private $error = false;
    private $output_format = 'html';
    private $template = 'html';
    private $total_item_available = 0;
    protected $detail_prefix = '';
    protected $detail_suffix = '';
    public $record_title;
    public $metadata;
    public $image_src;
    public $notes;
    public $subjects;

    /**
     * Class Constructor
     *
     * @param   object  $obj_db
     * @param   integer $int_detail_id
     * @param   str     $str_output_format
     * @return  void
     */
    public function __construct($dbs, $int_detail_id, $str_output_format = 'html')
    {
        if (!in_array($str_output_format, array('html', 'xml', 'mods', 'dc', 'json', 'json-ld', 'marc'))) {
            $this->output_format = trim($str_output_format);
        } else { $this->output_format = $str_output_format; }
        $this->db = $dbs;
        $this->detail_id = $int_detail_id;
        $this->biblio = new Biblio($this->db, $int_detail_id);
        $this->record_detail = $this->biblio->detail();
        $this->error = $this->biblio->getError();
        if (isset($this->record_detail['title'])) {
          $this->record_title = $this->record_detail['title'];
          $this->notes = $this->record_detail['notes'];
          $this->subjects = $this->record_detail['subjects'];
        } else if (!$this->error) {
          $this->error = 'Data not found!';
        }
    }


    public function setTemplate($str_template_path)
    {
      $this->template = $str_template_path;
    }


    /**
     * Method to print out the document detail based on template
     *
     * @return  void
     */
    public function showDetail()
    {
        global $sysconf;
        if ($this->error) {
            return '<div class="error alert alert-error">Error Fetching data for record detail. Server return error message: '.$this->error.'</div>';
        } else {
            if ($this->output_format == 'html') {
                ob_start();
                $detail = $this->htmlOutput();
                extract($detail, EXTR_OVERWRITE);
                include $this->template;
                $detail_html = ob_get_clean();
                return $detail_html;
            } else if ($this->output_format == 'mods') {
                return $this->MODSoutput();
            } else if ($this->output_format == 'json-ld') {
                return $this->JSONLDoutput();
            } else {
                // external output function
                if (function_exists($this->output_format)) {
                    $_ext_func = $this->output_format;
                    return $_ext_func();
                }
                return null;
            }
        }
    }


    /**
     * Method to get file attachments information of biblio
     *
     * @param   boolean     $bool_return_raw
     *
     * @return  mix
     */
    public function getAttachments() {
        $_output = '';
        $_output .= '<ul class="attachList list-unstyled">';
        if (!$this->record_detail['attachments']) {
          return false;
        }
        foreach ($this->record_detail['attachments'] as $attachment_d) {
          // Restricted attachment check
          if (!is_null($attachment_d['access_limit'])) {
              // need member login access
              if (!utility::isMemberLogin()) {
                $_output .= '<li class="attachment-locked" style="list-style-image: url(images/labels/locked.png)"><a class="font-italic" href="index.php?p=member&destination=' . (\SLiMS\Url::getSlimsFullUri('#attachment')->encode()) . '">'.__('Please login to see this attachment').'</a></li>';
                continue;
              // member type access check 
              } else if (utility::isMemberLogin() && !in_array($_SESSION['m_member_type_id'], unserialize($attachment_d['access_limit']))) {
                $_output .= '<li class="attachment-locked cursor-pointer" style="list-style-image: url(images/labels/locked.png)">'. __('You have no authorization to download this file.') . '</li>';
                continue;
              }
          }

          if ($attachment_d['mime_type'] == 'application/pdf') {
            $_output .= '<li class="attachment-pdf" style="list-style-image: url(images/labels/ebooks.png)" itemscope itemtype="http://schema.org/MediaObject"><a itemprop="name" property="name" '.(utility::isMobileBrowser() ? 'target="_blank"' : 'class="openPopUp"').' title="'.$attachment_d['file_title'].'" href="./index.php?p=fstream&fid='.$attachment_d['file_id'].'&bid='.$attachment_d['biblio_id'].'" width="780" height="520">'.$attachment_d['file_title'].'</a>';
            $_output .= '<div class="attachment-desc" itemprop="description" property="description">'.$attachment_d['file_desc'].'</div>';
            if (trim($attachment_d['file_url']) != '') { $_output .= '<div><a href="'.trim($attachment_d['file_url']).'" itemprop="url" property="url" title="Other Resource related to this book" target="_blank">Other Resource Link</a></div>'; }
            $_output .= '</li>';
          } else if (preg_match('@(video)/.+@i', $attachment_d['mime_type'])) {
              switch ($attachment_d['placement']) {
                  case 'embed':
                      $_output .= '<li style="list-style: none">'.$this->embed('./index.php?p=multimediastream&fid='.$attachment_d['file_id'].'&bid='.$attachment_d['biblio_id']).'</li>';
                      break;
                  case 'popup':
                      $_output .= '<li class="attachment-audio-video" itemprop="video" property="video" itemscope itemtype="http://schema.org/VideoObject" style="list-style-image: url(images/labels/auvi.png)">'
                          .'<a itemprop="name" property="name" class="openPopUp" title="'.$attachment_d['file_title'].'" href="./index.php?p=multimediastream&fid='.$attachment_d['file_id'].'&bid='.$attachment_d['biblio_id'].'" width="640" height="480">'.$attachment_d['file_title'].'</a>';
                      $_output .= '<div class="attachment-desc" itemprop="description" property="description">'.$attachment_d['file_desc'].'</div>';
                      break;
                  default:
                      $_output .= '<li class="attachment-audio-video" itemprop="video" property="video" itemscope itemtype="http://schema.org/VideoObject" style="list-style-image: url(images/labels/auvi.png)">'
                          .'<a itemprop="name" property="name" title="'.$attachment_d['file_title'].'" href="./index.php?p=multimediastream&fid='.$attachment_d['file_id'].'&bid='.$attachment_d['biblio_id'].'" target="_blank">'.$attachment_d['file_title'].'</a>';
                      $_output .= '<div class="attachment-desc" itemprop="description" property="description">'.$attachment_d['file_desc'].'</div>';
              }
            if (trim($attachment_d['file_url']) != '') { $_output .= '<div><a href="'.trim($attachment_d['file_url']).'" itemprop="url" property="url" title="Other Resource Link" target="_blank">Other Resource Link</a></div>'; }
            $_output .= '</li>';
          } else if (preg_match('@(audio)/.+@i', $attachment_d['mime_type'])) {
            $_output .= '<li class="attachment-audio-audio" itemprop="audio" property="audio" itemscope itemtype="http://schema.org/AudioObject" style="list-style-image: url(images/labels/auvi.png)">'
              .'<a itemprop="name" property="name" class="openPopUp" title="'.$attachment_d['file_title'].'" href="./index.php?p=multimediastream&fid='.$attachment_d['file_id'].'&bid='.$attachment_d['biblio_id'].'" width="640" height="480">'.$attachment_d['file_title'].'</a>';
            $_output .= '<div class="attachment-desc" itemprop="description" property="description">'.$attachment_d['file_desc'].'</div>';
            if (trim($attachment_d['file_url']) != '') { $_output .= '<div><a href="'.trim($attachment_d['file_url']).'" itemprop="url" property="url" title="Other Resource Link" target="_blank">Other Resource Link</a></div>'; }
            $_output .= '</li>';
          } else if ($attachment_d['mime_type'] == 'text/uri-list') {
              switch ($attachment_d['placement']) {
                  case 'embed':
                      $_output .= '<li style="list-style: none">'.$this->embed($attachment_d['file_url']).'</li>';
                      break;
                  case 'popup':
                      $_output .= '<li class="attachment-url-list" style="list-style-image: url(images/labels/url.png)" itemscope itemtype="http://schema.org/MediaObject"><a itemprop="name" property="name"  href="'.trim($attachment_d['file_url']).'" title="Click to open link" class="openPopUp" width="560" height="315">'.$attachment_d['file_title'].'</a><div class="attachment-desc">'.$attachment_d['file_desc'].'</div></li>';
                      break;
                  default:
                      $_output .= '<li class="attachment-url-list" style="list-style-image: url(images/labels/url.png)" itemscope itemtype="http://schema.org/MediaObject"><a itemprop="name" property="name"  href="'.trim($attachment_d['file_url']).'" title="Click to open link" target="_blank">'.$attachment_d['file_title'].'</a><div class="attachment-desc">'.$attachment_d['file_desc'].'</div></li>';
              }
          } else if (preg_match('@(image)/.+@i', $attachment_d['mime_type'])) {
            $file_loc = REPOBS.'/'.$attachment_d['file_dir'].'/'.$attachment_d['file_name'];
            $imgsize = GetImageSize($file_loc);
            $imgwidth = $imgsize[0] + 16;
            if ($imgwidth > 600) {
              $imgwidth = 600;
            }
            $imgheight = $imgsize[1] + 16;
            if ($imgheight > 400) {
              $imgheight = 400;
            }
            $_output .= '<li class="attachment-image" style="list-style-image: url(images/labels/ebooks.png)" itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><a itemprop="name" property="name" class="openPopUp" title="'.$attachment_d['file_title'].'" href="index.php?p=fstream&fid='.$attachment_d['file_id'].'&bid='.$attachment_d['biblio_id'].'" width="'.$imgwidth.'" height="'.$imgheight.'">'.$attachment_d['file_title'].'</a>';
            if (trim($attachment_d['file_url']) != '') { $_output .= ' [<a href="'.trim($attachment_d['file_url']).'" itemprop="url" property="url" title="Other Resource related to this file" target="_blank" style="font-size: 90%;">Other Resource Link</a>]'; }
            $_output .= '<div class="attachment-desc" itemprop="description" property="description">'.$attachment_d['file_desc'].'</div></li>';
          } else {
            $_output .= '<li class="attachment-image" style="list-style-image: url(images/labels/ebooks.png)" itemscope itemtype="http://schema.org/MediaObject"><a itemprop="name" property="name" title="Click To View File" href="index.php?p=fstream&fid='.$attachment_d['file_id'].'&bid='.$attachment_d['biblio_id'].'" target="_blank">'.$attachment_d['file_title'].'</a>';
            if (trim($attachment_d['file_url']) != '') { $_output .= ' [<a href="'.trim($attachment_d['file_url']).'" itemprop="url" property="url" title="Other Resource related to this file" target="_blank" style="font-size: 90%;">Other Resource Link</a>]'; }
            $_output .= '<div class="attachment-desc" itemprop="description" property="description">'.$attachment_d['file_desc'].'</div></li>';
          }
        }
        $_output .= '</ul>';
        return $_output;
    }


    function embed($url) {
        return <<<HTML
<div class="embed-responsive embed-responsive-16by9">
  <iframe class="embed-responsive-item" width="560" height="315" src="{$url}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
HTML;

    }


    /**
     * Method to get items/copies information of biblio
     *
     *
     * @return  string
     */
    public function getItemCopy() {
      global $sysconf;
      $_output = '';
      $copies = $this->record_detail['copies'];
      if (!$copies) {
        return false;
      }
      $_output = '<div class="flex flex-col">';
      foreach ($copies as $copy_d) {
        // check if this collection is on loan
        $loan_stat_q = $this->db->query('SELECT due_date FROM loan AS l
            LEFT JOIN item AS i ON l.item_code=i.item_code
            WHERE l.item_code=\''.$copy_d['item_code'].'\' AND is_lent=1 AND is_return=0');

        if ($loan_stat_q->num_rows > 0) {
            $loan_stat_d = $loan_stat_q->fetch_row();
            list($avail_class, $avail_status) = ['item-onloan', __('Currently On Loan (Due on ').date($sysconf['date_format'], strtotime($loan_stat_d[0])).')'];
        } else if ($copy_d['no_loan']) {
            list($avail_class, $avail_status) = ['item-notforloan', __('Available but not for loan').' - '.$copy_d['item_status_name']];
        } else {
            $this->total_item_available++;
            list($avail_class, $avail_status) = ['item-available', __('Available').(trim($copy_d['item_status_name']??'')?' - '.$copy_d['item_status_name']:'')];
        }

        extract($copy_d);
        $location_name = empty($location_name) ? __('Location name is not set') : $location_name;

        if (trim($copy_d['site']) != "") {
          $location_name .= ' ('.$copy_d['site'].')';
        }

        $call_number = empty($call_number) ? __('Location name is not set') : $call_number;
        $_output .= <<<HTML
            <div class="w-100 flex flex-row w-full">
                <div class="col-7 flex flex-row border border-gray-300 p-3">
                    <div>#</div>
                    <div class="mx-2">
                      <span class="block mx-auto">{$location_name}</span>
                      <small class="text-sm text-muted">{$call_number}</small>
                    </div>
                </div>
                <div class="col-2 border border-gray-300 p-3">
                    {$item_code}
                </div>
                <div class="col-3 border border-gray-300 p-3">
                  <b class="text-sm availability-item {$avail_class}">{$avail_status}</b>
                </div>
            </div>
        HTML;

        $loan_stat_q->free_result();
      }
      $_output .= '</div>';
      return $_output;
    }


    /**
     * Method to get other version of biblio
     *
     * @return  string
     */
    public function getRelatedBiblio() {
        $_output = '<table class="table table-bordered table-small itemList">';
        $_output .= '<tr>';
        $_output .= '<th>'.__('Title').'</th>';
        $_output .= '<th>'.__('Edition').'</th>';
        $_output .= '<th>'.__('Language').'</th>';
        $_output .= '</tr>';
        // get parent id
        $parent_q = $this->db->query(sprintf('SELECT b.biblio_id, title, edition, language_id
            FROM biblio_relation AS br INNER JOIN biblio AS b ON br.biblio_id=b.biblio_id
            WHERE rel_biblio_id=%d', $this->detail_id));
        $parent_d = $parent_q->fetch_assoc();
        if ($parent_d) {
            $_output .= '<tr>';
            $_output .= '<td class="biblio-title relation"><a href="'.SWB.'index.php?p=show_detail&id='.$parent_d['biblio_id'].'">'.$parent_d['title'].'</a></td>';
            $_output .= '<td class="biblio-edition relation">'.$parent_d['edition'].'</td>';
            $_output .= '<td class="biblio-language relation">'.$parent_d['language_id'].'</td>';
            $_output .= '</tr>';
        }
        // check related data
        $rel_q = $this->db->query(sprintf('SELECT b.biblio_id, title, edition, language_id FROM biblio_relation AS br
          INNER JOIN biblio AS b ON br.rel_biblio_id=b.biblio_id
          WHERE br.biblio_id IN (SELECT biblio_id FROM biblio_relation WHERE rel_biblio_id=%d) OR br.biblio_id=%d',
          $this->detail_id, $this->detail_id));

        if ($rel_q->num_rows < 1) {
            return null;
        }

        while ($rel_d = $rel_q->fetch_assoc()) {
            if ($rel_d['biblio_id'] == $this->detail_id) {
                continue;
            }
            $_output .= '<tr>';
            $_output .= '<td class="biblio-title relation"><a href="'.SWB.'index.php?p=show_detail&id='.$rel_d['biblio_id'].'">'.$rel_d['title'].'</a></td>';
            $_output .= '<td class="biblio-edition relation">'.$rel_d['edition'].'</td>';
            $_output .= '<td class="biblio-language relation">'.$rel_d['language_id'].'</td>';
            $_output .= '</tr>';
        }

        $_output .= '</table>';
        return $_output;
    }

    /**
     * Method to get biblio custom data
     *
     * @return  array
     */
    public function getBiblioCustom() {
      $_return = array();
      // include custom fields file
      if (file_exists(MDLBS.'bibliography/custom_fields.inc.php')) {
        include MDLBS.'bibliography/custom_fields.inc.php';
      }
      $columns = '';
      if (isset($biblio_custom_fields)) {
        foreach ($biblio_custom_fields as $custom_field) {
          if (isset($custom_field['is_public']) && $custom_field['is_public'] == '1')
            $columns .= $custom_field['dbfield'] . ', ';
        }
        if ($columns !== '') {
          $columns = substr($columns, 0, -2);
        }
      } else {
        $columns = '*';
      }

      $query = $this->db->query(sprintf("SELECT %s FROM biblio_custom WHERE biblio_id=%d", $columns, $this->detail_id));
      if ($query) {
        $data = $query->fetch_assoc();
        if (isset($biblio_custom_fields)) {
          foreach ($biblio_custom_fields as $custom_field) {
            if (isset($custom_field['is_public']) && $custom_field['is_public'] == '1' && isset($data[$custom_field['dbfield']])) {

              $data_field = unserialize($custom_field['data']??'');
              $data_record  = $data[$custom_field['dbfield']];

              switch ($custom_field['type']) {
                case 'dropdown':
                case 'choice':
                  $value = end($data_field[$data_record]);
                  break;
                case 'checklist':
                  $data_record = unserialize($data_record);
                  foreach ($data_record as $key => $val) {
                    if(isset($data_field[$val])){
                    $arr[] = end($data_field[$val]);
                    }
                  }
                  // convert array to string
                  $value = implode(' -- ',$arr);
                  break;
                default:
                  $value = $data[$custom_field['dbfield']];
                  break;
              }

              $_return[] = array(
                'label' => $custom_field['label'],
                'value' => $value
              );
            }
          }
        }
      }

      return $_return;
    }


    /**
     * Record detail output in HTML mode
     * @return  array
     *
     */
    protected function htmlOutput()
    {
        // get global configuration vars array
        global $sysconf;
        $_detail_link = SWB.'index.php?p=show_detail&id='.$this->detail_id;

        foreach ($this->record_detail as $idx => $data) {
          if ($idx == 'notes') {
            $data = nl2br($data??'');
          } else {
            if (is_string($data)) {
              $data = trim(strip_tags($data));
            }
          }
          $this->record_detail[$idx] = $data;
        }

        // get title and set it to public record_title property
        $this->record_title = $this->record_detail['title'];
        $this->metadata = '<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />';
        $this->metadata .= '<meta name="DC.title" content="'.$this->record_title.'" />';
        $this->metadata .= '<meta name="DC.identifier" content="'.$this->record_detail['isbn_issn'].'" />';
        $this->metadata .= '<meta name="DC.format" content="'.$this->record_detail['gmd_name'].'" />';
        $this->metadata .= '<meta name="DC.type" content="'.$this->record_detail['gmd_name'].'" />';
        $this->metadata .= '<meta name="DC.language" content="'.$this->record_detail['language_name'].'" />';
        $this->metadata .= '<meta name="DC.publisher" content="'.$this->record_detail['publisher_name'].'" />';
        $this->metadata .= '<meta name="DC.date" content="'.$this->record_detail['publish_year'].'" />';
        $this->metadata .= '<meta name="DC.coverage" content="'.$this->record_detail['publish_place'].'" />';
        $this->metadata .= '<meta name="DC.description" content="'.strip_tags($this->record_detail['notes']).'" />';
        $this->metadata .= '<meta name="Physical Description" content="'.$this->record_detail['collation'].'" />';
        $this->metadata .= '<meta name="Statement of Responsibility" content="'.$this->record_detail['sor'].'" />';
        $this->metadata .= '<meta name="Classification" content="'.$this->record_detail['classification'].'" />';
        $this->metadata .= '<meta name="Series Title" content="'.$this->record_detail['series_title'].'" />';
        $this->metadata .= '<meta name="Edition" content="'.$this->record_detail['edition'].'" />';
        $this->metadata .= '<meta name="Call Number" content="'.$this->record_detail['call_number'].'" />';

        // get the authors data
        $authors = '';
        $data = array();
        // authors for metadata
        $this->metadata .= '<meta name="DC.creator" content="';
        foreach ($this->record_detail['authors'] as $data) {
          $authors .= '<a href="?author='.urlencode('"'.$data['author_name'].'"').'&search=Search" title="'.__('Click to view others documents with this author').'">'.$data['author_name']."</a> - ".__($data['authority_type'])."<br />";
          $this->metadata .= $data['author_name'].'; ';
        }
        $this->metadata .= '" />';
        $this->record_detail['authors'] = $authors;

        // get the topics data
        $topics = '';
        $data = array();
        $this->metadata .= '<meta name="DC.subject" content="';
        foreach ($this->record_detail['subjects'] as $data) {
            $topics .= '<a href="?subject='.urlencode('"'.$data['topic'].'"').'&search=Search" title="'.__('Click to view others documents with this subject').'">'.$data['topic']."</a><br />";
            $this->metadata .= $data['topic'].'; ';
        }
        $this->metadata .= '" />';
        $this->record_detail['subjects'] = $topics;

        $this->record_detail['availability'] = $this->getItemCopy();
        $this->record_detail['file_att'] = $this->getAttachments();
        $this->record_detail['related'] = $this->getRelatedBiblio();
        $this->record_detail['biblio_custom'] = $this->getBiblioCustom();

        // check image
        if (!empty($this->record_detail['image'])) {
          if ($sysconf['tg']['type'] == 'minigalnano') {
            $isItemAvailable = $this->total_item_available > 0;
            $this->record_detail['image_src'] = 'lib/minigalnano/createthumb.php?filename=images/docs/'.urlencode($this->record_detail['image']).'&amp;width=200';
            $this->record_detail['image'] = '<img class="' . ($isItemAvailable ? 'available' : 'not-available') . '" title="' . ($isItemAvailable ? $this->record_title : __('Items is not available')) . '" loading="lazy" itemprop="image" alt="'.sprintf('Image of %s', $this->record_title).'" src="./'.$this->record_detail['image_src'].'" border="0" alt="'.$this->record_detail['title'].'" />';
          }
        } else {
          $this->record_detail['image_src'] = "images/default/image.png";
          $this->record_detail['image'] = '<img src="./'.$this->record_detail['image_src'].'" alt="No image available for this title" border="0" alt="'.$this->record_detail['title'].'" />';
        }

        // get image source
        $this->image_src = $this->record_detail['image_src'];

        if ($sysconf['social_shares']) {
        // share buttons
        $_detail_link_encoded = urlencode('http://'.$_SERVER['SERVER_NAME'].$_detail_link);
        $_share_btns = "\n".'<ul class="share-buttons">'.
            '<li>'.__('Share to').': </li>'.
            '<li><a href="http://www.facebook.com/sharer.php?u='.$_detail_link_encoded.'" title="Facebook" target="_blank"><img src="./images/default/fb.gif" alt="Facebook" /></a></li>'.
            '<li><a href="http://twitter.com/share?url='.$_detail_link_encoded.'&text='.urlencode($this->record_title).'" title="Twitter" target="_blank"><img src="./images/default/tw.gif" alt="Twitter" /></a></li>'.
            '<li><a href="https://plus.google.com/share?url='.$_detail_link_encoded.'" title="Google Plus" target="_blank"><img src="./images/default/gplus.gif" alt="Google" /></a></li>'.
            '<li><a href="http://www.digg.com/submit?url='.$_detail_link_encoded.'" title="Digg It" target="_blank"><img src="./images/default/digg.gif" alt="Digg" /></a></li>'.
            '<li><a href="http://reddit.com/submit?url='.$_detail_link_encoded.'&title='.urlencode($this->record_title).'" title="Reddit" target="_blank"><img src="./images/default/rdit.gif" alt="Reddit" /></a></li>'.
            '<li><a href="http://www.linkedin.com/shareArticle?mini=true&url='.$_detail_link_encoded.'" title="LinkedIn" target="_blank"><img src="./images/default/lin.gif" alt="LinkedIn" /></a></li>'.
            '<li><a href="http://www.stumbleupon.com/submit?url='.$_detail_link_encoded.'&title='.urlencode($this->record_title).'" title="Stumbleupon" target="_blank"><img src="./images/default/su.gif" alt="StumbleUpon" /></a></li>'.
            '</ul>'."\n";

          $this->record_detail['social_shares'] = $_share_btns;
        }
        return $this->record_detail;
    }


    /**
     * Record detail output in MODS (Metadata Object Description Schema) XML mode
     * @return  array
     *
     */
    public function MODSoutput()
    {
        // get global configuration vars array
        global $sysconf;
        $mods_version = '3.3';
        $xml = new XMLWriter();
        $xml->openMemory();
        $xml->setIndent(true);

        // set prefix and suffix
        $this->detail_prefix = '<modsCollection xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.loc.gov/mods/v3" xmlns:slims="http://slims.web.id" xsi:schemaLocation="http://www.loc.gov/mods/v3 http://www.loc.gov/standards/mods/v3/mods-3-3.xsd">'."\n";
        $this->detail_suffix = '</modsCollection>';

        // $_xml_output = '<mods version="3.3" ID="'.$this->detail_id.'">'."\n";
        // MODS main tag
        $xml->startElement('mods');
        $xml->writeAttribute('version', $mods_version);
        $xml->writeAttribute('id', $this->detail_id);

        // parse title
        $_title_sub = '';
        $_title_statement_resp = '';
        if (stripos($this->record_detail['title'], ':') !== false) {
            $_title_main = trim(substr_replace($this->record_detail['title'], '', stripos($this->record_detail['title'], ':')+1));
            $_title_sub = trim(substr_replace($this->record_detail['title'], '', 0, stripos($this->record_detail['title'], ':')+1));
        } else if (stripos($this->record_detail['title'], '/') !== false) {
            $_title_statement_resp = trim(substr_replace($this->record_detail['title'], '', stripos($this->record_detail['title'], '/')+1));
        } else {
            $_title_main = trim($this->record_detail['title']);
        }

        // $_xml_output .= '<titleInfo>'."\n".'<title><![CDATA['.$_title_main.']]></title>'."\n";
        $xml->startElement('titleInfo');
        $xml->startElement('title');
        $this->xmlWrite($xml, $_title_main);
        $xml->endElement();
        if ($_title_sub) {
            // $_xml_output .= '<subTitle><![CDATA['.$_title_sub.']]></subTitle>'."\n";
            $xml->startElement('subTitle');
            $this->xmlWrite($xml, $_title_sub);
            $xml->endElement();
        }
        // $_xml_output .= '</titleInfo>'."\n";
        $xml->endElement();

        // personal name
        // get the authors data
        foreach ($this->record_detail['authors'] as $_auth_d) {
            /*
            $_xml_output .= '<name type="'.$_auth_d['authority_type'].'" authority="'.$_auth_d['auth_list'].'">'."\n"
              .'<namePart><![CDATA['.$_auth_d['author_name'].']]></namePart>'."\n"
              .'<role><roleTerm type="text"><![CDATA['.$sysconf['authority_level'][$_auth_d['level']].']]></roleTerm></role>'."\n"
              .'</name>'."\n";
              */

            // $xml->startElement('name'); $xml->writeAttribute('type', $sysconf['authority_type'][$_auth_d['authority_type']]); $xml->writeAttribute('authority', $_auth_d['auth_list']);
            $xml->startElement('name'); $xml->writeAttribute('type', $_auth_d['authority_type']); $xml->writeAttribute('authority', $_auth_d['auth_list']??'');
            $xml->startElement('namePart'); $this->xmlWrite($xml, $_auth_d['author_name']); $xml->endElement();
            $xml->startElement('role');
                $xml->startElement('roleTerm'); $xml->writeAttribute('type', 'text');
                $this->xmlWrite($xml, $sysconf['authority_level'][$_auth_d['level']]);
                $xml->endElement();
            $xml->endElement();
            $xml->endElement();
        }

        // resources type
        // $_xml_output .= '<typeOfResource manuscript="yes" collection="yes"><![CDATA[mixed material]]></typeOfResource>'."\n";
        $xml->startElement('typeOfResource'); $xml->writeAttribute('manuscript', 'no'); $xml->writeAttribute('collection', 'yes'); $this->xmlWrite($xml, 'mixed material'); $xml->endElement();

        // $_xml_output .= '<genre authority="marcgt"><![CDATA[bibliography]]></genre>'."\n";
        $xml->startElement('genre'); $xml->writeAttribute('authority', 'marcgt'); $this->xmlWrite($xml, 'bibliography'); $xml->endElement();

        // imprint/publication data
        /*
        $_xml_output .= '<originInfo>'."\n";
        $_xml_output .= '<place><placeTerm type="text"><![CDATA['.$this->record_detail['publish_place'].']]></placeTerm></place>'."\n"
          .'<publisher><![CDATA['.$this->record_detail['publisher_name'].']]></publisher>'."\n"
          .'<dateIssued><![CDATA['.$this->record_detail['publish_year'].']]></dateIssued>'."\n";
        if ((integer)$this->record_detail['frequency_id'] > 0) {
            $_xml_output .= '<issuance>continuing</issuance>'."\n";
            $_xml_output .= '<frequency><![CDATA['.$this->record_detail['frequency'].']]></frequency>'."\n";
        } else {
            $_xml_output .= '<issuance><![CDATA[monographic]]></issuance>'."\n";
        }
        $_xml_output .= '<edition><![CDATA['.$this->record_detail['edition'].']]></edition>'."\n";
        $_xml_output .= '</originInfo>'."\n";
        */
        $xml->startElement('originInfo');
            $xml->startElement('place');
              $xml->startElement('placeTerm'); $xml->writeAttribute('type', 'text'); $this->xmlWrite($xml, $this->record_detail['publish_place']);$xml->endElement();
            $xml->endElement();
            $xml->startElement('publisher'); $this->xmlWrite($xml, $this->record_detail['publisher_name']); $xml->endElement();
            $xml->startElement('dateIssued'); $this->xmlWrite($xml, $this->record_detail['publish_year']); $xml->endElement();
        $xml->endElement();

        // language
        /*
        $_xml_output .= '<language>'."\n";
        $_xml_output .= '<languageTerm type="code"><![CDATA['.$this->record_detail['language_id'].']]></languageTerm>'."\n";
        $_xml_output .= '<languageTerm type="text"><![CDATA['.$this->record_detail['language_name'].']]></languageTerm>'."\n";
        $_xml_output .= '</language>'."\n";
        */
        $xml->startElement('language');
        $xml->startElement('languageTerm'); $xml->writeAttribute('type', 'code'); $this->xmlWrite($xml, $this->record_detail['language_id']); $xml->endElement();
        $xml->startElement('languageTerm'); $xml->writeAttribute('type', 'text'); $this->xmlWrite($xml, $this->record_detail['language_name']); $xml->endElement();
        $xml->endElement();

        // Physical Description/Collation
        /*
        $_xml_output .= '<physicalDescription>'."\n";
        $_xml_output .= '<form authority="gmd"><![CDATA['.$this->record_detail['gmd_name'].']]></form>'."\n";
        $_xml_output .= '<extent><![CDATA['.$this->record_detail['collation'].']]></extent>'."\n";
        $_xml_output .= '</physicalDescription>'."\n";
        */
        $xml->startElement('physicalDescription');
        $xml->startElement('form'); $xml->writeAttribute('authority', 'gmd'); $this->xmlWrite($xml, $this->record_detail['gmd_name']); $xml->endElement();
        $xml->startElement('extent'); $this->xmlWrite($xml, $this->record_detail['collation']); $xml->endElement();
        $xml->endElement();

        // Series title
        if ($this->record_detail['series_title']) {
            /*
            $_xml_output .= '<relatedItem type="series">'."\n";
            $_xml_output .= '<titleInfo>'."\n";
            $_xml_output .= '<title><![CDATA['.$this->record_detail['series_title'].']]></title>'."\n";
            $_xml_output .= '</titleInfo>'."\n";
            $_xml_output .= '</relatedItem>'."\n";
            */
            $xml->startElement('relatedItem'); $xml->writeAttribute('type', 'series');
            $xml->startElement('titleInfo'); $xml->endElement();
            $xml->startElement('title'); $this->xmlWrite($xml, $this->record_detail['series_title']); $xml->endElement();
            $xml->endElement();
        }

        // Note
        // $_xml_output .= '<note>'.$this->record_detail['notes'].'</note>'."\n";
        $xml->startElement('note'); $this->xmlWrite($xml, $this->record_detail['notes']); $xml->endElement();
        if (isset($this->record_detail['sor'])) {
            $xml->startElement('note'); $xml->writeAttribute('type', 'statement of responsibility'); $this->xmlWrite($xml, $this->record_detail['sor']); $xml->endElement();
            // $_xml_output .= '<note type="statement of responsibility"><![CDATA['.$_title_statement_resp.']]></note>';
        }

        // subject/topic
        foreach ($this->record_detail['subjects'] as $_topic_d) {
            $_subject_type = strtolower($sysconf['subject_type'][$_topic_d['topic_type']]);
            /*
            $_xml_output .= '<subject authority="'.$_topic_d['auth_list'].'">';
            $_xml_output .= '<'.$_subject_type.'><![CDATA['.$_topic_d['topic'].']]></'.$_subject_type.'>';
            $_xml_output .= '</subject>'."\n";
            */
            $xml->startElement('subject'); $xml->writeAttribute('authority', $_topic_d['auth_list']??'');
            $xml->startElement($_subject_type); $this->xmlWrite($xml, $_topic_d['topic']); $xml->endElement();
            $xml->endElement();
        }

        // classification
        // $_xml_output .= '<classification><![CDATA['.$this->record_detail['classification'].']]></classification>';
        $xml->startElement('classification'); $this->xmlWrite($xml, $this->record_detail['classification']); $xml->endElement();

        // ISBN/ISSN
        // $_xml_output .= '<identifier type="isbn"><![CDATA['.str_replace(array('-', ' '), '', $this->record_detail['isbn_issn']).']]></identifier>';
        $xml->startElement('identifier'); $xml->writeAttribute('type', 'isbn'); $this->xmlWrite($xml, str_replace(array('-', ' '), '', $this->record_detail['isbn_issn'])); $xml->endElement();

        // Location and Copies information
        $_copy_q = $this->db->query(sprintf('SELECT i.item_code, i.call_number, stat.item_status_name, loc.location_name, stat.rules, i.site FROM item AS i '
            .'LEFT JOIN mst_item_status AS stat ON i.item_status_id=stat.item_status_id '
            .'LEFT JOIN mst_location AS loc ON i.location_id=loc.location_id '
            .'WHERE i.biblio_id=%d', $this->detail_id));
        /*
        $_xml_output .= '<location>'."\n";
        $_xml_output .= '<physicalLocation><![CDATA['.$sysconf['library_name'].' '.$sysconf['library_subname'].']]></physicalLocation>'."\n";
        $_xml_output .= '<shelfLocator><![CDATA['.$this->record_detail['call_number'].']]></shelfLocator>'."\n";
        if ($_copy_q->num_rows > 0) {
            $_xml_output .= '<holdingSimple>'."\n";
            while ($_copy_d = $_copy_q->fetch_assoc()) {
                $_xml_output .= '<copyInformation>'."\n";
                $_xml_output .= '<numerationAndChronology type="1"><![CDATA['.$_copy_d['item_code'].']]></numerationAndChronology>'."\n";
                $_xml_output .= '<sublocation><![CDATA['.$_copy_d['location_name'].( $_copy_d['site']?' ('.$_copy_d['site'].')':'' ).']]></sublocation>'."\n";
                $_xml_output .= '<shelfLocator><![CDATA['.$_copy_d['call_number'].']]></shelfLocator>'."\n";
                $_xml_output .= '</copyInformation>'."\n";
            }
            $_xml_output .= '</holdingSimple>'."\n";
        }
        $_xml_output .= '</location>'."\n";
        */
        $xml->startElement('location');
        $xml->startElement('physicalLocation'); $this->xmlWrite($xml, $sysconf['library_name'].' '.$sysconf['library_subname']); $xml->endElement();
        $xml->startElement('shelfLocator'); $this->xmlWrite($xml, $this->record_detail['call_number']); $xml->endElement();
        if ($_copy_q->num_rows > 0) {
            $xml->startElement('holdingSimple');
            while ($_copy_d = $_copy_q->fetch_assoc()) {
                $xml->startElement('copyInformation');
                    $xml->startElement('numerationAndChronology'); $xml->writeAttribute('type', '1'); $this->xmlWrite($xml, $_copy_d['item_code']); $xml->endElement();
                    $xml->startElement('sublocation'); $this->xmlWrite($xml, $_copy_d['location_name'].( $_copy_d['site']?' ('.$_copy_d['site'].')':'' )); $xml->endElement();
                    $xml->startElement('shelfLocator'); $this->xmlWrite($xml, $_copy_d['call_number']); $xml->endElement();
                $xml->endElement();
            }
            $xml->endElement();
        }
        $xml->endElement();

        // digital files
        $attachment_q = $this->db->query('SELECT att.*, f.* FROM biblio_attachment AS att
            LEFT JOIN files AS f ON att.file_id=f.file_id WHERE att.biblio_id='.$this->detail_id.' AND att.access_type=\'public\' LIMIT 20');
        if ($attachment_q->num_rows > 0) {
            /*
            $_xml_output .= '<slims:digitals>'."\n";
            while ($attachment_d = $attachment_q->fetch_assoc()) {
                // check member type privileges
                if ($attachment_d['access_limit']) { continue; }
                $_xml_output .= '<slims:digital_item id="'.$attachment_d['file_id'].'" url="'.trim($attachment_d['file_url']).'" '
                    .'path="'.$attachment_d['file_dir'].'/'.$attachment_d['file_name'].'" mimetype="'.$attachment_d['mime_type'].'">';
                $_xml_output .= '<![CDATA['.$attachment_d['file_title'].']]>';
                $_xml_output .= '</slims:digital_item>'."\n";
            }
            $_xml_output .= '</slims:digitals>';
            */
            $xml->startElementNS('slims','digitals', null);
            while ($attachment_d = $attachment_q->fetch_assoc()) {
                // check member type privileges
                if ($attachment_d['access_limit']) { continue; }
                $xml->startElementNS('slims','digital_item', null);
                $xml->writeAttribute('id', $attachment_d['file_id']);
                $xml->writeAttribute('url', trim($attachment_d['file_url']));
                $xml->writeAttribute('path', $attachment_d['file_dir'].'/'.$attachment_d['file_name']);
                $xml->writeAttribute('mimetype', $attachment_d['mime_type']);
                $this->xmlWrite($xml, $attachment_d['file_title']);
                $xml->endElement();
            }
            $xml->endElement();
        }

        // image
        if (!empty($this->record_detail['image'])) {
          $_image = urlencode($this->record_detail['image']);
          $xml->startElementNS('slims','image', null);
          $this->xmlWrite($xml, urlencode($_image));
          $xml->endElement();
        }

        // record info
        /*
        $_xml_output .= '<recordInfo>'."\n";
        $_xml_output .= '<recordIdentifier><![CDATA['.$this->detail_id.']]></recordIdentifier>'."\n";
        $_xml_output .= '<recordCreationDate encoding="w3cdtf"><![CDATA['.$this->record_detail['input_date'].']]></recordCreationDate>'."\n";
        $_xml_output .= '<recordChangeDate encoding="w3cdtf"><![CDATA['.$this->record_detail['last_update'].']]></recordChangeDate>'."\n";
        $_xml_output .= '<recordOrigin><![CDATA[machine generated]]></recordOrigin>'."\n";
        $_xml_output .= '</recordInfo>';
        */
        $xml->startElement('recordInfo');
        $xml->startElement('recordIdentifier'); $this->xmlWrite($xml, $this->detail_id); $xml->endElement();
        $xml->startElement('recordCreationDate'); $xml->writeAttribute('encoding', 'w3cdtf'); $this->xmlWrite($xml, $this->record_detail['input_date']); $xml->endElement();
        $xml->startElement('recordChangeDate'); $xml->writeAttribute('encoding', 'w3cdtf'); $this->xmlWrite($xml, $this->record_detail['last_update']); $xml->endElement();
        $xml->startElement('recordOrigin'); $this->xmlWrite($xml, 'machine generated'); $xml->endElement();
        $xml->endElement();

        // $_xml_output .= '</mods>';
        $xml->endElement();

        return $xml->flush();
    }


    /**
     * Record detail output in Dublin Core XML
     * @return  string
     *
     */
    public function DublinCoreOutput()
    {
        // get global configuration vars array
        global $sysconf;
        $protocol = isset($_SERVER["HTTPS"]) ? 'https' : 'http';
        $xml = new XMLWriter();
        $xml->openMemory();
        $xml->setIndent(true);

        // set prefix and suffix
        $this->detail_prefix = '';
        $this->detail_suffix = '';

        $_xml_output = '';

        $_title_main = utf8_encode($this->record_detail['title']);
        // title
        $xml->startElementNS('dc', 'title', null);
        $this->xmlWrite($xml, $_title_main);
        $xml->endElement();

        // get the authors data
        $_biblio_authors_q = $this->db->query('SELECT a.*,ba.level FROM mst_author AS a'
            .' LEFT JOIN biblio_author AS ba ON a.author_id=ba.author_id WHERE ba.biblio_id='.$this->detail_id);
        while ($_auth_d = $_biblio_authors_q->fetch_assoc()) {
          $xml->startElementNS('dc', 'creator', null);
          $this->xmlWrite($xml, $_auth_d['author_name']);
          $xml->endElement();
        }
        $_biblio_authors_q->free_result();

        // imprint/publication data
        $xml->startElementNS('dc', 'publisher', null);
        $this->xmlWrite($xml, $this->record_detail['publisher_name']);
        $xml->endElement();

        if ($this->record_detail['publish_year']) {
          $xml->startElementNS('dc', 'date', null);
          $this->xmlWrite($xml, $this->record_detail['publish_year']);
          $xml->endElement();
        } else {
          $xml->startElementNS('dc', 'date', null);
          $xml->fullEndElement();
        }

        // edition
        $xml->startElementNS('dc', 'hasVersion', null);
        $this->xmlWrite($xml, $this->record_detail['edition']);
        $xml->endElement();

        // language
        $xml->startElementNS('dc', 'language', null);
        $this->xmlWrite($xml, $this->record_detail['language_name']);
        $xml->endElement();

        // Physical Description/Collation
        $xml->startElementNS('dc', 'medium', null);
        $this->xmlWrite($xml, $this->record_detail['gmd_name']);
        $xml->endElement();

        $xml->startElementNS('dc', 'format', null);
        $this->xmlWrite($xml, $this->record_detail['gmd_name']);
        $xml->endElement();

        $xml->startElementNS('dc', 'extent', null);
        $this->xmlWrite($xml, $this->record_detail['collation']);
        $xml->endElement();

        if ((integer)$this->record_detail['frequency_id'] > 0) {
          $xml->startElementNS('dc', 'format', null);
          $this->xmlWrite($xml, 'serial');
          $xml->endElement();
        }

        // Series title
        if ($this->record_detail['series_title']) {
          $xml->startElementNS('dc', 'isPartOf', null);
          $this->xmlWrite($xml, $this->record_detail['series_title']);
          $xml->endElement();
        }

        // Note
        $xml->startElementNS('dc', 'description', null);
        $this->xmlWrite($xml, $this->record_detail['notes']);
        $xml->endElement();

        $xml->startElementNS('dc', 'abstract', null);
        $this->xmlWrite($xml, $this->record_detail['notes']);
        $xml->endElement();

        // subject/topic
        $_biblio_topics_q = $this->db->query('SELECT t.topic, t.topic_type, t.auth_list, bt.level FROM mst_topic AS t
          LEFT JOIN biblio_topic AS bt ON t.topic_id=bt.topic_id WHERE bt.biblio_id='.$this->detail_id.' ORDER BY t.auth_list');
        while ($_topic_d = $_biblio_topics_q->fetch_assoc()) {
          $xml->startElementNS('dc', 'subject', null);
          $this->xmlWrite($xml, $_topic_d['topic']);
          $xml->endElement();
        }
        $_biblio_topics_q->free_result();

        // classification
        $xml->startElementNS('dc', 'subject', null);
        $this->xmlWrite($xml, $this->record_detail['classification']);
        $xml->endElement();

        // Permalink
        $permalink = $protocol.'://'.$_SERVER['SERVER_NAME'].':'.$_SERVER['SERVER_PORT'].SWB.'index.php?p=show_detail&id='.$this->detail_id;
        $xml->startElementNS('dc', 'identifier', null);
        $this->xmlWrite($xml, $permalink);
        $xml->endElement();

        // ISBN/ISSN
        $xml->startElementNS('dc', 'identifier', null);
        $this->xmlWrite($xml, str_replace(array('-', ' '), '', $this->record_detail['isbn_issn']));
        $xml->endElement();

        // Call Number
        $xml->startElementNS('dc', 'identifier', null);
        $this->xmlWrite($xml, $this->record_detail['call_number']);
        $xml->endElement();

        $_copy_q = $this->db->query('SELECT i.item_code, i.call_number, stat.item_status_name, loc.location_name, stat.rules, i.site FROM item AS i '
            .'LEFT JOIN mst_item_status AS stat ON i.item_status_id=stat.item_status_id '
            .'LEFT JOIN mst_location AS loc ON i.location_id=loc.location_id '
            .'WHERE i.biblio_id='.$this->detail_id);
        if ($_copy_q->num_rows > 0) {
            while ($_copy_d = $_copy_q->fetch_assoc()) {
              $xml->startElementNS('dc', 'hasPart', null);
              $this->xmlWrite($xml, $_copy_d['item_code']);
              $xml->endElement();
            }
        }
        $_copy_q->free_result();

        // digital files
        $attachment_q = $this->db->query('SELECT att.*, f.* FROM biblio_attachment AS att
            LEFT JOIN files AS f ON att.file_id=f.file_id WHERE att.biblio_id='.$this->detail_id.' AND att.access_type=\'public\' LIMIT 20');
        if ($attachment_q->num_rows > 0) {
          while ($attachment_d = $attachment_q->fetch_assoc()) {
              $dir = '';
              if ($attachment_d['file_dir']) {
                $dir = $attachment_d['file_dir'].'/';
              }
              // check member type privileges
              if ($attachment_d['access_limit']) { continue; }
              $xml->startElementNS('dc', 'relation', null);
              $this->xmlWrite($xml, $protocol.'://'.$_SERVER['SERVER_NAME'].':'.$_SERVER['SERVER_PORT'].REPO_WBS.$dir.trim(urlencode($attachment_d['file_name'])));
              $xml->endElement();
          }
        }

        // image
        if (!empty($this->record_detail['image'])) {
          $_image = $protocol.'://'.$_SERVER['SERVER_NAME'].':'.$_SERVER['SERVER_PORT'].SWB.'images/docs/'.urlencode($this->record_detail['image']);
          $xml->startElementNS('dc', 'relation', null);
          $this->xmlWrite($xml, $_image);
          $xml->endElement();
        }

        return $xml->flush();
    }


    /**
     * Record detail output in JSON-LD (JSON-Linked Data)
     * @return  string
     *
     */
    public function JSONLDoutput() {
      // get global configuration vars array
      global $sysconf;

      // set prefix and suffix
      $this->detail_prefix = '';
      $this->detail_suffix = '';

      $jsonld['@context'] = 'http://schema.org';
      $jsonld['@type'] = 'Book';

      // parse title
      $_title_sub = '';
      $_title_statement_resp = '';
      if (stripos($this->record_detail['title'], ':') !== false) {
          $_title_main = trim(substr_replace($this->record_detail['title'], '', stripos($this->record_detail['title'], ':')+1));
          $_title_sub = trim(substr_replace($this->record_detail['title'], '', 0, stripos($this->record_detail['title'], ':')+1));
      } else if (stripos($this->record_detail['title'], '/') !== false) {
          $_title_statement_resp = trim(substr_replace($this->record_detail['title'], '', stripos($this->record_detail['title'], '/')+1));
      } else {
          $_title_main = trim($this->record_detail['title']);
      }

      $jsonld['name'] = $_title_main;
      if ($_title_sub) {
        $jsonld['alternativeHeadline'] = $_title_sub;
      }

      // get the authors data
      $jsonld['author']['@type'] = 'Person';
      $_biblio_authors_q = $this->db->query('SELECT a.*,ba.level FROM mst_author AS a'
          .' LEFT JOIN biblio_author AS ba ON a.author_id=ba.author_id WHERE ba.biblio_id='.$this->detail_id);
      while ($_auth_d = $_biblio_authors_q->fetch_assoc()) {
          $jsonld['author']['name'][] = $_auth_d['author_name'];
      }
      $_biblio_authors_q->free_result();

      // imprint/publication data
      $jsonld['publisher']['@type'] = 'Organization';
      $jsonld['publisher']['name'] = $this->record_detail['publisher_name'];

      // date
      $jsonld['dateCreated'] = $this->record_detail['publish_year'];

      // edition
      $jsonld['version'] = $this->record_detail['edition'];

      // language
      $jsonld['inLanguage'] = $this->record_detail['language_name'];

      // Physical Description/Collation
      $jsonld['bookFormat'] = $this->record_detail['gmd_name'];

      // collation
      $jsonld['numberOfPages'] = $this->record_detail['collation'];

      // Series title
      if ($this->record_detail['series_title']) {
        $jsonld['alternativeHeadline'] = $this->record_detail['series_title'];
      }

      // Note
      $jsonld['description'] = $this->record_detail['notes'];

      // subject/topic
      $jsonld['keywords'] = '';
      $_biblio_topics_q = $this->db->query('SELECT t.topic, t.topic_type, t.auth_list, bt.level FROM mst_topic AS t
        LEFT JOIN biblio_topic AS bt ON t.topic_id=bt.topic_id WHERE bt.biblio_id='.$this->detail_id.' ORDER BY t.auth_list');
      while ($_topic_d = $_biblio_topics_q->fetch_assoc()) {
        $jsonld['keywords'] .= $_topic_d['topic'].' ';
      }

      // classification
      $jsonld['keywords'] .= $this->record_detail['classification'];

      // Permalink
      $jsonld['url'] = 'http://'.$_SERVER['SERVER_NAME'].SWB.'index.php?p=show_detail&id='.$this->detail_id;

      // ISBN/ISSN
      $jsonld['isbn'] = str_replace(array('-', ' '), '', $this->record_detail['isbn_issn']);

      // digital files
      $jsonld['associatedMedia']['@type'] = 'MediaObject';
      $attachment_q = $this->db->query('SELECT att.*, f.* FROM biblio_attachment AS att
          LEFT JOIN files AS f ON att.file_id=f.file_id WHERE att.biblio_id='.$this->detail_id.' AND att.access_type=\'public\' LIMIT 20');
      if ($attachment_q->num_rows > 0) {
        while ($attachment_d = $attachment_q->fetch_assoc()) {
            $_xml_output .= '<dc:relation><![CDATA[';
            // check member type privileges
            if ($attachment_d['access_limit']) { continue; }
            $jsonld['associatedMedia']['name'] = trim($attachment_d['file_title']);
        }
      }

      // image
      if (!empty($this->record_detail['image'])) {
        $_image = urlencode($this->record_detail['image']);
	$jsonld['image'] = 'http://'.$_SERVER['SERVER_NAME'].IMGBS.'docs/'.urlencode($_image);
      }

      return json_encode($jsonld);
    }


    /**
     * Get Record detail prefix
     */
    public function getPrefix()
    {
        return $this->detail_prefix;
    }


    /**
     * Get Record detail suffix
     */
    public function getSuffix()
    {
        return $this->detail_suffix;
    }

    private function xmlWrite(&$xmlwriter, $data, $mode = 'Text') {
        if ($mode == 'CData') {
            $xmlwriter->writeCData($data);
        } else {
            $xmlwriter->text($data??'');
        }
    }
}

================================================================================
File: GroupMenu.php
================================================================================

<?php
/**
 * @Created by          : Waris Agung Widodo (ido.alit@gmail.com)
 * @Date                : 18/12/2021 11:51
 * @File name           : GroupMenu.php
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

namespace SLiMS;


class GroupMenu
{
    private static $instance;
    private $uniq_id;
    private $group = [];
    private $plugin_in_group = [];

    /**
     * @return GroupMenu
     */
    public static function getInstance(): GroupMenu
    {
        if (is_null(self::$instance)) self::$instance = new static;
        return self::$instance;
    }

    /**
     * @param $uniq_id
     * @return $this
     */
    function bind($uniq_id): GroupMenu
    {
        $this->uniq_id = $uniq_id;
        return $this;
    }

    function group($group_name)
    {
        if (!isset($this->group[strtolower($group_name)])) $this->group[strtolower($group_name)] = [];
        if (!is_null($this->uniq_id) && !in_array($this->uniq_id, $this->group[strtolower($group_name)])) {
            $this->group[strtolower($group_name)][] = $this->uniq_id;
            $this->plugin_in_group[] = $this->uniq_id;
            $this->uniq_id = null;
        }
        return GroupMenuOrder::getInstance()->bind($group_name);
    }

    /**
     * @return array
     */
    public function getGroup(): array
    {
        return $this->group;
    }

    public function getPluginInGroup(): array
    {
        return $this->plugin_in_group;
    }

    function getGroupName($uniq_id)
    {
        foreach ($this->group as $key => $group) {
            if (in_array($uniq_id, $group)) return $key;
        }
        return null;
    }
}
================================================================================
File: GroupMenuOrder.php
================================================================================

<?php
/*
 * File: GroupMenuOrder.php
 * Project: lib
 * Created Date: Saturday May 28th 2022 9:01:32 pm
 * Author: Waris Agung Widodo (ido.alit@gmail.com)
 * -----
 * Last Modified: Saturday May 28th 2022 9:37:40 pm
 * Modified By: Waris Agung Widodo
 * -----
 * License: GNU GPL v3
 * -----
 * HISTORY:
 * Date      	By	Comments
 * ----------	---	---------------------------------------------------------
 */

namespace SLiMS;

class GroupMenuOrder
{
    private static $instance;
    private array $order = [];
    private ?string $current_group;

    /**
     * Disable constructor
     * @return void 
     */
    private function __construct()
    {
    }

    /**
     * @return GroupMenuOrder
     */
    public static function getInstance(): GroupMenuOrder
    {
        if (is_null(self::$instance)) self::$instance = new static;
        return self::$instance;
    }

    public function bind($current_group)
    {
        $this->current_group = strtolower($current_group);
        return $this;
    }

    public function before($group_name)
    {
        $this->order('before', $group_name);
    }

    public function after($group_name)
    {
        $this->order('after', $group_name);
    }

    public function order($position, $group_name)
    {
        if (!is_null($this->current_group)) {
            $this->order[$this->current_group] = ['position' => $position, 'group' => strtolower($group_name)];
        }
        
        $this->current_group = null;
    }

    public function getOrder()
    {
        return $this->order;
    }
}

================================================================================
File: index.php
================================================================================

<?php header("location: ../"); ?>

================================================================================
File: index.html
================================================================================

<html><head><meta http-equiv="refresh" content="0;url=../"></head></html>

================================================================================
File: http_request.inc.php
================================================================================

<?php
/**
 * 2010 Arie Nugraha (dicarve@yahoo.com)
 *
 * This class is taken and modified from PHP script in:
 * http://www.fijiwebdesign.com/fiji-web-design-blog/acess-the-http-request-headers-and-body-via-php.html
 * by Fiji Web Design
 *
 * I don't know license of this class, but if someone know or disagree, please
 * send me an e-mail to me
 *
 * The send_http_request method is taken and modified from Jonas John's PHP script
 * found on : http://www.jonasjohn.de/snippets. Public Domain licensed
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

/**
* Access the HTTP Request
*/
class http_request {

    /** additional HTTP headers not prefixed with HTTP_ in $_SERVER superglobal */
    private $add_headers = array('CONTENT_TYPE', 'CONTENT_LENGTH');
    private $protocol = false;
    private $body = null;
    private $error = false;
    private $method = 'GET';
    private $request_method = false;
    private $headers = array();


    /**
    * Construtor
    * Retrieve HTTP Body
    * @param Array Additional Headers to retrieve
    */
    public function get_http_request($add_headers = false) {
        $this->retrieve_headers($add_headers);
        $this->body = @file_get_contents('php://input');
    }


    /**
    * Retrieve the HTTP request headers from the $_SERVER superglobal
    * @param Array Additional Headers to retrieve
    */
    private function retrieve_headers($add_headers = false) {
        if ($add_headers) {
            $this->add_headers = array_merge($this->add_headers, $add_headers);
        }

        if (isset($_SERVER['HTTP_METHOD'])) {
            $this->method = $_SERVER['HTTP_METHOD'];
            unset($_SERVER['HTTP_METHOD']);
        } else {
            $this->method = isset($_SERVER['REQUEST_METHOD']) ? $_SERVER['REQUEST_METHOD'] : false;
        }
        $this->protocol = isset($_SERVER['SERVER_PROTOCOL']) ? $_SERVER['SERVER_PROTOCOL'] : false;
        $this->request_method = isset($_SERVER['REQUEST_METHOD']) ? $_SERVER['REQUEST_METHOD'] : false;

        $this->headers = array();
        foreach($_SERVER as $i=>$val) {
            if (strpos($i, 'HTTP_') === 0 || in_array($i, $this->add_headers)) {
                $name = str_replace(array('HTTP_', '_'), array('', '-'), $i);
                $this->headers[$name] = $val;
            }
        }
    }


    /**
    * Retrieve HTTP Method
    */
    public function method() {
        return $this->method;
    }


    /**
    * Retrieve HTTP Body
    */
    public function body() {
        return $this->body;
    }


    /**
    * Retrieve HTTP request error
    * @return   array
    */
    public function error() {
        return $this->error;
    }


    /**
    * Retrieve all HTTP Headers
    * @param    string  $name: optionael header name to retrieve
    * @return   mixed
    */
    public function headers($name = '') {
        if ($name) {
            $name = strtoupper($name);
            return isset($this->headers[$name]) ? $this->headers[$name] : false;
        }
	    return $this->headers;
    }


    /**
     * Send HTTP request
     * @param   string  $url: URL where request is sent
     * @param   string  $referer: HTTP referer
     * @param   mixed   $data: string or an array of data to send
     * @param   string  $method: HTTP request method
     * @param   string  $content_type: content type of request
     */
    public function send_http_request($url, $referer, $data, $method = 'POST', $content_type = 'application/x-www-form-urlencoded') {
        if ($content_type == 'text/json') {
            if (is_string($data)) {
                // raw data
                $encoded_data = $data;
            } else {
                // convert array to JSON format
                $encoded_data = json_encode($data);
            }
        } else if ($content_type != 'text/json' && $content_type != 'application/x-www-form-urlencoded') {
            // raw data
            $encoded_data = $data;
        } else {
            if (is_string($data)) {
                // raw data
                $encoded_data = $data;
            } else {
                // convert variables array to URL encoded
                $encoded_data = http_build_query($data);
            }
        }

        // parse the given URL
        $url = parse_url($url);
        if (!in_array($url['scheme'], ['http', 'https'])) {
            return false;
        }

        // extract host, port and path:
        $host = $url['host'];
        $port = isset($url['port']) ? $url['port'] : '80'; // using port 80 for undefined port number
        $path = $url['path'];

        // open a socket connection
        $fp = fsockopen($host, $port, $errno, $errstr, 30);
        if (!$fp) {
            $this->error = array('errno' => $errno, 'message' => $errstr);
            return false;
        }

        // send the request headers:
        $method = strtoupper($method);
        fputs($fp, "$method $path HTTP/1.1\r\n");
        fputs($fp, "Host: $host" . (($port != '80') ? ":$port" : '') . "\r\n");
        fputs($fp, "Referer: $referer\r\n");
        fputs($fp, "Content-type: $content_type\r\n");
        fputs($fp, "Content-length: ". strlen($encoded_data) ."\r\n");
        fputs($fp, "Accept: */*\r\n");
        fputs($fp, "Connection: close\r\n\r\n");
        fputs($fp, $encoded_data);

        $result = '';
        while(!feof($fp)) {
            // receive the results of the request
            $result .= fgets($fp, 1024);
        }

        // close the socket connection:
        fclose($fp);

        // split the result header from the content
        $result = explode("\r\n\r\n", $result, 2);

        $this->headers = isset($result[0]) ? $result[0] : '';
        $this->body = $this->decode_chunked(isset($result[1]) ? $result[1] : '');
    }

    function decode_chunked($str) {
        for ($res = ''; !empty($str); $str = trim($str)) {
            $pos = strpos($str, "\r\n");
            $len = hexdec(substr($str, 0, $pos));
            $res.= substr($str, $pos + 2, $len);
            $str = substr($str, $pos + 2 + $len);
        }
        return $res;
    }
}

================================================================================
File: ip_based_access.inc.php
================================================================================

<?php
/**
 * SLiMS Library for limiting access to modules by IP address
 *
 * Copyright (C) 2011  Hendro Wicaksono (hendrowicaksono@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

if (!function_exists('do_checkIP')) {
    function do_checkIP ($module = 'general')
    {
        global $sysconf;
        if (isset($sysconf['ipaccess'][''.$module.''])) {
            $accmod = $sysconf['ipaccess'][''.$module.''];
        } else {
            die ('Invalid access module');
        }
        #$accmod = $sysconf['ipaccess'][''.$module.''];
        $is_allowed = false;
        $remote_addr = ip();
        if (($accmod != 'all') AND (is_array($accmod))) {
            foreach ($accmod as $value) {
                $pattern = "/^".$value."/i";
                if (preg_match($pattern, $remote_addr)) {
                    $is_allowed = true;
                }
            }
        } elseif ($accmod == 'all') {
            $is_allowed = true;
        } else {
            $is_allowed = false;
        }
        if (!$is_allowed) {
            echo 'Stop here! Access not allowed.';
            exit();
        }
    }
}

do_checkIP();

================================================================================
File: helper.inc.php
================================================================================

<?php
/**
 * @CreatedBy          : Waris Agung Widodo (ido.alit@gmail.com)
 * @Date               : 2020-11-28  20:07:48
 * @FileName           : helper.inc.php
 * @Project            : slims9_bulian
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

use SLiMS\Config;
use SLiMS\Ip;
use SLiMS\Number;
use SLiMS\Currency;
use SLiMS\Json;
use SLiMS\Jquery;
use SLiMS\Http\Redirect;
use SLiMS\Session\Flash;

if (!function_exists('config')) {
    /**
     * Helper to get config with dot separator keys
     *
     * @param $key
     * @param null $default
     * @return mixed|null
     */
    function config($key, $default = null) {
        return Config::getInstance()->get($key, $default);
    }
}

if (!function_exists('ip'))
{
    /**
     * Helper to get client Ip Address
     * and check if app is behind proxy or not
     */
    function ip()
    {
        return Ip::getInstance();
    }
}

if (!function_exists('number'))
{
    /**
     * function to call number instance
     *
     * @param mixed $input
     * @return Number
     */
    function number($input)
    {
        return Number::set($input);
    }
}

if (!function_exists('currency'))
{
    /**
     * function to call currency instance
     *
     * @param mixed $input
     * @return Number
     */
    function currency($input)
    {
        return new Currency($input);
    }
}

if (!function_exists('isDev')) 
{
    function isDev()
    {
        return ENVIRONMENT === 'development';
    }
}

if (!function_exists('isCli')) 
{
    function isCli()
    {
        return php_sapi_name() === 'cli';
    }
}

// set version on static files
if (!function_exists('v'))
{
  function v($filename)
  {
    global $sysconf;
    $version = substr(isDev() ? md5(date('this')) : md5(SENAYAN_VERSION_TAG . $sysconf['static_file_version']), 0,5);
    return  $filename . '?v=' . $version;
  }
}

if (!function_exists('flash'))
{
    /**
     * Set flash session message
     *
     * @param string $key
     * @param string $message
     * @return Flash|AnonymousClass
     */
    function flash(string $key = '', string $message = '')
    {
        if (!empty($message) && !empty($key))  return Flash::register($key, $message);

        return new Class {
            public function __call($method, $arguments)
            {
                if (method_exists(Flash::class, $method)) 
                {
                    return Flash::{$method}(...$arguments);
                }
                else
                {
                    return Flash::init()->$method(...$arguments);
                }
            }
        };
    }
}

if (!function_exists('jQuery'))
{
    function jQuery(string $selector = '')
    {
        if (!empty($selector)) return Jquery::getInstance($selector);
        echo Jquery::getInstance('');
    }
}

if (!function_exists('redirect'))
{
    /**
     * Redirect page with many options
     *
     * @param string $urlOrPath
     * @return void
     */
    function redirect(string $urlOrPath = '')
    {
        if (!empty($urlOrPath))  Redirect::getInstance()->to($urlOrPath);

        return new Class {
            /**
             * Redirect html content via Simbio AJAX
             *
             * @param string $url
             * @param string $data
             * @param string $position
             * @param string $selector
             * @return void
             */
            public function simbioAJAX(string $url, string $data = '', string $position = 'top.', string $selector = '#mainContent', int $timeout = 0)
            {
                $params = empty($data) ? "'$url'" : "'$url', {method: 'post', addData: '$data'}";
                exit(jQuery($selector)->setPosition($position)->simbioAJAX($params)->delayIn($timeout));
            }

            public function __call($method, $arguments)
            {
                if (method_exists(Flash::class, $method)) 
                {
                    return Redirect::{$method}(...$arguments);
                }
                else
                {
                    return Redirect::getInstance()->$method(...$arguments);
                }
            }
        };
    }
}


if (!function_exists('toastr'))
{
    /**
     * Helper to call toastrJS
     * alert template as function
     * 
     * usage: 
     * 
     * toastr('your message')->{template}('Toastr alert title leave empty for default title');
     * 
     * example:
     * 
     * toastr('Success insert data')->success();
     * 
     * Available template
     * - error, info, success, warning
     * 
     * if you use outside template, by default this function
     * will you use native browser alert.
     * 
     * @param string $message
     * @return void
     */
    function toastr(string $message)
    {
        // Anonymous class
        return new Class($message)
        {
            private $message = '';

            public function __construct($message)
            {
                $this->message = $message;
            }

            /**
             * use magic method to identifiy which
             * template user use.
             */
            public function __call($method, $parameters)
            {
                // Call toastrJS on utility class
                if (in_array($method, ['error','info','success','warning'])) utility::jsToastr($parameters[0]??__(ucfirst($method)), $this->message, $method);
                // native as default if template not available
                else utility::jsAlert($this->message);
            }
        };
    }
}
================================================================================
File: Ip.php
================================================================================

<?php
/**
 * @author drajathasan20@gmail.com
 * @email drajathasan20@gmail.com
 * @create date 2022-09-11 12:22:46
 * @modify date 2022-09-11 14:47:13
 * @license GPLv3
 * @desc [description]
 */

namespace SLiMS;

class Ip
{
    /**
     * Class instance
     */
    private static $instance = null;

    /**
     * Array key of $_SERVER 
     * to get client IP
     */
    private $sourceRemoteIp = 'REMOTE_ADDR';

    /**
     * Default array key of $_SERVER 
     * to collect client ip from proxy server
     */
    private $proxyKey = 'HTTP_X_FORWARDED_FOR';

    /**
     * Variable to store $_SERVER
     */
    private array $server;

    /* Constructor */
    private function __construct()
    {
        $this->server = $_SERVER;
    }

    public static function getInstance()
    {
        if (is_null(self::$instance)) self::$instance = new Ip;
        return self::$instance;
    }

    /**
     * Method to check the application is behind
     * proxy or not
     */
    public function isBehindProxy()
    {
        return array_key_exists($this->proxyKey, $this->server);
    }

    /**
     * Get proxy ip address
     */
    public function getProxyIp()
    {
        if ($this->isBehindProxy()) return $this->server['REMOTE_ADDR']??null;
    }

    /**
     * Get client IP
     */
    public function get()
    {
        return $this->server[$this->sourceRemoteIp]??$this->server['REMOTE_ADDR'];
    }

    /**
     * Setter for default $_SERVER key to get ip address of client
     */
    public function setSourceRemoteIp(string $serverKey)
    {
        $this->sourceRemoteIp = $serverKey;
    }

    /**
     * Set key to get real ip client at reverse proxy
     */
    public function setProxyKey(string $proxyKey)
    {
        $this->proxyKey = $proxyKey;
    }

    /**
     * short cut for access "get" method
     */
    public function __toString()
    {
        return $this->get();
    }
}
================================================================================
File: Jquery.php
================================================================================

<?php
/**
 * @author Drajat Hasan
 * @email drajathasan20@gmail.com
 * @create date 2023-06-06 05:39:26
 * @modify date 2023-06-06 15:59:35
 * @license GPLv3
 * @desc [description]
 */
namespace SLiMS;

use Closure;

class Jquery
{
    private static ?object $instance = null;
    private string $mainSelector = '';
    private string $result = '';
    private string $contents = '';
    public string $position = 'top.';

    private function __construct(){}

    public static function getInstance(string $mainSelector)
    {
        if (is_null(self::$instance)) self::$instance = new Jquery;
        self::$instance->mainSelector = $mainSelector;
        return self::$instance;
    }

    public static function raw(string $content)
    {
        $instance = self::getInstance('');
        $instance->contents = $instance->position . 'jQuery.' . $content;
        echo $instance;
        $instance->contents = '';
    }

    public function writeIfExists(string $contents):void
    {
        $position = $this->position;
        $message = isDev() ? "alert('jQuery not exists!')" : "console.log('jQuery not exists!')";
        $this->result = <<<HTML
        <script type="text/javascript">
            if (typeof {$position}\$ === 'function') {
                {$position}\$(document).ready(function(){
                    {$contents}
                })
            } else { {$message} }
        </script>
        HTML;
    }

    public function delayIn(int $timeout)
    {
        $contents = $this->contents;
        $this->contents = '';
        $this->setContent(<<<HTML
            setTimeout(() => {$contents}, {$timeout})
        HTML);
        return $this;
    }

    public function on(string $selector, string $eventListener, Closure|string $contents)
    {
        $position = $this->position;
        $mainSelector = $this->mainSelector;
        $this->setContent(<<<HTML
        {$position}\$('{$mainSelector}').on('{$eventListener}', '{$selector}', function(e){
            {$contents}
        })
        HTML);
    }

    public function getContents()
    {
        return $this->contents;
    }

    public function getResult()
    {
        return $this->result;
    }

    public function setPosition(string $position)
    {
        $this->position = $position;
        return $this;
    }

    private function setContent(string $content)
    {
        $this->contents .= $content . PHP_EOL;
    }
    
    
    public function __call($method, $parameters)
    {
        if (!method_exists($this, $method)) {
            $mainSelector = $this->mainSelector;
            $position = $this->position;
            
            if (count($parameters) === 1 && is_callable($parameters[0]))
            {
                $contents = <<<HTML
                function(e) {
                    {$parameters[0]()}
                }
                HTML;
            } else if (count($parameters) === 1 && substr($parameters[0], 0,1) === "'") {
                $contents = $parameters[0];
            } else { 
                $contents = "'" . implode(',', $parameters) . "'"; 
            }

            $this->setContent(<<<HTML
            {$position}\$('{$mainSelector}').{$method}({$contents})
            HTML);

            return $this;
        }
    }

    public function __toString():String
    {
        $this->writeIfExists($this->contents);
        return $this->getResult();
    }
}
================================================================================
File: Mail.php
================================================================================

<?php
/**
 * @author Drajat Hasan
 * @email drajathasan20@gmail.com
 * @create date 2022-10-06 22:44:30
 * @modify date 2023-06-04 06:20:36
 * @license GPLv3
 * @desc [description]
 */

namespace SLiMS;

use Exception;
use PHPMailer\PHPMailer\{SMTP,PHPMailer};
use SLiMS\Mail\Queue;
use SLiMS\Mail\TemplateContract;

class Mail extends PHPMailer
{
    use Queue;
    
    private static $instance = null;
    public static $mode = 'singleton';

    /**
     * Initialize default php mailer
     *
     * @return void
     */
    private function __construct()
    {
        parent::__construct(...func_get_args());
        $mail = config('mail');
        
        //Server settings
        $this->SMTPDebug = $mail['debug'];
        $this->isSMTP();
        $this->Host = $mail['server'];
        $this->SMTPAuth = $mail['enable'];
        $this->Username = $mail['auth_username'];
        $this->Password = $mail['auth_password'];

        // SMTP secure option
        if ($mail['SMTPSecure'] === 'tls') {
            $this->SMTPSecure = PHPMailer::ENCRYPTION_STARTTLS;
        } else if ($mail['SMTPSecure'] === 'ssl') {
            $this->SMTPSecure = PHPMailer::ENCRYPTION_SMTPS;
        }
        $this->Port = $mail['server_port'];
        
        //Recipients
        $this->setFrom($mail['from'], $mail['from_name']);
        $this->addReplyTo($mail['reply_to'], $mail['reply_to_name']);
        $this->charSet($mail['charset']??'UTF-8');
    }

    public static function getInstance()
    {
        if (!empty(self::$mode) && self::$mode != 'singleton') self::$instance = null;
        if (is_null(self::$instance)) self::$instance = new Mail(true);
        return self::$instance;
    }

    /**
     * Set destionation mail address
     *
     * @param string $mailAddress
     * @param string $mailName
     * @return Mail
     */
    public static function to(string $mailAddress, string $mailName = 'Member')
    {
        self::getInstance()->addAddress($mailAddress, $mailName);
        return self::getInstance();
    }

    /**
     * Mail subject
     *
     * @param string $mailObject
     * @return Mail
     */
    public function subject(string $mailObject)
    {
        $this->Subject = $mailObject;
        return $this;
    }

    /**
     * Set content charset
     *
     * @param string $charSet
     * @return void
     */
    public function charSet(string $charSet)
    {
        $this->CharSet = $charSet;
    }

    /**
     * Set plain message without html format
     *
     * @param string $mailPlainMessage
     * @return Mail
     */
    public function message(string $mailPlainMessage)
    {
        $this->isHTML(false);
        $this->Body = $mailPlainMessage;
        $this->AltBody = $mailPlainMessage;
        
        return $this;
    }

    /**
     * Send an email with formated template
     *
     * @param string $templateClass
     * @return Mail
     */
    public function loadTemplate(object $template)
    {
        if (!$template instanceof TemplateContract) throw new Exception("Class {$template} is not instance of SLiMS\Mail\TemplateContract!");

        $this->isHTML(true); // html yes!
        $this->msgHTML($template->render());
        if (is_object($template->render())) $this->AltBody = $template->render()->asAltBody();
        
        return $this;
    }

    /**
     * Attach some file
     *
     * @param string $filePath
     * @param array $options
     * @return Mail
     */
    public function attachment(string $filePath, array $options = [])
    {
        $this->addAttachment($filePath, ...$options);
        return $this;
    }

    /**
     * An option to override environment
     * setting
     *
     * @param string $envName
     * @return Mail
     */
    public function setEnv(string $envName)
    {
        // bypass if env not available!
        if (!array_key_exists($envName, self::availableEnv())) return $this;

        // override debug status
        $this->SMTPDebug = self::availableEnv()[$envName][0];
        return $this;
    }

    /**
     * PHPMailer environment list
     *
     * @return array
     */
    public static function availableEnv()
    {
        return [
            'Production' => [SMTP::DEBUG_OFF, __('Production')],
            'Development' => [SMTP::DEBUG_SERVER, __('Development')]
        ];
    }
}
================================================================================
File: marcxmlsenayan.inc.php
================================================================================

<?php
/**
 *
 * MARCXML to SENAYAN converter
 *
 * Copyright (C) 2009 Arie Nugraha (dicarve@yahoo.com), Hendro Wicaksono (hendrowicaksono@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

/**
 * simple MARC XML parser for SENAYAN 3
 * @param   string  $str_marcxml
 * @return  array
 **/
function marcXMLsenayan($str_marcxml, $str_xml_type = 'string')
{
    // MARC XML file path
    $_records = array();

    // load XML
    if ($str_xml_type == 'file') {
        // load from file
        if (file_exists($str_marcxml)) {
            $xml = simplexml_load_file($str_marcxml);
        } else {
            return 'File '.$str_marcxml.' not found! Please supply full path to MARC XML file';
        }
    } else {
        // load from string
        try {
            $xml = new SimpleXMLElement($str_marcxml);
        } catch (Exception $xmlerr) {
            die($xmlerr->getMessage());
        }
    }


    $record_num = 0;
    $corp_authors = array();
    $conf_authors = array();
    // start iterate records
    foreach ($xml->record as $record) {
        // default elements
        $isbn_issn = '';
        $classification = '';
        $language = '';
        $main_author = '';
        $title = '';
        $title_main = '';
        $title_sub = '';
        $title_statement_resp = '';
        $gmd = '';
        $edition = '';
        $publish_place = '';
        $publisher = '';
        $publish_year = '';
        $physical = '';
        $series = '';
        $notes = '';
        $topics = array();
        $authors = array();
        $copies = array();
        $call_number = '';
        $collection_type = '';
        $corp_authors[$record_num] = '';
        $conf_authors[$record_num] = '';
        // field
        foreach ($record->datafield as $field) {
            // subfield
            foreach ($field->subfield as $subfield) {
                // author
                if ((string)$field['tag'] == '020' OR (string)$field['tag'] == '022') {
                    if ((string)$subfield['code'] == 'a') {
                        $isbn_issn = $subfield;
                    }
                } else if ((string)$field['tag'] == '041') {
                    // language
                    if ((string)$subfield['code'] == 'a') {
                        $language = $subfield;
                    }
                } else if ((string)$field['tag'] == '082') {
                    if ((string)$subfield['code'] == 'a') {
                        // DDC classification
                        $classification = $subfield;
                    }
                } else if ((string)$field['tag'] == '100') {
                    if ((string)$subfield['code'] == 'a') {
                        $main_author = (string)$subfield;
                    }
                } else if ((string)$field['tag'] == '245') {
                    // title
                    if ((string)$subfield['code'] == 'a') {
                        $title_main = $subfield;
                    } else if ((string)$subfield['code'] == 'b') {
                        $title_sub = $subfield;
                    } else if ((string)$subfield['code'] == 'c') {
                        $title_statement_resp = $subfield;
                    } else if ((string)$subfield['code'] == 'h') {
                        $gmd = $subfield;
                    }
                } else if ((string)$field['tag'] == '250') {
                    // edition
                    if ((string)$subfield['code'] == 'a') {
                        $edition = $subfield;
                    } else if ((string)$subfield['code'] == 'b') {
                        $edition .= ' '.$subfield;
                    }
                } else if ((string)$field['tag'] == '260') {
                    // imprint
                    if ((string)$subfield['code'] == 'a') {
                        $publish_place = $subfield;
                    } else if ((string)$subfield['code'] == 'b') {
                        $publisher = $subfield;
                    } else if ((string)$subfield['code'] == 'c') {
                        $publish_year = $subfield;
                    }
                } else if ((string)$field['tag'] == '300') {
                    // physical
                    if ((string)$subfield['code'] == 'a') {
                        $physical = $subfield;
                    } else if ((string)$subfield['code'] == 'b') {
                        $physical .= ' - '.$subfield;
                    }
                } else if ((string)$field['tag'] == '440') {
                    // series
                    if ((string)$subfield['code'] == 'a') {
                        $series = $subfield;
                    } else if ((string)$subfield['code'] == 'v') {
                        $series .= ' '.$subfield;
                    }
                } else if (preg_match('@^5.+@i', (string)$field['tag'])) {
                    // notes
                    $notes .= $subfield.'; ';
                } else if ((string)$field['tag'] == '600') {
                    // authors subject headings
                    if ((string)$subfield['code'] == 'a') {
                        $authors[] = (string)$subfield;
                    }
                } else if ((string)$field['tag'] == '610') {
                    // authors corporate subject heading
                    if ((string)$subfield['code'] == 'a') {
                        $corp_author_buff .= (string)$subfield;
                    } else if ((string)$subfield['code'] == 'b') {
                        $corp_author_buff .= (string)$subfield;
                    }
                } else if ((string)$field['tag'] == '611') {
                    // authors conference/meeting subject heading
                    if ((string)$subfield['code'] == 'a') {
                        $conf_author_buff .= (string)$subfield;
                    } else if ((string)$subfield['code'] == 'c') {
                        $conf_author_buff .= '.'.(string)$subfield;
                    }
                } else if ((string)$field['tag'] == '650') {
                    // topics
                    if ((string)$subfield['code'] == 'a') {
                        $topics[] = (string)$subfield;
                    }
                } else if ((string)$field['tag'] == '700') {
                    // additional authors
                    if ((string)$subfield['code'] == 'a') {
                        $authors[] = (string)$subfield;
                    }
                } else if ((string)$field['tag'] == '710') {
                    // additional authors corporate
                    if ((string)$subfield['code'] == 'a') {
                        $corp_authors[$record_num] .= (string)$subfield;
                    } else if ((string)$subfield['code'] == 'b') {
                        $corp_authors[$record_num] .= (string)$subfield;
                    }
                } else if ((string)$field['tag'] == '711') {
                    // additional authors conference/meeting
                    if ((string)$subfield['code'] == 'a') {
                        $conf_authors[$record_num] .= (string)$subfield;
                    } else if ((string)$subfield['code'] == 'c') {
                        $conf_authors[$record_num] .= '.'.(string)$subfield;
                    }
                } else if ((string)$field['tag'] == '852') {
                    // copies
                    if ((string)$subfield['code'] == 'p') {
                        $copies[] = (string)$subfield;
                    } else if ((string)$subfield['code'] == 'h') {
                        $call_number = $subfield;
                    } else if ((string)$subfield['code'] == 'c') {
                        $collection_type = $subfield;
                    }
                }
            }
            // concat titles
            $title = (string)$title_main.( $title_sub?(string)$title_sub:'' ).( $title_statement_resp?(string)$title_statement_resp:'' );
        }

        // reset $data array
        $data = array();
        // clear array
        if (!$corp_authors[$record_num]) { unset($corp_authors[$record_num]); }
        if (!$conf_authors[$record_num]) { unset($conf_authors[$record_num]); }

        $data['title'] = (string)$title;
        $data['gmd'] = (string)$gmd;
        $data['gmd'] = str_replace(array('[', ']'), '', trim($data['gmd']));
        $data['edition'] = (string)$edition;
        $data['isbn_issn'] = (string)$isbn_issn;
        $data['publisher'] = (string)$publisher;
        $data['publish_year'] = (integer)$publish_year;
        $data['collation'] = (string)$physical;
        $data['series_title'] = (string)$series;
        $data['call_number'] = (string)$call_number;
        $data['language'] = (string)$language;
        $data['publish_place'] = (string)$publish_place;
        $data['classification'] = (string)$classification;
        $data['notes'] = (string)$notes;
        $data['author_main'] = $main_author;
        $data['authors_add'] = $authors;
        $data['authors_corp'] = $corp_authors;
        $data['authors_conf'] = $conf_authors;
        $data['subjects'] = $topics;
        $data['copies'] = $copies;

        $_records[] = $data;
        $record_num++;
    }
    return $_records;
}

================================================================================
File: Json.php
================================================================================

<?php
/**
 * @author Drajat Hasan
 * @email drajathasan20@gmail.com
 * @create date 2022-07-29 13:05:34
 * @modify date 2022-11-15 17:07:17
 * @license GPLv3
 * @desc : 
 * - Manage & manipulation JSON en|de-code process
 * - easy iterate with foreach at decoding/parsing process
 */

namespace SLiMS;

use ArrayIterator;
use Countable;
use IteratorAggregate;
use JsonSerializable;
use JsonException;

class Json implements IteratorAggregate,Countable
{
    /**
     * Instance
     *
     * @var Json|null
     */
    private static $instance = null;

    /**
     * Property for inputed json string
     *
     * @var string
     */
    private string $original;

    /**
     * Error
     *
     * @var string
     */
    private string $error = '';

    /**
     * An option for json output
     *
     * @var boolean
     */
    private bool $assoc = false;

    /**
     * Json number option
     *
     * @var integer
     */
    private int $option = 0;

    /**
     * Json depth
     *
     * @var integer
     */
    private int $depth = 512;

    /**
     * Magic method mapping for JSON option
     *
     * @var array
     */
    private array $scope = ['prettyPrint' => JSON_PRETTY_PRINT];

    /**
     * Attributes
     *
     * @var Object|Array
     */
    private $attributes;

    public static function getInstance()
    {
        if (is_null(self::$instance)) self::$instance = new Json;
        return self::$instance;
    }

    /**
     * Register json string
     * 
     * @param string $jsonString
     * @param boolean $error
     * @return Json | Array via ArrayIterator
     */
    public static function parse(string $jsonString, bool $error = false): Json
    {
        if ($error) self::getInstance()->option = JSON_THROW_ON_ERROR;
        self::getInstance()->original = $jsonString;
        return self::getInstance();
    }

    /**
     * Register data to prepare json_encode process
     *
     * @param mix $data
     * @return Json
     */
    public static function stringify($data): Json
    {
        self::getInstance()->attributes = $data;
        return self::getInstance();
    }

    /**
     * Implement IteratorAggregate interface
     *
     * Use for iterate attributes at foreach()
     * 
     * @param Undocumented function value
     * @return value
     */
    public function getIterator(): ArrayIterator
    {
        $this->toArray();
        return new ArrayIterator($this->attributes);
    }

    /**
     * Counting attributes data
     *
     * @return int
     */
    public function count(): int
    {
        $this->process();
        return count((array)$this->attributes);
    }

    /**
     * JSON en|de-code process
     *
     * @param string $type
     * @return Json
     */
    private function process($type = 'decode'): Json
    {
        try {
            $this->attributes = $type === 'decode' ? 
                                    json_decode($this->original, $this->assoc, $this->depth, $this->option) : 
                                    json_encode($this->attributes, $this->option);
        } catch (JsonException $e) {
            $this->error = $e->getMessage();
        }
        return $this;
    }

    /**
     * Convert attributes to array
     *
     * @param Undocumented function value
     * @return value
     */
    public function toArray(): array
    {
        $this->assoc = true;
        $this->process();

        if (!is_array($this->attributes)) 
        {
            $this->error = '$attributes property is not valid json_decode result';
            $this->attributes = [];
        }

        return $this->attributes;
    }

    /**
     * Set up json option
     *
     * @param [type] $option
     * @return void
     */
    public function setOption($option)
    {
        $this->option = $option;
    }

    /**
     * JSON Output with header
     *
     * @return Json
     */
    public function withHeader(): Json
    {
        header('Content-Type: application/json');
        return $this;
    }

    /**
     * Get attributes
     *
     * @return mixed
     */
    public function getAttributes()
    {
        return $this->process()->attributes;
    }

    /**
     * Get JSON error
     *
     * @return string
     */
    public static function getError()
    {
        return self::getInstance()->error;
    }

    /**
     * Get value from attributes based on magic property
     *
     * @param [type] $key
     * @return mixed
     */
    public function __get($key)
    {
        return self::getInstance()->process()->toArray()[$key]??null;
    }

    /**
     * Call Json scope for optional json process
     * as magic method
     *
     * @param [type] $method
     * @param [type] $params
     * @return void
     */
    public function __call($method, $params)
    {
        if (isset($this->scope[$method])) $this->option = $this->scope[$method];
        return $this;
    }

    /**
     * Main output for encoding process
     *
     * @param Undocumented function value
     * @return value
     */
    public function __toString()
    {
        $this->process('encode');
        $output = '';
        if ($this->option === JSON_PRETTY_PRINT) $output .= '<pre>';
        $output .= $this->attributes;
        if ($this->option === JSON_PRETTY_PRINT) $output .= '</pre>';
        
        return $output;
    }
}
================================================================================
File: member_api.inc.php
================================================================================

<?php
/**
 * API class
 * A Collection of API static utility methods
 *
 * Copyright (C) 2016  Hendro Wicaksono (hendrowicaksono@gmail.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

class membershipApi
{
  public static function getMembershipType($obj_db)
  {
    $sMtype = 'SELECT * FROM mst_member_type';
    $qMtype = $obj_db->query($sMtype);
    $_return = array ();
    $_return[0]['member_type_name'] = __('All');

    if (!$obj_db->errno) {
      $i = 0;
      while ($rMtype = $qMtype->fetch_assoc()) {
        #$_return[$i]['member_type_id'] = $rMtype['member_type_id'];
        $member_type_id = $rMtype['member_type_id'];
        #$_return[$i]['member_type_name'] = $rMtype['member_type_name'];
        $_return[$member_type_id]['member_type_name'] = $rMtype['member_type_name'];
        $i++;
      }
    }
    #return api::to_object($_return);
    return ($_return);
  }

}

================================================================================
File: member_logon.inc.php
================================================================================

<?php
/**
 * Member Login class
 * Class for user authentication
 *
 * Copyright (C) 2007,2008  Arie Nugraha (dicarve@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} else if (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

class member_logon
{
    private $obj_db = false;
    protected $username = '';
    protected $password = '';
    protected $auth_method = 'native';
    protected $user_info = array();
    public $real_name = '';
    public $ip_check = false;
    public $ip_allowed = array();
    public $errors = '';


    /**
     * Class Constructor
     *
     * @param   string  $str_username
     * @param   string  $str_password
     * @param   string  $str_auth_method
     * @return  void
     */
    public function __construct($str_username, $str_password, $str_auth_method = 'native') {
        $this->username = trim($str_username);
        $this->password = trim($str_password);
        $this->auth_method = $str_auth_method;
    }


 /**
     * LDAP/Active directory login
     *
     * @return  boolean
     */
    protected function ldapLogin() {
        global $ldap_configs;
        if (!function_exists('ldap_connect')) {
            $this->errors = 'LDAP library is not installed yet!';
            return false;
        }
        // connect to Directory Server
        $_ds = $ldap_configs['ldap_port']?ldap_connect($ldap_configs['ldap_server'], $ldap_configs['ldap_port']):ldap_connect($ldap_configs['ldap_server']);

        // check LDAP options
        if ($ldap_configs['ldap_options']) {
            foreach ($ldap_configs['ldap_options'] as $_opt) {
                @ldap_set_option($_ds, $_opt[0], $_opt[1]);
            }
        }

        // LDAP Connection check
        if (!$_ds) {
            $this->errors = 'Failed to connect to LDAP server';
            return false;
        }

        // LDAP binding
        // for Active Directory Server login active line below
        // $_bind = ldap_bind($_ds, ( $ldap_configs['ldap_suffix']?$this->username.'@'.$ldap_configs['ldap_suffix']:$this->username ), $this->password);
        $_bind = @ldap_bind($_ds,
            str_ireplace('#loginUserName', $this->username, $ldap_configs['ldap_bind_dn']),
            $this->password);

        if (!$_bind) {
            $this->errors = 'Failed to bind to directory server!';
            return false;
        }

        $_filter = str_ireplace('#loginUserName', $this->username, $ldap_configs['ldap_search_filter']);

        // run query
        $_search = @ldap_search($_ds, $ldap_configs['ldap_base_dn'], $_filter);
        if (!$_search) {
            $this->errors = 'LDAP search failed because of error!';
            return false;
        }

        // get query entry
        $_entries = @ldap_get_entries($_ds, $_search);
        if ($_entries) {
            $this->user_info['member_id'] = $_entries[0][$ldap_configs['userid_field']][0];
            // check member in database
            $_check_q = $this->obj_db->query('SELECT m.member_id, m.member_name, m.inst_name,
                m.member_email, m.expire_date, m.register_date, m.is_pending,
                m.member_type_id, mt.member_type_name, mt.enable_reserve, mt.reserve_limit
                FROM member AS m LEFT JOIN mst_member_type AS mt ON m.member_type_id=mt.member_type_id
                WHERE m.member_id=\''.$this->user_info['member_id'].'\'');
            if ($_check_q->num_rows < 1) {
                $_curr_date = date('Y-m-d H:i:s');
                $_userid_field = strtolower($ldap_configs['userid_field']);
                $_fullname_field = strtolower($ldap_configs['fullname_field']);
                // insert member data to database
                $this->user_info['member_id'] = $_entries[0][$_userid_field][0];
                $this->user_info['member_name'] = $_entries[0][$_fullname_field][0];
                $this->user_info['gender'] = '1';
                $this->user_info['inst_name'] = 'New registered member';
                $this->user_info['member_email'] = $_entries[0][$ldap_configs['mail_field']][0];
                $this->user_info['expire_date'] = '0000-00-00';
                $this->user_info['register_date'] = '0000-00-00';
                $this->user_info['is_pending'] = '1';
                $this->user_info['member_type_id'] = '1';
                $this->user_info['input_date'] = $_curr_date;
                $this->user_info['last_update'] = $_curr_date;

                // include database operation library
                require_once SIMBIO.'simbio_DB/simbio_dbop.inc.php';
                $_dbop = new simbio_dbop($this->obj_db);
                $_insert = $_dbop->insert('member', $this->user_info);
                if (!$_insert) {
                    $this->errors = 'Member insertion error because of: '.$_dbop->error;
                }
                $this->user_info['member_type_name'] = 'None';
            } else {
                $this->user_info = $_check_q->fetch_assoc();
            }
        } else {
            $this->errors = 'LDAP Record not found!';
            return false;
        }

        // closing connection
        ldap_close($_ds);
        return true;
    }


    /**
     * Native database checking login method
     *
     * @return  boolean
     */
    public function nativeLogin() {
        /*
        $_sql_member_login = sprintf("SELECT m.member_id, m.member_name, m.inst_name,
            m.member_email, m.expire_date, m.register_date, m.is_pending,
            m.member_type_id, mt.member_type_name, mt.enable_reserve, mt.reserve_limit
            FROM member AS m LEFT JOIN mst_member_type AS mt ON m.member_type_id=mt.member_type_id
            WHERE m.member_id='%s'
                AND m.mpasswd=MD5('%s')", $this->obj_db->escape_string($this->username), $this->obj_db->escape_string($this->password));
        */
        $_sql_member_login = sprintf("SELECT m.member_id, m.member_name, m.mpasswd, m.inst_name,
            m.member_email, m.expire_date, m.register_date, m.is_pending,
            m.member_type_id, mt.member_type_name, mt.enable_reserve, mt.reserve_limit, m.member_image
            FROM member AS m LEFT JOIN mst_member_type AS mt ON m.member_type_id=mt.member_type_id
            WHERE m.member_id='%s'", $this->obj_db->escape_string($this->username));
        $_member_q = $this->obj_db->query($_sql_member_login);

        // error check
        if ($this->obj_db->error) {
            $this->errors = 'Failed to query member data from database with error: '.$this->obj_db->error;
            return false;
        }
        
        // result check
        if ($_member_q->num_rows < 1) {
            $this->errors = 'Username or Password not exists in database!';
            return false;
        }
        
        // get user info
        $this->user_info = $_member_q->fetch_assoc();
        // verify password hash
        $verified = password_verify($this->password, $this->user_info['mpasswd']??'');
        if (!$verified) {
            //check if md5
            if($this->user_info['mpasswd'] == md5($this->password)){
                $_sql_update_password = sprintf("UPDATE member SET mpasswd = '%s', last_update = CURDATE() WHERE member_id = '%s'",
                password_hash($this->password, PASSWORD_BCRYPT), $this->username);
                $_update_q = $this->obj_db->query($_sql_update_password);
                // error check
                if ($this->obj_db->error) {
                    $this->errors = 'Failed to query user data from database with error: '.$this->obj_db->error;
                    return false;
                }
                return true;
            }else{        	
            $this->errors = 'Username or Password not exists in database!';
            return false;
        	}
        }
        
        return true;
    }


    /**
     * Method to check user validity
     *
     * @param   object  $obj_db
     * @return  void
     */
    public function valid($obj_db) {
        global $sysconf;
        $this->obj_db = $obj_db;
        $_check_login = call_user_func(array($this, $this->auth_method.'Login'));
        // check if the user exist in database
        if (!$_check_login) {
          return false;
        }

        // fill all sessions var
        $_SESSION['mid'] = $this->user_info['member_id'];
        $_SESSION['m_name'] = $this->user_info['member_name'];
        $_SESSION['m_email'] = $this->user_info['member_email'];
        $_SESSION['m_institution'] = $this->user_info['inst_name'];
        $_SESSION['m_logintime'] = time();
        $_SESSION['m_expire_date'] = $this->user_info['expire_date'];
        $_SESSION['m_member_type_id'] = $this->user_info['member_type_id'];
        $_SESSION['m_member_type'] = $this->user_info['member_type_name'];
        $_SESSION['m_register_date'] = $this->user_info['register_date'];
        $_SESSION['m_membership_pending'] = intval($this->user_info['is_pending'])?true:false;
        $_SESSION['m_is_expired'] = false;
        $_SESSION['m_mark_biblio'] = array();
        $_SESSION['m_can_reserve'] = $this->user_info['enable_reserve'];
        $_SESSION['m_reserve_limit'] = $this->user_info['reserve_limit'];
        $_SESSION['m_image'] = $this->user_info['member_image'];

        // set bookmark
        $bookmarkStatement = $obj_db->query('SELECT `biblio_id` FROM `biblio_mark` WHERE `member_id` = \'' . $obj_db->escape_string($this->user_info['member_id']) . '\'');

        if ($bookmarkStatement)
        {
            $_SESSION['bookmark'] = [];
            while ($bookmark = $bookmarkStatement->fetch_row()) {
                $_SESSION['bookmark'][$bookmark[0]] = $bookmark[0];
            }
        }

        // check member expiry date
        require_once SIMBIO.'simbio_UTILS/simbio_date.inc.php';
        $_curr_date = date('Y-m-d');
        if (simbio_date::compareDates($this->user_info['expire_date'], $_curr_date) == $_curr_date) {
            $_SESSION['m_is_expired'] = true;
        }

        // update the last login time
        $obj_db->query("UPDATE member SET last_login='".date("Y-m-d H:i:s")."',
            last_login_ip='".ip()."'
            WHERE member_id='".$obj_db->escape_string($this->user_info['member_id'])."'");

        return true;
    }
}

================================================================================
File: member_session.inc.php
================================================================================

<?php
/**
 *
 * Member SESSION Settings
 * Copyright (C) 2009  Arie Nugraha (dicarve@yahoo.com)
 * Taken and modified from phpMyAdmin's Session library
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

use SLiMS\Session\Factory as SessionFactory;
use SLiMS\Session\Driver\Files;

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

// use session factory to handle session based on default SLiMS or user handler
SessionFactory::use(config('customSession', Files::class))->start('memberArea');

================================================================================
File: modsxmlsenayan.inc.php
================================================================================

<?php
/**
 *
 * MODS XML to SENAYAN converter
 *
 * Copyright (C) 2010 Hendro Wicaksono (hendrowicaksono@yahoo.com)
 * Copyright (C) 2011,2012 Arie Nugraha (dicarve@gmail.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

define('MODS_XML_PARSE_ERROR', 199);

use SLiMS\Url;
use SLiMS\Http\Client;

/**
 * MODS XML parser for SENAYAN 3
 * @param string $str_modsxml : can be string, file or uri
 * @return  mixed
 **/
function modsXMLsenayan($str_modsxml, $str_xml_type = 'string')
{
  // initiate records array
  $_records = array();

  // load XML
  if ($str_xml_type == 'file') {
    // load from file
    if (file_exists($str_modsxml)) {
      $xml = @simplexml_load_file($str_modsxml);
    } else {
      return 'File ' . $str_modsxml . ' not found! Please supply full path to MODS XML file';
    }
  } else {
    // load from string
    try {
      $modsxml = $str_modsxml;
      if ($str_xml_type == 'uri' && Url::isValid($modsxml))
      {
        $getModsxml = Client::get($modsxml);
        if (!empty($getModsxml->getError())) throw new Exception($getModsxml->getError());
        $modsxml = $getModsxml->getContent();
      }

      // parse xml string 
      $xml = @new SimpleXMLElement($modsxml, LIBXML_NSCLEAN);
    } catch (Exception $xmlerr) {
      return $xmlerr->getMessage();
      // die($xmlerr->getMessage());
    }
  }

  // get result information from SLiMS Namespaced node
  $_slims = $xml->children('http://senayan.diknas.go.id');
  if (!$_slims) {
    $_slims = $xml->children('http://slims.web.id');
  }

  if ($_slims) {
    if (isset($_slims->resultInfo)) {
      $_records['result_num'] = (integer)$_slims->resultInfo->modsResultNum;
      $_records['result_page'] = (integer)$_slims->resultInfo->modsResultPage;
      $_records['result_showed'] = (integer)$_slims->resultInfo->modsResultShowed;
    } else {
      $_records['result_num'] = (integer)$_slims->modsResultNum;
      $_records['result_page'] = (integer)$_slims->modsResultPage;
      $_records['result_showed'] = (integer)$_slims->modsResultShowed;
    }
  } else {
    $_records['result_num'] = isset($xml->modsResultNum) ? $xml->modsResultNum : '';
    $_records['result_page'] = isset($xml->modsResultPage) ? $xml->modsResultPage : '';
    $_records['result_showed'] = isset($xml->modsResultShowed) ? $xml->modsResultShowed : '';
  }

  $record_num = 0;
  // start iterate records
  foreach ($xml->mods as $record) {
    $data = array();

    $data['id'] = (string)$record['ID'];
    if (!$data['id']) {
      $data['id'] = (string)$record['id'];
    }
    # authors
    $data['authors'] = array();

    # title
    $data['title'] = (string)$record->titleInfo->title;
    if (isset($record->titleInfo->subTitle)) {
      $data['title'] .= (string)$record->titleInfo->subTitle;
    }

    # name/author (repeatable)
    if (isset($record->name) AND $record->name) {
      foreach ($record->name as $value) {
        $_author_type = $value['type'];
        if ($value->role->roleTerm == 'Primary Author') {
          $_level = 1;
        } else {
          $_level = 2;
        }
        $data['authors'][] = array('name' => (string)$value->namePart, 'authority_list' => (string)$value['authority'], 'level' => $_level, 'author_type' => (string)$_author_type);
      }
    }

    # mods->typeOfResource
    $data['manuscript'] = (boolean)$record->typeOfResource['manuscript'] == 'yes';
    $data['collection'] = (boolean)$record->typeOfResource['collection'] == 'yes';
    $data['resource_type'] = (string)$record->typeOfResource;

    # mods->genre
    $data['genre_authority'] = (string)$record->genre['authority'];
    $data['genre'] = (string)$record->genre;

    # mods->originInfo
    $data['publish_place'] = isset($record->originInfo->place->placeTerm) ? (string)$record->originInfo->place->placeTerm : '';
    $data['publisher'] = (string)$record->originInfo->publisher;
    $data['publish_year'] = (string)$record->originInfo->dateIssued;
    $data['issuance'] = (string)$record->originInfo->issuance;
    $data['edition'] = (string)$record->originInfo->edition;

    # mods->language
    if (isset($record->language->languageTerm)) {
      foreach ($record->language->languageTerm as $_langterm) {
        if ($_langterm['type'] == 'code') {
          $data['language']['code'] = (string)$_langterm;
        } else {
          $data['language']['name'] = (string)$_langterm;
        }
      }
    }

    # mods->physicalDescription
    $data['gmd'] = (string)$record->physicalDescription->form;
    $data['collation'] = (string)$record->physicalDescription->extent;

    # mods->relatedItem
    if ($record->relatedItem['type'] == 'series') {
      $data['series_title'] = (string)$record->relatedItem->titleInfo->title;
    }

    # mods->note
    $data['notes'] = (string)$record->note;

    # mods->subject
    foreach ($record->subject as $_subj) {
      $_authority = (string)$_subj['authority'];
      if (isset($_subj->topic)) {
        $_term_type = 'topical';
        $_term = (string)$_subj->topic;
      }
      if (isset($_subj->geographic)) {
        $_term_type = 'geographic';
        $_term = (string)$_subj->geographic;
      }
      if (isset($_subj->name)) {
        $_term_type = 'name';
        $_term = (string)$_subj->name;
      }
      if (isset($_subj->temporal)) {
        $_term_type = 'temporal';
        $_term = (string)$_subj->temporal;
      }
      if (isset($_subj->genre)) {
        $_term_type = 'genre';
        $_term = (string)$_subj->genre;
      }
      if (isset($_subj->occupation)) {
        $_term_type = 'occupation';
        $_term = (string)$_subj->occupation;
      }
      $data['subjects'][] = array('term' => $_term ?? '', 'term_type' => $_term_type ?? '', 'authority' => $_authority);
    }

    # mods->classification
    $data['classification'] = (string)$record->classification;

    # mods->identifier
    $data['isbn_issn'] = '';
    if ($record->identifier['type'] == 'isbn') {
      $data['isbn_issn'] = (string)$record->identifier;
    }

    # mods->location
    $data['location'] = (string)$record->location->physicalLocation;
    $data['call_number'] = (string)$record->location->shelfLocator;

    # mods->recordInfo
    if (isset($record->recordInfo)) {
      $data['id'] = (string)$record->recordInfo->recordIdentifier;
      $data['create_date'] = (string)$record->recordInfo->recordCreationDate;
      $data['modified_date'] = (string)$record->recordInfo->recordChangeDate;
      $data['origin'] = (string)$record->recordInfo->recordOrigin;
    }

    $_slims = $record->children('http://slims.web.id');

    # images
    if (isset($_slims->image)) {
      $data['image'] = (string)$_slims->image;
    }

    # digital files
    if (isset($_slims->digitals)) {
      foreach ($_slims->digitals->digital_item as $_dig_item) {
        // get attributes
        $_attr = (array)$_dig_item->attributes();
        $data['digitals'][] = array('id' => $_attr['@attributes']['id'],
          'title' => (string)$_dig_item,
          'path' => $_attr['@attributes']['path'],
          'mimetype' => $_attr['@attributes']['mimetype'],
          'url' => $_attr['@attributes']['url']);
      }
    }

    $_records['records'][] = $data;
    $record_num++;
  }
  return $_records;
}

================================================================================
File: modsxmlslims.inc.php
================================================================================

<?php
/**
 *
 * MODS XML to SENAYAN
 *
 * Copyright (C) 2011,2012 Arie Nugraha (dicarve@gmail.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

/**
 * MODS XML Record parser
 * @param   object  $modsrecords: XML record object from simpleXML
 * @return  array
 **/
function modsXMLslims($modsrecords)
{
    $data = array();

    # authors
    $data['authors'] = array();

    # title
    $data['title'] = (string)$modsrecords->titleInfo->title;
    if (isset($modsrecords->titleInfo->subTitle)) {
      $data['title'] .= ': '.(string)$modsrecords->titleInfo->subTitle;
    }

    # name/author (repeatable)
    if (isset($modsrecords->name) AND $modsrecords->name) {
      foreach ($modsrecords->name as $value) {
        $_author_type = $value['type'];
        if ($value->role->roleTerm == 'Primary Author') {
            $_level = 1;
        } else {
            $_level = 2;
        }
        $data['authors'][] = array('name' => (string)$value->namePart, 'authority_list' => (string)$value['authority'], 'level' => $_level, 'author_type' => (string)$_author_type);
        // $data['authors'][] = (string)$value->namePart;
      }
    }

    # mods->typeOfResource
    $data['manuscript'] = (boolean)$modsrecords->typeOfResource['manuscript'] == 'yes';
    $data['collection'] = (boolean)$modsrecords->typeOfResource['collection'] == 'yes';
    $data['resource_type'] = (string)$modsrecords->typeOfResource;

    # mods->genre
    $data['genre_authority'] = (string)$modsrecords->genre['authority'];
    $data['genre'] = (string)$modsrecords->genre;

    # mods->originInfo
    $data['publish_place'] = isset($modsrecords->originInfo->place->placeTerm)?(string)$modsrecords->originInfo->place->placeTerm:'';
    $data['publisher'] = (string)$modsrecords->originInfo->publisher;
    $data['publish_year'] = (string)$modsrecords->originInfo->dateIssued;
    $data['issuance'] = (string)$modsrecords->originInfo->issuance;
    $data['edition'] = (string)$modsrecords->originInfo->edition;

    # mods->language
    if (isset($modsrecords->language->languageTerm)) {
      foreach ($modsrecords->language->languageTerm as $_langterm) {
        if ($_langterm['type'] == 'code') {
          $data['language']['code'] = (string)$_langterm;
        } else {
          $data['language']['name'] = (string)$_langterm;
        }
      }
    }

    # mods->physicalDescription
    $data['gmd'] = (string)$modsrecords->physicalDescription->form;
    $data['collation'] = (string)$modsrecords->physicalDescription->extent;

    # mods->relatedItem
    if ($modsrecords->relatedItem['type'] == 'series') {
      $data['series_title'] = (string)$modsrecords->relatedItem->titleInfo->title;
    }

    # mods->note
    $data['notes'] = (string)$modsrecords->note;

    # mods->subject
    $_term_type = 'topical';
    $_term = '';
    foreach ($modsrecords->subject as $_subj) {
      $_authority = (string)$_subj['authority'];
      if (isset($_subj->topic)) {
          $_term_type = 'topical';
          $_term = (string)$_subj->topic;
      }
      if (isset($_subj->geographic)) {
          $_term_type = 'geographic';
          $_term = (string)$_subj->geographic;
      }
      if (isset($_subj->name)) {
          $_term_type = 'name';
          $_term = (string)$_subj->name;
      }
      if (isset($_subj->temporal)) {
          $_term_type = 'temporal';
          $_term = (string)$_subj->temporal;
      }
      if (isset($_subj->genre)) {
          $_term_type = 'genre';
          $_term = (string)$_subj->genre;
      }
      if (isset($_subj->occupation)) {
          $_term_type = 'occupation';
          $_term = (string)$_subj->occupation;
      }
      $data['subjects'][] = array('term' => $_term, 'term_type' => $_term_type, 'authority' => $_authority);
    }

    # mods->classification
    $data['classification'] = (string)$modsrecords->classification;

    # mods->identifier
    if ($modsrecords->identifier['type'] == 'isbn') {
      $data['isbn_issn'] = (string)$modsrecords->identifier;
    }

    # mods->location
    $data['location'] = (string)$modsrecords->location->physicalLocation;
    $data['call_number'] = (string)$modsrecords->location->shelfLocator;

    # mods->recordInfo
    if (isset($modsrecords->recordInfo)) {
      $data['id'] = (string)$modsrecords->recordInfo->recordIdentifier;
      $data['create_date'] = (string)$modsrecords->recordInfo->recordCreationDate;
      $data['modified_date'] = (string)$modsrecords->recordInfo->recordChangeDate;
      $data['origin'] = (string)$modsrecords->recordInfo->recordOrigin;
    }

    return $data;
}

================================================================================
File: module.inc.php
================================================================================

<?php

/**
 * module class
 * Application modules related class
 *
 * Copyright (C) 2010 Arie Nugraha (dicarve@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

use SLiMS\GroupMenu;
use SLiMS\GroupMenuOrder;
use SLiMS\Plugins;

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

class module extends simbio
{
    private $modules_dir = 'modules';
    private $module_table = 'mst_module';
    public $module_list = array();
    public $appended_first;
    public $appended_last;


    public function __construct()
    {
        $this->appended_first = '<li><a class="menu home#replaced#" href="index.php"><span>' . __('Home') . '</a></li><li><a class="menu opac" href="../index.php" title="' . __('View OPAC in New Window') . '" target="_blank"><span>' . __('OPAC') . '</span></a></li>';
        $this->appended_last = '<li><a class="menu logout" href="logout.php"><span>' . __('Logout') . '</span></a></li>';
    }

    /**
     * Method to set modules directory
     *
     * @param string $str_modules_dir
     * @return  void
     */
    public function setModulesDir($str_modules_dir)
    {
        $this->modules_dir = $str_modules_dir;
    }


    /**
     * Method to generate a list of module menu
     *
     * @param object $obj_db
     * @return  string
     */
    public function generateModuleMenu($obj_db)
    {
        // create the HTML Hyperlinks
        $_menu = '<ul id="menuList">';
        $_menu .= !isset($_GET['mod']) ? str_replace('#replaced#', ' menuCurrent', $this->appended_first) : str_replace('#replaced#', '', $this->appended_first);
        // sort modules
        if ($this->module_list = $this->getModuleMainMenu($obj_db)) {
            foreach ($this->module_list as $_module) {
                $_formated_module_name = ucwords(str_replace('_', ' ', $_module['name']));
                $_mod_dir = $_module['path'];
                $_menu .= '<li><a class="menu ' . $_module['name'] . ((isset($_GET['mod']) && $_GET['mod'] == $_module['path']) ? ' menuCurrent' : '') . '" title="' . $_module['desc'] . '" href="index.php?mod=' . $_mod_dir . '"><span>' . __($_formated_module_name) . '</span></a></li>';
            }
        }
        $_menu .= $this->appended_last;
        $_menu .= '</ul>';

        return $_menu;
    }

    /**
     * Method to get a list of module menu
     *
     * @param object $obj_db
     * @param boolean $also_get_childs
     * @return  array
     */
    public function getModuleMainMenu($obj_db, $also_get_childs = false)
    {
        $_menu = array();
        $module_list = array();
        // get module data from database
        $_mods_q = $obj_db->query('SELECT * FROM ' . $this->module_table);
        while ($_mods_d = $_mods_q->fetch_assoc()) {
            $module_list[] = array('name' => $_mods_d['module_name'], 'path' => $_mods_d['module_path'], 'desc' => $_mods_d['module_desc']);
        }

        // Get module from plugin
        Plugins::run('module_main_menu_init', [&$module_list]);
        
        // sort modules
        if ($module_list) {
            foreach ($module_list as $_id => $_module) {
                $_mod_dir = $_module['path'];
                $_path_exists = file_exists($this->modules_dir . $_mod_dir) || (isset($_module['plugin_module_path']) && file_exists($_module['plugin_module_path']));
                if (isset($_SESSION['priv'][$_module['path']]['r']) && $_SESSION['priv'][$_module['path']]['r'] && $_path_exists) {
                    $_menu[$_id] = $_module;
                    if ($also_get_childs) {
                        $_menu[$_id]['childs'] = $this->getSubMenuItems($_module['name']);
                    }
                }
            }
        }

        return $_menu;
    }


    /**
     * Method to generate a list of module submenu
     *
     * @param string $str_module
     * @return  string
     */
    public function generateSubMenu($str_module = '')
    {
        global $dbs;
        $_submenu = '';
        $_submenu_current = 'curModuleLink';
        $i = 0;
        $menus = $this->getSubMenuItems($str_module);
        // iterate menu array
        foreach ($menus as $header => $menu) {
            $_submenu .= '<div class="subMenuHeader subMenuHeader-' . $header . '">' . strtoupper($header) . '</div>';

            foreach ($menu as $item) {
                if ($i > 0) $_submenu_current = '';
                $_submenu .= '<a class="subMenuItem ' . $_submenu_current . '" '
                    . ' href="' . $item[1] . '"'
                    . ' title="' . (isset($item[2]) ? $item[2] : $item[0]) . '" href="#"><span>' . $item[0] . '</span></a>';
                $i++;
            }
        }
        $_submenu .= '&nbsp;';
        return $_submenu;
    }

    /**
     * Method to get a list of module submenu
     *
     * @param string $str_module
     * @return  array
     */
    public function getSubMenuItems($str_module = '')
    {
        global $dbs;
        $_submenu_file = $this->modules_dir . $str_module . DIRECTORY_SEPARATOR . 'submenu.php';

        // get menus from plugins
        $plugin_menus = \SLiMS\Plugins::getInstance()->getMenus($str_module);

        if (file_exists($_submenu_file) || (isset($_SESSION['priv'][$str_module]['submenu']) && file_exists($_submenu_file = $_SESSION['priv'][$str_module]['submenu']))) {
            include $_submenu_file;
        } else {
            include 'default/submenu.php';
            foreach ($this->get_shortcuts_menu($dbs) as $key => $value) {
                $link = explode('|', $value);
                // Exception for shortcut menu based on registered plugin
                if (preg_match('/plugin_container/', $link[1])) {
                    $menu[$link[0]] = array(__($link[0]), $link[1]);
                    continue;
                }
                $menu[$link[0]] = array(__($link[0]), MWB . $link[1]);
            }
        }

        $menus = [];
        foreach ($this->reorderMenus($menu, $plugin_menus) as $header => $items) {
            foreach ($items as $item) {
                $menus[$header] = $menus[$header] ?? [];
                if ($_SESSION['uid'] > 1 && !empty($str_module) && !in_array(md5($item[1]), $_SESSION['priv'][$str_module]['menus'] ?? [])) continue;
                $menus[$header][] = $item;
            }
        }
        $menus = array_filter($menus, fn ($m) => count($m) > 0);
        return $menus;
    }

    /**
     * Method to order default menu and plugin menu
     * 
     * @param array $default 
     * @param array $plugin 
     * @return array 
     */
    function reorderMenus($default, $plugin)
    {
        $groups = [];
        $orders = GroupMenuOrder::getInstance()->getOrder();
        $group_menu = GroupMenu::getInstance()->getGroup();

        // collect header from default menu
        $header = null;
        foreach ($default as $menu) {
            if (count($menu) === 2 && strtolower($menu[0]) === 'header') {
                // before continue to new header
                // check to plugin group
                if (!is_null($header) && isset($group_menu[$header])) {
                    foreach ($group_menu[$header] as $hash) {
                        $groups[$header][] = $plugin[$hash];
                    }
                    unset($group_menu[$header]);
                }

                // reset header
                $header = null;
                // iterate orders
                if (count($orders) > 0) {
                    // get menu before
                    foreach ($orders as $key => $value) {
                        if (count($plugin) < 1) break;
                        $group_menu_items = array_map(fn ($i) => $plugin[$i] ?? [], $group_menu[$key]);
                        if (count($group_menu_items) > 0 && strtolower($menu[1]) === $value['group'] && $value['position'] === 'before')
                            $groups[strtolower($key)] = $group_menu_items;
                    }

                    // main menu
                    $groups[strtolower($menu[1])] = [];

                    // get menu after
                    foreach ($orders as $key => $value) {
                        if (count($plugin) < 1) break;
                        $group_menu_items = array_map(fn ($i) => $plugin[$i] ?? [], $group_menu[$key]);
                        if (count($group_menu_items) > 0 && strtolower($menu[1]) === $value['group'] && $value['position'] === 'after')
                            $groups[strtolower($key)] = $group_menu_items;
                    }
                } else {
                    $groups[strtolower($menu[1])] = [];
                }
                $header = strtolower($menu[1]);
                continue;
            }
            if (!is_null($header)) {
                // Check if the registered plugin menu label is the same as the default
                $override_menu = array_values(array_filter($plugin, function($itemPlugin) use($menu) {
                    if ($itemPlugin[0] === $menu[0] && isset($itemPlugin[3])) return true;
                }))[0]??$menu;

                // if match then remove matching plugin from plugin list
                if (isset($override_menu[3])) unset($plugin[md5(realpath($override_menu[3]??''))]);

                // Register menu into group
                $groups[strtolower($header)][] = $override_menu;
            }
        }

        foreach ($group_menu as $header => $menus) {
            $tmp_menu = [];
            foreach ($menus as $hash) {
                if (isset($plugin[$hash])) $tmp_menu[] = $plugin[$hash];
            }

            if(count($tmp_menu) > 0) $groups[$header] = $tmp_menu;
        }

        // ungrouped plugin group to "plugins" group
        $ungrouped = array_filter(array_keys($plugin), fn ($p) => !in_array($p, GroupMenu::getInstance()->getPluginInGroup()));
        $ungrouped = ['plugins' => array_map(fn ($i) => $plugin[$i], $ungrouped)];

        // merge group
        if (count($plugin) > 0)
            $groups = array_merge($groups, $ungrouped);

        return $groups;
    }

    /**
     * Method to get a first submenu of module
     * 
     * @param string $str_module 
     * @return mixed 
     */
    public function getFirstMenu($str_module = '')
    {
        $menus = $this->getSubMenuItems($str_module);
        $key = array_keys($menus)[0] ?? false;
        if ($key) return $menus[$key][0] ?? null;
        return null;
    }

    /**
     * Method to get a list of shortcut submenu
     *
     * @param object $obj_db
     * @return  array
     */
    function get_shortcuts_menu()
    {
        global $dbs;
        $shortcuts = array();
        $shortcuts_q = $dbs->query('SELECT * FROM setting WHERE setting_name LIKE \'shortcuts_' . $dbs->escape_string($_SESSION['uid']) . '\'');
        $shortcuts_d = $shortcuts_q->fetch_assoc();
        if ($shortcuts_q->num_rows > 0) {
            $shortcuts = unserialize($shortcuts_d['setting_value']);
        }
        return $shortcuts;
    }

    public function unprivileged()
    {
        global $sysconf;
        $alertType = 'alert-warning';
        $alertTitle = __('Warning');
        $alertMessage = __('You don\'t have access to interact with this module. Call system administrator to give you right to access it.');
        include SB . 'template/alert.php';
    }
}

================================================================================
File: Number.php
================================================================================

<?php
/**
 * @author Drajat Hasan
 * @email drajathasan20@gmail.com
 * @create date 2022-10-10 22:51:38
 * @modify date 2022-10-15 12:07:31
 * @license GPLv3
 * @desc Number manipulation tool
 */

namespace SLiMS;

class Number
{
    private $input;
    
    public function __construct($input)
    {
        $this->input = $input;
    }

    /**
     * Set an input value
     *
     * @param $input
     * @return Number
     */
    public static function set($input)
    {
        return new static($input);
    }

    /**
     * Convert number into currency format
     *
     * @return string
     */
    public function toCurrency()
    {
        return (new Currency($this->input))->get();
    }

    /**
     * Convert input into integer
     *
     * @return integer
     */
    public function toInteger()
    {
        return (int)$this->input;
    }

    /**
     * Convert input to float data
     *
     * @return float
     */
    public function toFloat()
    {
        return floatval($this->input);
    }

    /**
     * format number into decimal with some criteria
     */
    public function toDecimal(int $decimalNumber = 2, string $decimalSeparator = ',', string $thousand = ',')
    {
        return number_format($this->toFloat(), $decimalNumber, $decimalSeparator, $thousand);
    }

    /**
     * Get number by position number
     *
     * @param integer|null $startPosition
     * @param integer|null $endPosition
     * @return string
     */
    public function get(?int $startPosition, ?int $endPosition = 0)
    {
        return substr($this, $startPosition, ($endPosition === 0 ? 1 : $endPosition));
    }

    /**
     * Get length of number
     *
     * @return string
     */
    public function len()
    {
        return strlen($this);
    }

    /**
     * Chunk a number with some
     * character
     *
     * @param string $delimiter
     * @return array
     */
    public function chunk(string $delimiter)
    {
        return explode($delimiter, $this);
    }

    /**
     * Round some number
     *
     * @param integer $precision
     * @return void
     */
    public function round(int $precision = 0)
    {
        return (int)round($this->toFloat(), $precision);
    }

    /**
     * Ceil number
     *
     * @return value
     */
    public function ceil()
    {
        return (int)ceil($this->toFloat());
    }

    /**
     * Modulus
     *
     * @param integer $modNumber
     * @return void
     */
    public function mod(int $modNumber)
    {
        return $this->toInteger() % $modNumber;
    }

    public function __toString()
    {
        return (string)$this->input;
    }
}
================================================================================
File: oai-pmh.inc.php
================================================================================

<?php
/**
 * Class for OAI-PMH Web Services
 *
 * Copyright (C) 2012  Arie Nugraha (dicarve@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

class OAI_Web_Service {
  private $db = false;
  private $xml = false;

  public function __construct($obj_db = false) {
    $this->db = $obj_db;
    $this->xml = new XMLWriter();
    $this->xml->openMemory();
    $this->xml->setIndent(true);
  }

  /**
   * Menampilkan seluruh ID (Identifiers) record/dokumen yang ada repositori
   */
  public function ListIdentifiers($metadataPrefix = 'oai_dc') {
    global $sysconf;

    $resumptionToken = array();
    $offset = 0;
    $where = '';
    $metadataPrefix = 'oai_dc';

    if (isset($_GET['resumptionToken'])) {
      list($metadataPrefix, $offset) = explode('/', $_GET['resumptionToken'], 2);
      if (isset($offset)) {
        $offset = (integer)$offset;
      }
     } else {
      if (isset($_GET['offset'])) {
        $offset = (integer)$_GET['offset'];
      }
      if (isset($_GET['metadataPrefix'])) {
        $metadataPrefix = $_GET['metadataPrefix'];
      }
    }

    // total query
    $num_rec_q = $this->db->query("SELECT COUNT(*) FROM biblio $where");
    $num_data = $num_rec_q->fetch_row();
    $completeListSize = $num_data[0];

    $rec_q = $this->db->query("SELECT biblio_id, last_update FROM biblio $where
      ORDER BY biblio_id DESC LIMIT ".$sysconf['OAI']['ListRecords']['RecordPerSet']." OFFSET $offset");

    $this->xml->startElement('request');
        $this->xml->writeAttribute('verb', 'ListIdentifiers');
        $this->xml->writeAttribute('metadataPrefix', $metadataPrefix);
        $this->xmlWrite($this->xml, $sysconf['OAI']['Identify']['baseURL']);
    $this->xml->endElement();
    $this->xml->startElement('ListIdentifiers');
    // mulai iterasi record
    while ($rec_data = $rec_q->fetch_assoc()) {
      $this->xml->startElement('header');
        $this->xml->writeElement('identifier', $sysconf['OAI']['identifierPrefix'].$rec_data['biblio_id']);
        $this->xml->writeElement('datestamp', $rec_data['last_update']);
      $this->xml->endElement();
    }

    // resumptionToken
    if ($completeListSize > $sysconf['OAI']['ListRecords']['RecordPerSet']) {
      $next_offset = $offset+$sysconf['OAI']['ListRecords']['RecordPerSet'];
      if ($next_offset < $completeListSize) {
        $this->xml->startElement('resumptionToken');
        $this->xml->writeAttribute('completeListSize', $completeListSize);
        $this->xml->writeAttribute('cursor', $offset);
        $this->xml->text($metadataPrefix.'/'.$next_offset);
        $this->xml->endElement();
      }
    }

    $this->xml->endElement();

    $ListIdentifiers = $this->xml->flush();

    return $ListIdentifiers;
  }


  /**
   * Menampilkan seluruh Set/Kategori yang ada pada repositori
   */
  public function ListSets() {
    global $sysconf;

    $resumptionToken = array();
    $offset = 0;
    $where = '';
    $metadataPrefix = 'oai_dc';

    if (isset($_GET['resumptionToken'])) {
      $offset = (integer)$_GET['resumptionToken'];
    } else {
      if (isset($_GET['offset'])) {
        $offset = (integer)$_GET['offset'];
      }
    }

    // total query
    $num_rec_q = $this->db->query("SELECT COUNT(*) FROM mst_topic $where");
    $num_data = $num_rec_q->fetch_row();
    $completeListSize = $num_data[0];

    $set_q = $this->db->query("SELECT * FROM mst_topic $where ORDER BY topic ASC LIMIT ".$sysconf['OAI']['ListRecords']['RecordPerSet']." OFFSET $offset");

    ob_start();
    $this->xml->startElement('request');
        $this->xml->writeAttribute('verb', 'ListSets');
        $this->xmlWrite($this->xml, $sysconf['OAI']['Identify']['baseURL']);
    $this->xml->endElement();

    $this->xml->startElement('ListSets');
    // mulai iterasi record
    while ($set_data = $set_q->fetch_assoc()) {
        $this->xml->startElement('set');
        $this->xml->writeElement('setSpec', $set_data['topic_id']);
        $this->xml->writeElement('setName', "Subject = ".$set_data['topic']);
        $this->xml->endElement();
    }

    // resumptionToken
    if ($completeListSize > $sysconf['OAI']['ListRecords']['RecordPerSet']) {
      $next_offset = $offset+$sysconf['OAI']['ListRecords']['RecordPerSet'];
      if ($next_offset < $completeListSize) {
        $this->xml->startElement('resumptionToken');
        $this->xml->writeAttribute('completeListSize', $completeListSize);
        $this->xml->writeAttribute('cursor', $offset);
        $this->xml->text($next_offset);
        $this->xml->endElement();
      }
    }

    $this->xml->endElement();

    $ListSets = $this->xml->flush();

    return $ListSets;
  }


  /**
   * Menampilkan seluruh Deskripsi Record pada repositori
   */
  public function ListRecords($metadataPrefix = 'oai_dc') {
    global $sysconf;

    $resumptionToken = array();
    $offset = 0;
    $from = null;
    $until = null;
    $where = '';
    $metadataPrefix = 'oai_dc';

    if (isset($_GET['resumptionToken'])) {
      list($metadataPrefix, $offset) = explode('/', $_GET['resumptionToken'], 2);
      if (isset($offset)) {
        $offset = (integer)$offset;
      }
     } else {
      if (isset($_GET['offset'])) {
        $offset = (integer)$_GET['offset'];
      }
      if (isset($_GET['metadataPrefix'])) {
        $metadataPrefix = $_GET['metadataPrefix'];
      }
    }

    if (isset($_GET['from'])) {
        $from = $this->db->escape_string($_GET['from']);
        $date = date_create($from);
        $from_date = $date->format('Y-m-d H:i:s');
    }
    if (isset($_GET['from']) && isset($_GET['until'])) {
        $until = $this->db->escape_string($_GET['until']);
        $date = date_create($until);
        $until_date = $date->format('Y-m-d H:i:s');
    }
    if ($from && $until) {
        $where = "WHERE input_date >= '$from_date' AND input_date <= '$until_date'";
    }

    // total query
    $num_rec_q = $this->db->query("SELECT COUNT(*) FROM biblio $where");
    $num_data = $num_rec_q->fetch_row();
    $completeListSize = $num_data[0];

    $rec_q = $this->db->query("SELECT biblio_id FROM biblio $where ORDER BY biblio_id DESC LIMIT ".$sysconf['OAI']['ListRecords']['RecordPerSet']." OFFSET $offset");

    ob_start();
    $this->xml->startElement('request');
        $this->xml->writeAttribute('verb', 'ListRecords');
        $this->xml->writeAttribute('metadataPrefix', $metadataPrefix);
        $this->xmlWrite($this->xml, $sysconf['OAI']['Identify']['baseURL']);
    $this->xml->endElement();
    echo $this->xml->flush();
    echo "<ListRecords>\n";
    // mulai iterasi record
    while ($rec_data = $rec_q->fetch_row()) {
      echo $this->outputRecordXML($rec_data[0], $metadataPrefix);
    }

    // resumptionToken
    if ($completeListSize > $sysconf['OAI']['ListRecords']['RecordPerSet']) {
      $next_offset = $offset+$sysconf['OAI']['ListRecords']['RecordPerSet'];
      if ($next_offset < $completeListSize) {
        $this->xml->startElement('resumptionToken');
        $this->xml->writeAttribute('completeListSize', $completeListSize);
        $this->xml->writeAttribute('cursor', $offset);
        $this->xml->text($metadataPrefix.'/'.$next_offset);
        $this->xml->endElement();
        echo $this->xml->flush();
      }
    }

    echo "</ListRecords>\n";

    $ListRecords = ob_get_clean();

    return $ListRecords;
  }


  /**
   * Menampilkan data sebuah record pada repositori
   */
  public function GetRecord($recordID, $metadataPrefix = 'oai_dc') {
    global $sysconf;
    ob_start();
    // check record ID
    /*
    if (strpos($recordID, $sysconf['OAI']['identifierPrefix']) !== true) {
      echo '<request verb="GetRecord" identifier="'.$recordID.'" metadataPrefix="'.$metadataPrefix.'">'.$sysconf['OAI']['Identify']['baseURL'].'</request>'."\n";
      echo '<error code="idDoesNotExist">No matching identifier in our Repository</error>';
      return ob_get_clean();
    }
    */
    $recordID = str_ireplace($sysconf['OAI']['identifierPrefix'], '', $recordID);
    $this->xml->startElement('request');
        $this->xml->writeAttribute('verb', 'GetRecord');
        $this->xml->writeAttribute('identifier', $recordID);
        $this->xml->writeAttribute('metadataPrefix', $metadataPrefix);
        $this->xmlWrite($this->xml, $sysconf['OAI']['Identify']['baseURL']);
    $this->xml->endElement();
    echo $this->xml->flush();
    // echo '<request verb="GetRecord" identifier="'.$recordID.'" metadataPrefix="'.$metadataPrefix.'">'.$sysconf['OAI']['Identify']['baseURL'].'</request>'."\n";
    echo "<GetRecord>\n";
    echo $this->outputRecordXML($recordID, $metadataPrefix);
    echo "</GetRecord>\n";
    $GetRecord = ob_get_clean();

    return $GetRecord;
  }


  /**
   * Menampilkan data mengenai repository ini
   */
  public function Identify() {
    global $sysconf;
    $earliestDatestamp = '';
    $this->xml->startElement('request'); $this->xml->writeAttribute('verb', 'Identify'); $this->xml->text($sysconf['OAI']['Identify']['baseURL']); $this->xml->endElement();
    $this->xml->startElement('Identify');
        $this->xml->writeElement('repositoryName', $sysconf['OAI']['Identify']['repositoryName']);
        $this->xml->writeElement('baseURL', $sysconf['OAI']['Identify']['baseURL']);
        $this->xml->writeElement('protocolVersion', '2.0');
        $this->xml->writeElement('repositoryName', $sysconf['OAI']['Identify']['repositoryName']);
        $this->xml->writeElement('adminEmail', $sysconf['OAI']['Identify']['adminEmail']);
        $this->xml->writeElement('earliestDatestamp', $earliestDatestamp);
        $this->xml->writeElement('deletedRecord', $sysconf['OAI']['Identify']['deletedRecord']);
        $this->xml->writeElement('granularity', $sysconf['OAI']['Identify']['granularity']);
        $this->xml->startElement('description');
             $this->xml->startElement('eprints');
             $this->xml->writeAttribute('xmlns', 'http://www.openarchives.org/OAI/1.1/eprints');
             $this->xml->writeAttribute('xsi:schemaLocation', 'http://www.openarchives.org/OAI/1.1/eprints http://www.openarchives.org/OAI/1.1/eprints.xsd');
                $this->xml->startElement('metadataPolicy');
                    $this->xml->writeElement('text', $sysconf['OAI']['Identify']['metadataPolicy']);
                $this->xml->endElement();
             $this->xml->endElement();
        $this->xml->endElement();
    $this->xml->endElement();
    return $this->xml->flush();
  }


  /**
   * Menampilkan seluruh skema metadata yang didukung oleh repositori ini
   */
  public function ListMetadataFormats() {
    global $sysconf;
    $this->xml->startElement('request');
        $this->xml->writeAttribute('verb', 'ListMetadataFormats');
        $this->xml->text($sysconf['OAI']['Identify']['baseURL']);
    $this->xml->endElement();
    $this->xml->startElement('ListMetadataFormats');
    // query ke database
    foreach ($sysconf['OAI']['MetadataFormats'] as $metadataformat) {
      $this->xml->startElement('metadataFormat');
        $this->xml->writeElement('metadataPrefix', $metadataformat['oai_prefix']);
        $this->xml->writeElement('schema', $metadataformat['schema_xsd']);
        $this->xml->writeElement('metadataNamespace', $metadataformat['namespace']);
      $this->xml->endElement();
    }
    $this->xml->endElement();
    $ListMetadataFormats = $this->xml->flush();

    return $ListMetadataFormats;
  }


  /**
   * Menampilkan detil record metadata dalam bentuk XML
   *
   * @param   mixed   $recordID: ID atau Identifier OAI dari record
   * @param   string  $metadataPrefix:  Prefix dari skema metadata yang diinginkan
   * @param   boolean $headerOnly: tampilkan hanya header dari record XML OAI
   *
   */
  protected function outputRecordXML($recordID, $metadataPrefix = 'oai_dc') {
    global $sysconf;

    // ambil detail record
    if ($metadataPrefix == 'oai_dc') {
      $detail = new detail($this->db, $recordID, 'dc');
      $rec_detail = $detail->DublinCoreOutput();
    }

    // mulai output XML
    ob_start();
    echo "<record><header><identifier>".$sysconf['OAI']['identifierPrefix'].$recordID."</identifier></header>";
    echo "<metadata>";
    if ($metadataPrefix == 'oai_dc') {
      echo '<oai_dc:dc xmlns:oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/oai_dc/ http://www.openarchives.org/OAI/2.0/oai_dc.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">';
    }

    echo $rec_detail;

    if ($metadataPrefix == 'oai_dc') {
      echo '</oai_dc:dc>';
    }

    echo "</metadata>\n";
    echo "</record>\n";
    $recordXML = ob_get_clean();

    return $recordXML;
  }

  private function xmlWrite(&$xmlwriter, $data, $mode = 'Text') {
    if ($mode == 'CData') {
        $xmlwriter->writeCData($data);
    } else {
        $xmlwriter->text($data);
    }
  }
}

================================================================================
File: Opac.php
================================================================================

<?php
/**
 * @composedBy Drajat Hasan
 * @email drajathasan20@gmail.com
 * @create date 2022-08-16 09:07:12
 * @modify date 2023-04-08 10:35:20
 * @license GPLv3
 * @desc modify from SLiMS Index.php
 */

namespace SLiMS;

use Closure,Exception,Content,utility,simbio_security;

class Opac
{
    /**
     * Opac property
     *
     * @var boolean
     */
    private bool $matchPath = false;
    private string $path = '';
    private string $csrf_token = '';
    private bool $invalid_token = false;
    private array $definedVariable = [];
    private array $sysconf = [];
    private $dbs = null;
    
    /**
     * Opac constructor
     *
     * @param array $definedVariable
     * @param array $sysconf
     * @param [type] $dbs
     */
    public function __construct(array $definedVariable, array $sysconf, $dbs)
    {
        $this->definedVariable = $definedVariable;
        $this->sysconf = $sysconf;
        $this->dbs = $dbs;
    }

    /**
     * Hook process before content
     *
     * @param Closure $callback
     * @return void
     */
    public function hookBeforeContent(Closure $callback)
    {
        $callback($this);
        return $this;
    }

    /**
     * Hook process after content
     *
     * @param Closure $callback
     * @return void
     */
    public function hookAfterContent(Closure $callback)
    {
        $callback($this);
        return $this;
    }

    /**
     * Filter path string
     *
     * @param string $path
     * @return void
     */
    public static function filterPath(string $path)
    {
        $path = utility::filterData('p', 'get', false, true, true);
        // some extra checking
        $path = preg_replace('@^(http|https|ftp|sftp|file|smb):@i', '', $path);
        $path = preg_replace('@\/@i','',$path);

        return $path;
    }

    /**
     * Generate search keywords
     * into array javascript with Json::stringify
     *
     * @return void
     */
    public function generateKeywords(array $advanceSearch = [])
    {
        $result = [];
        $hasKeywords = isset($_GET['search']) && (isset($_GET['keywords'])) && ($_GET['keywords'] != '');
        $hasAdvanceSearch = [];

        foreach ($advanceSearch as $search) { $hasAdvanceSearch[] =  trim($_GET[$search]??''); }

        if ($hasKeywords || $hasAdvanceSearch) 
        {
            $result = preg_replace('@\b(exact|and|or|not)\b@i', '', $_GET['keywords']??implode(' ', $hasAdvanceSearch));
            $result = explode(' ', preg_replace('/[^A-Za-z0-9\s]/i', '', $result));
        }

        return Json::stringify($result);
    }

    /**
     * Load coontent based on plugin
     *
     * @return void
     */
    private function loadPluginPath()
    {
        if (isset(($menu = Plugins::getInstance()->getMenus('opac'))[$this->path])) {
            if (file_exists($menu[$this->path][3])) {
                // extract defined variable
                extract($this->definedVariable);
                
                // Default variable for this method
                $path = $this->path;
                $sysconf = $this->sysconf;
                $dbs = $this->dbs;
                $page_title = $menu[$this->path][0];

                // Include plugin file
                include $menu[$this->path][3];
                $this->matchPath = true;
            }
            else
            {
                throw new Exception("Plugin for path {$this->path} is not found!");
            }
        }
        return $this;
    }

    /**
     * Load content from static file 
     * in lib/contents/
     *
     * @return void
     */
    private function loadFileContent()
    {
        if (file_exists(LIB.'contents/'.$this->path.'.inc.php') && !$this->matchPath) {
            // extract defined variable
            extract($this->definedVariable);
            
            if ($this->path != 'show_detail') {
                $this->definedVariable['metadata'] = '<meta name="robots" content="noindex, follow">';
            }

            // Default variable for this method
            $path = $this->path;
            $sysconf = $this->sysconf;
            $dbs = $this->dbs;
            $opac = $this;
            
            include LIB.'contents/'.$this->path.'.inc.php';
            $this->matchPath = true;
        }
        return $this;
    }

    /**
     * Load content from database like
     * news, content etc
     *
     * @return void
     */
    private function loadDbContent()
    {
        if (!$this->matchPath)
        {
            // get content data from database
            $this->definedVariable['metadata'] = '<meta name="robots" content="index, follow">';
            include LIB.'content.inc.php';
            $content = new Content();
            $content_data = $content->get($this->dbs, $this->path);
            if ($content_data) {
                $this->page_title = $content_data['Title'];
                echo $content_data['Content'];
                unset($content_data);
                $this->matchPath = true;
            }
            else
            {
                $this->loadApi();
            }
        }

        return $this;
    }

    /**
     * Fetch route process
     *
     * @return void
     */
    private function loadApi()
    {
        $sysconf = $this->sysconf;
        $dbs = $this->dbs;
        require SB . 'api/v'.$this->sysconf['api']['version'].'/routes.php';
    }

    /**
     * Set HTTP header
     *
     * @param string $headerName
     * @param string $headerValue
     * @return void
     */
    public function setHeader(string $headerName, string $headerValue)
    {
        header(trim($headerName) . ':' . trim($headerValue));
    }

    /**
     * Set csrf token
     *
     * @return void
     */
    private function setCsrf()
    {
        $this->csrf_token = \Slims\Opac\Security::getCsrfToken();
        $_SESSION['csrf_token'] = $this->csrf_token;
    }

    /**
     * Get CSRF token
     *
     * @return void
     */
    public function getCsrf()
    {
        return $this->csrf_token;
    }

    /**
     * Validate csrf token
     *
     * @return void
     */
    public function validateCsrf()
    {
        if ((isset($_SESSION['csrf_token'])) AND (isset($_GET['csrf_token'])) ) {
            if (!(\Slims\Opac\Security::checkCsrfToken($_SESSION['csrf_token'], $_GET['csrf_token']))) {
                $this->invalid_token = true;
            }
        }
    }

    /**
     * Set Content Security Policy
     *
     * @param array $additionalCsp
     * @return void
     */
    public function setCsp(array $additionalCsp = [])
    {
        $defaultCsp = config('csp', []);
        if (count($defaultCsp)) $this->setHeader('Content-Security-Policy', implode(';', array_merge($defaultCsp, $additionalCsp)));
    }

    /**
     * Parse content to template
     *
     * @return void
     */
    public function parseToTemplate()
    {
        // OPAC
        $opac = $this;
        
        // Validate incoming token and session
        $opac->validateCsrf();

        // csrf
        $opac->setCsrf();

        // extract defined variable
        extract($opac->definedVariable);
        $sysconf = $opac->sysconf;
        $dbs = $opac->dbs;

        // if (!$this->invalid_token)
        // {
            // load default contents
            include LIB.'contents/default.inc.php';
            
            // Sanitaze quote payload before content
            $sanitizer->quoteFree(exception: ['contentDesc','comment']);

            // Load common SLiMS variable
            require LIB.'contents/common.inc.php';
            $main_content = ob_get_clean();
        // }

        // parse into template
        require $opac->sysconf['template']['dir'].'/'.$opac->sysconf['template']['theme'].'/index_template.inc.php';
        exit;
    }

    public function onWeb(Closure $callback)
    {
        if (!isCli()) $callback($this);
        return $this;
    }

    public function onCli()
    {
        Cli\Console::getInstance()->run();
    }

    /**
     * Handle request based on $_GET['p'];
     *
     * @param string $path
     * @return void
     */
    public function handle(string $path)
    {
        // not isset then by pass to Opac::class
        if (!isset($_GET[$path])) return $this;

        // fiiltering inputed path
        $this->path = self::filterPath($_GET[$path]);

        try {
            // start buffering
            ob_start();

            $this
                ->loadPluginPath() // Plugin first
                ->loadFileContent() // or from lib/contents/
                ->loadDbContent() // or from database
                ->parseToTemplate(); // then parse to template
            
        } catch (Exception $e) {
            echo $this->error(isDev() ? $e->getMessage() : 'something wrong.');
            $this->parseToTemplate();
        }
    }

    /**
     * Parse default content
     *
     * @return void
     */
    public function orWelcome()
    {
        $filteredQuery = array_intersect(['keywords','page','title','author','subject','location'], array_keys($_GET));

        ob_start();
        if (empty($filteredQuery)) {
            $this->definedVariable['metadata'] = '<meta name="robots" content="index, follow">';
            // get content data from database
            include LIB.'content.inc.php';
            $content = new Content();
            $content_data = $content->get($this->dbs, 'headerinfo');
            if ($content_data) {
                //$header_info .= '<div id="headerInfo">'.$content_data['Content'].'</div>';
                unset($content_data);
            }
        }

        return $this;
    }

    private function error(string $message)
    {
        // Clear buffer
        ob_get_flush();

        // send as json
        $this->toJson(['status' => false, 'message' => $message]);

        // output buffer
        ob_start();
        $alertType = 'alert-danger';
        $alertTitle = 'Error';
        $alertMessage = $message;
        $sysconf = $this->sysconf;

        // load alert template
        require SB . 'template/alert.php';
        return ob_get_clean();
    }

    /**
     * Output content as JSON with header
     *
     * @param mix $data
     * @return void
     */
    public function toJson($data)
    {
        if (isset($_SERVER['CONTENT_TYPE']) && $_SERVER['CONTENT_TYPE'] === 'application/json') 
            die(Json::stringify($data)->withHeader());
    }

    /**
     * Mutatate an existing key in sysconf
     * we don't want to add new key directly
     *
     * @param [type] $key
     * @param [type] $value
     * @return void
     */
    public function mutateConf($key, $value)
    {
        if (isset($this->sysconf[$key])) $this->sysconf[$key] = $value;
    }

    /**
     * Setter for definedVariable property
     *
     * @param string $key
     * @param string $value
     * @return @return Undocumented function
     */
    public function __set($key, $value)
    {
        $this->definedVariable[$key] = $value;
    }

    /**
     * Getter for sysconf & definedVariable property
     *
     * @param string $key
     * @return @return Undocumented function
     */
    public function __get($key)
    {
        if (isset($this->definedVariable[$key])) return $this->definedVariable[$key];
        if (isset($this->sysconf[$key])) return $this->sysconf[$key];
    }
}
================================================================================
File: Plugins.php
================================================================================

<?php

/**
 * @Created by          : Waris Agung Widodo (ido.alit@gmail.com)
 * @Date                : 05/11/20 13.53
 * @File name           : Plugins.php
 */

namespace SLiMS;


use SLiMS\Cli\Console;
use SLiMS\SearchEngine\Engine;
use SLiMS\Session\Factory;
use stdClass;

class Plugins
{
    const DATABASE_VERSION = 'db_version';

    /**
     * Constanta's List of Hooks
     */
    const ADMIN_SESSION_AFTER_START = 'admin_session_after_start';
    const CONTENT_BEFORE_LOAD = 'before_content_load';
    const CONTENT_AFTER_LOAD = 'after_content_load';
    const BIBLIOGRAPHY_INIT = 'bibliography_init';
    const BIBLIOGRAPHY_BEFORE_UPDATE = 'bibliography_before_update';
    const BIBLIOGRAPHY_AFTER_UPDATE = 'bibliography_after_update';
    const BIBLIOGRAPHY_BEFORE_SAVE = 'bibliography_before_save';
    const BIBLIOGRAPHY_AFTER_SAVE = 'bibliography_after_save';
    const BIBLIOGRAPHY_BEFORE_DELETE = 'bibliography_before_delete';
    const BIBLIOGRAPHY_AFTER_DELETE = 'bibliography_after_delete';
    const BIBLIOGRAPHY_CUSTOM_FIELD_DATA = 'advance_custom_field_data';
    const BIBLIOGRAPHY_CUSTOM_FIELD_FORM = 'advance_custom_field_form';
    const CIRCULATION_AFTER_SUCCESSFUL_TRANSACTION = 'circulation_after_successful_transaction';
    const MEMBERSHIP_INIT = 'membership_init';
    const MEMBERSHIP_BEFORE_UPDATE = 'membership_before_update';
    const MEMBERSHIP_AFTER_UPDATE = 'membership_after_update';
    const MEMBERSHIP_BEFORE_SAVE = 'membership_before_save';
    const MEMBERSHIP_AFTER_SAVE = 'membership_after_save';
    const OVERDUE_NOTICE_INIT = 'overduenotice_init';
    const DUEDATE_NOTICE_INIT = 'duedate_init';
    const MODULE_MAIN_MENU_INIT = 'module_main_menu_init';

    private static $instance;
    /**
     * Store plugins location, so plugins can stored in multiple location
     * @var array
     */
    protected array $locations = [];

    /**
     * Plugin scanned will store here
     * @var array
     */
    protected array $plugins = [];
    protected array $active_plugins = [];
    protected array $hooks = [];
    protected array $menus = [];
    private int $deep = 2;
    private array $autoloadList = [];
    private string $hook_handler = '';
    private string $current_location = '';
    private ?string $group_name = null;

    /**
     * Plugins constructor.
     * @param null $location
     */
    public function __construct($location = null)
    {
        $this->addLocation($location);
    }

    public static function getInstance(): Plugins
    {
        if (is_null(self::$instance)) self::$instance = new static;
        return self::$instance;
    }

    /**
     * Add .plugin.php | plugin file into list
     * @param array|string $location
     * @return Plugins
     */
    public function addLocation($location): Plugins
    {
        if (is_array($location)) {
            $this->locations = array_unique(array_merge($this->locations, $location));
        } elseif (!is_null($location)) {
            $this->locations[] = $location;
        } else {
            // setup default location
            $this->locations[] = realpath(__DIR__ . '/../plugins');
        }
        return $this;
    }

    /**
     * Collection plugin information from .plugin.php
     * documentation at top of file.
     * 
     * @param string $path
     * @return stdClass
     */
    private function getPluginInfo($path): stdClass
    {
        $file_open = fopen($path, 'r');
        $raw_data = fread($file_open, 8192);
        fclose($file_open);

        // store plugin info as object
        $plugin = new stdClass;

        // parsing plugin data
        preg_match('|Plugin Name:(.*)$|mi', $raw_data, $plugin->name);
        preg_match('|Plugin URI:(.*)$|mi', $raw_data, $plugin->uri);
        preg_match('|Version:(.*)|i', $raw_data, $plugin->version);
        preg_match('|Description:(.*)$|mi', $raw_data, $plugin->description);
        preg_match('|Author:(.*)$|mi', $raw_data, $plugin->author);
        preg_match('|Author URI:(.*)$|mi', $raw_data, $plugin->author_uri);

        foreach (get_object_vars($plugin) as $key => $val) {
            $plugin->$key = isset($val[1]) && trim($val[1]) !== '' ? trim($val[1]) : null;
        }

        $plugin->id = md5($path);
        $plugin->path = $path;
        return $plugin;
    }

    /**
     * Scan plugin directory to get plugin information.
     * by default SLiMS use <slims-root>/plugin to store
     * plugin. Please read 'addLocation' method method.
     * 
     * @param string $location
     * @return void
     */
    private function getPluginsInfo($location)
    {
        // open location
        if ($dir = opendir($location)) {
            while ($file = readdir($dir)) {
                $path = $location . DS . $file;
                // if location is file
                if (is_file($path)) {
                    // just get file with suffix plugin.php
                    if (strpos($path, 'plugin.php')) {
                        $plugin = $this->getPluginInfo($path);
                        // get migration info
                        $this->plugins[$plugin->id] = $plugin;
                        $this->plugins[$plugin->id]->migration = $this->getMigrationInfo($plugin);
                    }
                } elseif (is_dir($path) && (substr($file, 0, 1) != '.')) {
                    // get plugins from sub folder location
                    // deep level directory that will be scanned
                    if ($this->isDeep($location)) $this->getPluginsInfo($path);
                }
            }
            closedir($dir);
        }
    }

    /**
     * Register migration directory in each plugin
     * if it exists. This method is use SLiMS\Migration\Migration
     * to migrate some query | schema | files etc from some plugin.
     * 
     * @param Plugins $plugin
     * @return stdClass
     */
    private function getMigrationInfo($plugin): stdClass
    {
        $migration = new stdClass;
        $migration->is_exist = false;

        $migration_directory = dirname($plugin->path) . DIRECTORY_SEPARATOR . 'migration';
        if (is_dir($migration_directory)) {
            $migration->is_exist = true;
            $migration->{self::DATABASE_VERSION} = $this->getDBVersion($plugin->id);
        }
        return $migration;
    }

    /**
     * Plugin option is an information about
     * plugin migration | database history
     * @param string $id
     */
    private function getOptions($id): void
    {
        if (isset($this->active_plugins[$id])) {
            try {
                $this->plugins[$id]->options = json_decode($this->active_plugins[$id]->options??'');
            } catch (\Exception $exception) {
                $this->plugins[$id]->options = new stdClass;
            }
        } else {
            $stmt = DB::getInstance()->prepare('SELECT options FROM plugins WHERE id = :id');
            $stmt->execute(['id' => $id]);
            if ($stmt->rowCount() < 1) $this->plugins[$id]->options = new stdClass;
            $plugin = $stmt->fetch(\PDO::FETCH_OBJ);
            try {
                $this->plugins[$id]->options = json_decode($plugin->options ?? '{}');
            } catch (\Exception $exception) {
                $this->plugins[$id]->options = new stdClass;
            }
        }
    }

    /**
     * @param string $id
     */
    private function getDBVersion($id): int
    {
        $this->getOptions($id);
        return $this->plugins[$id]->options->{self::DATABASE_VERSION} ?? 0;
    }

    /**
     * Check if path location have sub-directory
     * 
     * @param string $location
     */
    function isDeep($location): bool
    {
        $sub_dir = str_replace($this->current_location, '', $location);
        $arr_sub_dir = explode(DIRECTORY_SEPARATOR, $sub_dir);
        return count($arr_sub_dir) <= $this->deep;
    }

    /**
     * @return array
     */
    public function getPlugins(): array
    {
        foreach ($this->locations as $location) {
            $this->current_location = $location;
            $this->getPluginsInfo($location);
        }
        return $this->plugins;
    }

    /**
     * Get active plugins from database
     */
    public function getActive(): array
    {
        $query = DB::getInstance()->query("SELECT * FROM plugins WHERE deleted_at IS NULL");
        while ($data = $query->fetchObject()) $this->active_plugins[$data->id] = $data;
        return $this->active_plugins;
    }

    public function isActive($id): bool
    {
        $query = DB::getInstance()->prepare("SELECT * FROM plugins WHERE ID = :id");
        $query->bindValue(':id', $id);
        $query->execute();
        return $query->rowCount() > 0;
    }

    /**
     * load .plugin.php file from plugin
     * @return void
     */
    public function loadPlugins()
    {
        foreach ($this->getActive() as $item) {
            if (file_exists($item->path)) require_once $item->path;
        }
    }

    /**
     * A method to listing hook into list
     * 
     * @param string $hook
     * @param closure $callback
     * @return void
     */
    public function register($hook, $callback)
    {
        $this->hooks[$hook][] = [$callback, $this->hook_handler];
    }

    /**
     * A shortcut to register method
     * 
     * @param string $hook
     * @param closure $callback
     * @return void
     */
    public function registerHook($hook, $callback)
    {
        $this->register($hook, $callback);
    }

    /**
     * shortcut to 'registerHook'
     */
    public static function hook($hook, $callback)
    {
        self::getInstance()->registerHook($hook, $callback);
    }

    /**
     * A method to listing menu into SLiMS module
     * submenut.
     * 
     * @param string $module_name
     * @param string $label
     * @param string $path
     * @param string $description
     * @return void
     */
    public function registerMenu($module_name, $label, $path, $description = null)
    {
        $hash = md5(realpath($path));
        if ($module_name === 'opac') {
            $name = strtolower(implode('_', explode(' ', $label)));
            $this->menus[$module_name][$name] = [$label, SWB . 'index.php?p=' . $name, $description, realpath($path)];
        } else {
            $this->menus[$module_name][$hash] = [$label, AWB . 'plugin_container.php?mod=' . $module_name . '&id=' . $hash, $description, realpath($path)];
        }

        $group_instance = GroupMenu::getInstance()->bind($hash);
        if (!is_null($this->group_name)) $group_instance->group($this->group_name);

        return $group_instance;
    }

    /**
     * Shortcut for 'registerMenu'
     */
    public static function menu($module_name, $label, $path, $description = null)
    {
        return self::getInstance()->registerMenu($module_name, $label, $path, $description = null);
    }

    /**
     * Register SLiMS Module as Plugin
     *
     * @param string $module_name
     * @param string $path
     * @param string $description
     * @param string $callback_priv
     * @return void
     */
    public function registerModule($module_name, $path, $description = '', $callback_priv = '')
    {
        // Conver current path to md5 (prevent path transversal)
        $md5_path = md5($path);

        // Register module as hook
        Plugins::hook(Plugins::MODULE_MAIN_MENU_INIT, function(&$module_list) use($module_name, $path, $md5_path, $description, $callback_priv) {
            // set module list
            $module_list[] = ['name' => $module_name, 'plugin_module_path' => $path, 'path' => $md5_path, 'desc' => $description];

            // set session 
            if (!isset($_SESSION['priv'][$md5_path])) {
                // Custom privelges
                if (is_callable($callback_priv)) {
                    $callback_priv();
                } else {
                    $_SESSION['priv'][$md5_path] = [
                        'r' => true,
                        'w' => true,
                        'submenu' => $path . 'submenu.php'
                    ];
                }
            }
        });

        // Make default group menu
        Plugins::group($module_name, function() use($path,$md5_path) {
            // Scan all file inside module directory as menu
            foreach (array_diff(scandir($path), ['.','..','submenu.php']) as $menu) {
                if (is_dir($menu) || strpos($menu, '.inc.php')) continue;

                // set label
                $label = trim($menu, '.php');
                $label = $label === 'index' ? __('Main List') : ucwords(str_replace('_', ' ', strtolower($menu)));

                // Register module menu
                Plugins::menu($md5_path, $label, $path . DS . $menu);
            }
        });
    }

    /**
     * A shortcut for registerModule
     *
     * @param string $module_name
     * @param string $path
     * @param string $description
     * @param string $callback_priv
     * @return void
     */
    public function module($module_name, $path, $description = '', $callback_priv = '')
    {
        self::getInstance()->registerModule($module_name, $path, $description, $callback_priv);
    }

    /**
     * This method is relate to SLiMS\SearchEngine\Engine
     * 
     * @param string $class_name
     * @return void
     */
    public function registerSearchEngine($class_name)
    {
        Engine::init()->set($class_name);
    }

    /**
     * This method is relate to SLiMS\Session\Factory
     * 
     * @param string $class_name
     * @return void
     */
    public function registerSessionDriver($class_name)
    {
        Factory::getInstance()->registerDriver($class_name);
    }

    /**
     * This method is relate to SLiMS\Cli\Console
     * 
     * @param string $class_name
     * @return void
     */
    public function registerCommand($class_name)
    {
        Console::getInstance()->registerCommand($class_name);
    }

    /**
     * Seperate root composer ('slims-plugin') detector
     * and plugin base composer (vendor inside each plugin).
     * The autoload.php will be call at plugin_container.php
     */
    public function registerAutoload($directoryToAutoload)
    {
        $match = file_exists($path = $directoryToAutoload . DS . 'vendor/autoload.php') || file_exists($path = $directoryToAutoload);
        if ($match) $this->autoloadList[$directoryToAutoload] = $path;
    }

    public function getAutoload($pluginPath)
    {
        $pluginDirectory = explode(DS, str_replace(SB . 'plugins' . DS, '', $pluginPath))[0]??'';
        if (isset($this->autoloadList[SB . 'plugins' . DS . $pluginDirectory])) include_once $this->autoloadList[SB . 'plugins' . DS . $pluginDirectory];
    }

    /**
     * Grouping some plugin into submenu.
     * 
     * @param string $group_name
     * @param closure $callback
     */
    public static function group($group_name, $callback): GroupMenuOrder
    {
        self::getInstance()->setGroupName($group_name);
        $callback();
        self::getInstance()->setGroupName(null);
        return GroupMenuOrder::getInstance()->bind($group_name);
    }

    public function setGroupName($group_name)
    {
        $this->group_name = $group_name;
    }

    /**
     * Running hook process.
     * 
     * @param string $hook
     * @param array $params
     * @return void
     */
    public static function run($hook, $params = []) {
        self::getInstance()->execute($hook, $params);
    }

    public function execute($hook, $params = [])
    {
        foreach ($this->hooks[$hook] ?? [] as $hook) {
            list($callback, $handler) = $hook;
            if (is_callable($callback)) call_user_func_array($callback, array_values($params));
            if (!empty($handler) && is_string($callback) && method_exists(($handlerInstance = new $handler), $callback)) 
            {call_user_func_array([$handlerInstance, $callback], array_values($params));}
        }
    }

    /**
     * This method is part of hooking process.
     * If you have class to handle some hook, this
     * method to set up your class.
     * 
     * @param string $handler_class
     */
    public static function use($handler_class)
    {
        self::getInstance()->hook_handler = $handler_class;
        return self::getInstance();
    }

    /**
     * This method call closure to use hook
     * handler
     * 
     * @param closure $hooks
     */
    public function for($hooks)
    {
        if (empty($this->hook_handler)) return;
        if (is_callable($hooks)) call_user_func_array($hooks, [$this]);
    }

    /**
     * @param null $module
     * @return array
     */
    public function getMenus($module = null): array
    {
        if (is_null($module)) return $this->menus;
        return $this->menus[$module] ?? [];
    }
}

================================================================================
File: phpwebsocket.php
================================================================================

<?php

/*
	Based on PHP WebSocket Server 0.2
	 - http://code.google.com/p/php-websocket-server/
	 - http://code.google.com/p/php-websocket-server/wiki/Scripting

	WebSocket Protocol 07
	 - http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07
	 - Supported by Firefox 6 (30/08/2011)

	Whilst a big effort is made to follow the protocol documentation, the current script version may unknowingly differ.
	Please report any bugs you may find, all feedback and questions are welcome!
*/


class PHPWebSocket
{
	// maximum amount of clients that can be connected at one time
	const WS_MAX_CLIENTS = 100;

	// maximum amount of clients that can be connected at one time on the same IP v4 address
	const WS_MAX_CLIENTS_PER_IP = 15;

	// amount of seconds a client has to send data to the server, before a ping request is sent to the client,
	// if the client has not completed the opening handshake, the ping request is skipped and the client connection is closed
	const WS_TIMEOUT_RECV = 10;

	// amount of seconds a client has to reply to a ping request, before the client connection is closed
	const WS_TIMEOUT_PONG = 5;

	// the maximum length, in bytes, of a frame's payload data (a message consists of 1 or more frames), this is also internally limited to 2,147,479,538
	const WS_MAX_FRAME_PAYLOAD_RECV = 100000;

	// the maximum length, in bytes, of a message's payload data, this is also internally limited to 2,147,483,647
	const WS_MAX_MESSAGE_PAYLOAD_RECV = 500000;




	// internal
	const WS_FIN =  128;
	const WS_MASK = 128;

	const WS_OPCODE_CONTINUATION = 0;
	const WS_OPCODE_TEXT =         1;
	const WS_OPCODE_BINARY =       2;
	const WS_OPCODE_CLOSE =        8;
	const WS_OPCODE_PING =         9;
	const WS_OPCODE_PONG =         10;

	const WS_PAYLOAD_LENGTH_16 = 126;
	const WS_PAYLOAD_LENGTH_63 = 127;

	const WS_READY_STATE_CONNECTING = 0;
	const WS_READY_STATE_OPEN =       1;
	const WS_READY_STATE_CLOSING =    2;
	const WS_READY_STATE_CLOSED =     3;

	const WS_STATUS_NORMAL_CLOSE =             1000;
	const WS_STATUS_GONE_AWAY =                1001;
	const WS_STATUS_PROTOCOL_ERROR =           1002;
	const WS_STATUS_UNSUPPORTED_MESSAGE_TYPE = 1003;
	const WS_STATUS_MESSAGE_TOO_BIG =          1004;

	const WS_STATUS_TIMEOUT = 3000;

	// global vars
	public $wsClients       = array();
	public $wsRead          = array();
	public $wsClientCount   = 0;
	public $wsClientIPCount = array();
	public $wsOnEvents      = array();

	/*
		$this->wsClients[ integer ClientID ] = array(
			0 => resource  Socket,                            // client socket
			1 => string    MessageBuffer,                     // a blank string when there's no incoming frames
			2 => integer   ReadyState,                        // between 0 and 3
			3 => integer   LastRecvTime,                      // set to time() when the client is added
			4 => int/false PingSentTime,                      // false when the server is not waiting for a pong
			5 => int/false CloseStatus,                       // close status that wsOnClose() will be called with
			6 => integer   IPv4,                              // client's IP stored as a signed long, retrieved from ip2long()
			7 => int/false FramePayloadDataLength,            // length of a frame's payload data, reset to false when all frame data has been read (cannot reset to 0, to allow reading of mask key)
			8 => integer   FrameBytesRead,                    // amount of bytes read for a frame, reset to 0 when all frame data has been read
			9 => string    FrameBuffer,                       // joined onto end as a frame's data comes in, reset to blank string when all frame data has been read
			10 => integer  MessageOpcode,                     // stored by the first frame for fragmented messages, default value is 0
			11 => integer  MessageBufferLength                // the payload data length of MessageBuffer
		)

		$wsRead[ integer ClientID ] = resource Socket         // this one-dimensional array is used for socket_select()
															  // $wsRead[ 0 ] is the socket listening for incoming client connections

		$wsClientCount = integer ClientCount                  // amount of clients currently connected

		$wsClientIPCount[ integer IP ] = integer ClientCount  // amount of clients connected per IP v4 address
	*/

	// server state functions
	function wsStartServer($host, $port) {
		if (isset($this->wsRead[0])) return false;

		if (!$this->wsRead[0] = socket_create(AF_INET, SOCK_STREAM, SOL_TCP)) {
			return false;
		}
		if (!socket_set_option($this->wsRead[0], SOL_SOCKET, SO_REUSEADDR, 1)) {
			socket_close($this->wsRead[0]);
			return false;
		}
		if (!socket_bind($this->wsRead[0], $host, $port)) {
			socket_close($this->wsRead[0]);
			return false;
		}
		if (!socket_listen($this->wsRead[0], 10)) {
			socket_close($this->wsRead[0]);
			return false;
		}

		$write = array();
		$except = array();

		$nextPingCheck = time() + 1;
		while (isset($this->wsRead[0])) {
			$changed = $this->wsRead;
			$result = socket_select($changed, $write, $except, 1);

			if ($result === false) {
				socket_close($this->wsRead[0]);
				return false;
			}
			elseif ($result > 0) {
				foreach ($changed as $clientID => $socket) {
					if ($clientID != 0) {
						// client socket changed
						$buffer = '';
						$bytes = @socket_recv($socket, $buffer, 4096, 0);

						if ($bytes === false) {
							// error on recv, remove client socket (will check to send close frame)
							$this->wsSendClientClose($clientID, self::WS_STATUS_PROTOCOL_ERROR);
						}
						elseif ($bytes > 0) {
							// process handshake or frame(s)
							if (!$this->wsProcessClient($clientID, $buffer, $bytes)) {
								$this->wsSendClientClose($clientID, self::WS_STATUS_PROTOCOL_ERROR);
							}
						}
						else {
							// 0 bytes received from client, meaning the client closed the TCP connection
							$this->wsRemoveClient($clientID);
						}
					}
					else {
						// listen socket changed
						$client = socket_accept($this->wsRead[0]);
						if ($client !== false) {
							// fetch client IP as integer
							$clientIP = '';
							$result = socket_getpeername($client, $clientIP);
							$clientIP = ip2long($clientIP);

							if ($result !== false && $this->wsClientCount < self::WS_MAX_CLIENTS && (!isset($this->wsClientIPCount[$clientIP]) || $this->wsClientIPCount[$clientIP] < self::WS_MAX_CLIENTS_PER_IP)) {
								$this->wsAddClient($client, $clientIP);
							}
							else {
								socket_close($client);
							}
						}
					}
				}
			}

			if (time() >= $nextPingCheck) {
				$this->wsCheckIdleClients();
				$nextPingCheck = time() + 1;
			}
		}

		return true; // returned when wsStopServer() is called
	}
	function wsStopServer() {
		// check if server is not running
		if (!isset($this->wsRead[0])) return false;

		// close all client connections
		foreach ($this->wsClients as $clientID => $client) {
			// if the client's opening handshake is complete, tell the client the server is 'going away'
			if ($client[2] != self::WS_READY_STATE_CONNECTING) {
				$this->wsSendClientClose($clientID, self::WS_STATUS_GONE_AWAY);
			}
			socket_close($client[0]);
		}

		// close the socket which listens for incoming clients
		socket_close($this->wsRead[0]);

		// reset variables
		$this->wsRead          = array();
		$this->wsClients       = array();
		$this->wsClientCount   = 0;
		$this->wsClientIPCount = array();

		return true;
	}

	// client timeout functions
	function wsCheckIdleClients() {
		$time = time();
		foreach ($this->wsClients as $clientID => $client) {
			if ($client[2] != self::WS_READY_STATE_CLOSED) {
				// client ready state is not closed
				if ($client[4] !== false) {
					// ping request has already been sent to client, pending a pong reply
					if ($time >= $client[4] + self::WS_TIMEOUT_PONG) {
						// client didn't respond to the server's ping request in self::WS_TIMEOUT_PONG seconds
						$this->wsSendClientClose($clientID, self::WS_STATUS_TIMEOUT);
						$this->wsRemoveClient($clientID);
					}
				}
				elseif ($time >= $client[3] + self::WS_TIMEOUT_RECV) {
					// last data was received >= self::WS_TIMEOUT_RECV seconds ago
					if ($client[2] != self::WS_READY_STATE_CONNECTING) {
						// client ready state is open or closing
						$this->wsClients[$clientID][4] = time();
						$this->wsSendClientMessage($clientID, self::WS_OPCODE_PING, '');
					}
					else {
						// client ready state is connecting
						$this->wsRemoveClient($clientID);
					}
				}
			}
		}
	}

	// client existence functions
	function wsAddClient($socket, $clientIP) {
		// increase amount of clients connected
		$this->wsClientCount++;

		// increase amount of clients connected on this client's IP
		if (isset($this->wsClientIPCount[$clientIP])) {
			$this->wsClientIPCount[$clientIP]++;
		}
		else {
			$this->wsClientIPCount[$clientIP] = 1;
		}

		// fetch next client ID
		$clientID = $this->wsGetNextClientID();

		// store initial client data
		$this->wsClients[$clientID] = array($socket, '', self::WS_READY_STATE_CONNECTING, time(), false, 0, $clientIP, false, 0, '', 0, 0);

		// store socket - used for socket_select()
		$this->wsRead[$clientID] = $socket;
	}
	function wsRemoveClient($clientID) {
		// fetch close status (which could be false), and call wsOnClose
		$closeStatus = $this->wsClients[$clientID][5];
		if ( array_key_exists('close', $this->wsOnEvents) )
			foreach ( $this->wsOnEvents['close'] as $func )
				$func($clientID, $closeStatus);

		// close socket
		$socket = $this->wsClients[$clientID][0];
		socket_close($socket);

		// decrease amount of clients connected on this client's IP
		$clientIP = $this->wsClients[$clientID][6];
		if ($this->wsClientIPCount[$clientIP] > 1) {
			$this->wsClientIPCount[$clientIP]--;
		}
		else {
			unset($this->wsClientIPCount[$clientIP]);
		}

		// decrease amount of clients connected
		$this->wsClientCount--;

		// remove socket and client data from arrays
		unset($this->wsRead[$clientID], $this->wsClients[$clientID]);
	}

	// client data functions
	function wsGetNextClientID() {
		$i = 1; // starts at 1 because 0 is the listen socket
		while (isset($this->wsRead[$i])) $i++;
		return $i;
	}
	function wsGetClientSocket($clientID) {
		return $this->wsClients[$clientID][0];
	}

	// client read functions
	function wsProcessClient($clientID, &$buffer, $bufferLength) {
		if ($this->wsClients[$clientID][2] == self::WS_READY_STATE_OPEN) {
			// handshake completed
			$result = $this->wsBuildClientFrame($clientID, $buffer, $bufferLength);
		}
		elseif ($this->wsClients[$clientID][2] == self::WS_READY_STATE_CONNECTING) {
			// handshake not completed
			$result = $this->wsProcessClientHandshake($clientID, $buffer);
			if ($result) {
				$this->wsClients[$clientID][2] = self::WS_READY_STATE_OPEN;

				if ( array_key_exists('open', $this->wsOnEvents) )
					foreach ( $this->wsOnEvents['open'] as $func )
						$func($clientID);
			}
		}
		else {
			// ready state is set to closed
			$result = false;
		}

		return $result;
	}
	function wsBuildClientFrame($clientID, &$buffer, $bufferLength) {
		// increase number of bytes read for the frame, and join buffer onto end of the frame buffer
		$this->wsClients[$clientID][8] += $bufferLength;
		$this->wsClients[$clientID][9] .= $buffer;

		// check if the length of the frame's payload data has been fetched, if not then attempt to fetch it from the frame buffer
		if ($this->wsClients[$clientID][7] !== false || $this->wsCheckSizeClientFrame($clientID) == true) {
			// work out the header length of the frame
			$headerLength = ($this->wsClients[$clientID][7] <= 125 ? 0 : ($this->wsClients[$clientID][7] <= 65535 ? 2 : 8)) + 6;

			// check if all bytes have been received for the frame
			$frameLength = $this->wsClients[$clientID][7] + $headerLength;
			if ($this->wsClients[$clientID][8] >= $frameLength) {
				// check if too many bytes have been read for the frame (they are part of the next frame)
				$nextFrameBytesLength = $this->wsClients[$clientID][8] - $frameLength;
				if ($nextFrameBytesLength > 0) {
					$this->wsClients[$clientID][8] -= $nextFrameBytesLength;
					$nextFrameBytes = substr($this->wsClients[$clientID][9], $frameLength);
					$this->wsClients[$clientID][9] = substr($this->wsClients[$clientID][9], 0, $frameLength);
				}

				// process the frame
				$result = $this->wsProcessClientFrame($clientID);

				// check if the client wasn't removed, then reset frame data
				if (isset($this->wsClients[$clientID])) {
					$this->wsClients[$clientID][7] = false;
					$this->wsClients[$clientID][8] = 0;
					$this->wsClients[$clientID][9] = '';
				}

				// if there's no extra bytes for the next frame, or processing the frame failed, return the result of processing the frame
				if ($nextFrameBytesLength <= 0 || !$result) return $result;

				// build the next frame with the extra bytes
				return $this->wsBuildClientFrame($clientID, $nextFrameBytes, $nextFrameBytesLength);
			}
		}

		return true;
	}
	function wsCheckSizeClientFrame($clientID) {
		// check if at least 2 bytes have been stored in the frame buffer
		if ($this->wsClients[$clientID][8] > 1) {
			// fetch payload length in byte 2, max will be 127
			$payloadLength = ord(substr($this->wsClients[$clientID][9], 1, 1)) & 127;

			if ($payloadLength <= 125) {
				// actual payload length is <= 125
				$this->wsClients[$clientID][7] = $payloadLength;
			}
			elseif ($payloadLength == 126) {
				// actual payload length is <= 65,535
				if (substr($this->wsClients[$clientID][9], 3, 1) !== false) {
					// at least another 2 bytes are set
					$payloadLengthExtended = substr($this->wsClients[$clientID][9], 2, 2);
					$array = unpack('na', $payloadLengthExtended);
					$this->wsClients[$clientID][7] = $array['a'];
				}
			}
			else {
				// actual payload length is > 65,535
				if (substr($this->wsClients[$clientID][9], 9, 1) !== false) {
					// at least another 8 bytes are set
					$payloadLengthExtended = substr($this->wsClients[$clientID][9], 2, 8);

					// check if the frame's payload data length exceeds 2,147,483,647 (31 bits)
					// the maximum integer in PHP is "usually" this number. More info: http://php.net/manual/en/language.types.integer.php
					$payloadLengthExtended32_1 = substr($payloadLengthExtended, 0, 4);
					$array = unpack('Na', $payloadLengthExtended32_1);
					if ($array['a'] != 0 || ord(substr($payloadLengthExtended, 4, 1)) & 128) {
						$this->wsSendClientClose($clientID, self::WS_STATUS_MESSAGE_TOO_BIG);
						return false;
					}

					// fetch length as 32 bit unsigned integer, not as 64 bit
					$payloadLengthExtended32_2 = substr($payloadLengthExtended, 4, 4);
					$array = unpack('Na', $payloadLengthExtended32_2);

					// check if the payload data length exceeds 2,147,479,538 (2,147,483,647 - 14 - 4095)
					// 14 for header size, 4095 for last recv() next frame bytes
					if ($array['a'] > 2147479538) {
						$this->wsSendClientClose($clientID, self::WS_STATUS_MESSAGE_TOO_BIG);
						return false;
					}

					// store frame payload data length
					$this->wsClients[$clientID][7] = $array['a'];
				}
			}

			// check if the frame's payload data length has now been stored
			if ($this->wsClients[$clientID][7] !== false) {

				// check if the frame's payload data length exceeds self::WS_MAX_FRAME_PAYLOAD_RECV
				if ($this->wsClients[$clientID][7] > self::WS_MAX_FRAME_PAYLOAD_RECV) {
					$this->wsClients[$clientID][7] = false;
					$this->wsSendClientClose($clientID, self::WS_STATUS_MESSAGE_TOO_BIG);
					return false;
				}

				// check if the message's payload data length exceeds 2,147,483,647 or self::WS_MAX_MESSAGE_PAYLOAD_RECV
				// doesn't apply for control frames, where the payload data is not internally stored
				$controlFrame = (ord(substr($this->wsClients[$clientID][9], 0, 1)) & 8) == 8;
				if (!$controlFrame) {
					$newMessagePayloadLength = $this->wsClients[$clientID][11] + $this->wsClients[$clientID][7];
					if ($newMessagePayloadLength > self::WS_MAX_MESSAGE_PAYLOAD_RECV || $newMessagePayloadLength > 2147483647) {
						$this->wsSendClientClose($clientID, self::WS_STATUS_MESSAGE_TOO_BIG);
						return false;
					}
				}

				return true;
			}
		}

		return false;
	}
	function wsProcessClientFrame($clientID) {
		// store the time that data was last received from the client
		$this->wsClients[$clientID][3] = time();

		// fetch frame buffer
		$buffer = &$this->wsClients[$clientID][9];

		// check at least 6 bytes are set (first 2 bytes and 4 bytes for the mask key)
		if (substr($buffer, 5, 1) === false) return false;

		// fetch first 2 bytes of header
		$octet0 = ord(substr($buffer, 0, 1));
		$octet1 = ord(substr($buffer, 1, 1));

		$fin = $octet0 & self::WS_FIN;
		$opcode = $octet0 & 15;

		$mask = $octet1 & self::WS_MASK;
		if (!$mask) return false; // close socket, as no mask bit was sent from the client

		// fetch byte position where the mask key starts
		$seek = $this->wsClients[$clientID][7] <= 125 ? 2 : ($this->wsClients[$clientID][7] <= 65535 ? 4 : 10);

		// read mask key
		$maskKey = substr($buffer, $seek, 4);

		$array = unpack('Na', $maskKey);
		$maskKey = $array['a'];
		$maskKey = array(
			$maskKey >> 24,
			($maskKey >> 16) & 255,
			($maskKey >> 8) & 255,
			$maskKey & 255
		);
		$seek += 4;

		// decode payload data
		if (substr($buffer, $seek, 1) !== false) {
			$data = str_split(substr($buffer, $seek));
			foreach ($data as $key => $byte) {
				$data[$key] = chr(ord($byte) ^ ($maskKey[$key % 4]));
			}
			$data = implode('', $data);
		}
		else {
			$data = '';
		}

		// check if this is not a continuation frame and if there is already data in the message buffer
		if ($opcode != self::WS_OPCODE_CONTINUATION && $this->wsClients[$clientID][11] > 0) {
			// clear the message buffer
			$this->wsClients[$clientID][11] = 0;
			$this->wsClients[$clientID][1] = '';
		}

		// check if the frame is marked as the final frame in the message
		if ($fin == self::WS_FIN) {
			// check if this is the first frame in the message
			if ($opcode != self::WS_OPCODE_CONTINUATION) {
				// process the message
				return $this->wsProcessClientMessage($clientID, $opcode, $data, $this->wsClients[$clientID][7]);
			}
			else {
				// increase message payload data length
				$this->wsClients[$clientID][11] += $this->wsClients[$clientID][7];

				// push frame payload data onto message buffer
				$this->wsClients[$clientID][1] .= $data;

				// process the message
				$result = $this->wsProcessClientMessage($clientID, $this->wsClients[$clientID][10], $this->wsClients[$clientID][1], $this->wsClients[$clientID][11]);

				// check if the client wasn't removed, then reset message buffer and message opcode
				if (isset($this->wsClients[$clientID])) {
					$this->wsClients[$clientID][1] = '';
					$this->wsClients[$clientID][10] = 0;
					$this->wsClients[$clientID][11] = 0;
				}

				return $result;
			}
		}
		else {
			// check if the frame is a control frame, control frames cannot be fragmented
			if ($opcode & 8) return false;

			// increase message payload data length
			$this->wsClients[$clientID][11] += $this->wsClients[$clientID][7];

			// push frame payload data onto message buffer
			$this->wsClients[$clientID][1] .= $data;

			// if this is the first frame in the message, store the opcode
			if ($opcode != self::WS_OPCODE_CONTINUATION) {
				$this->wsClients[$clientID][10] = $opcode;
			}
		}

		return true;
	}
	function wsProcessClientMessage($clientID, $opcode, &$data, $dataLength) {
		// check opcodes
		if ($opcode == self::WS_OPCODE_PING) {
			// received ping message
			return $this->wsSendClientMessage($clientID, self::WS_OPCODE_PONG, $data);
		}
		elseif ($opcode == self::WS_OPCODE_PONG) {
			// received pong message (it's valid if the server did not send a ping request for this pong message)
			if ($this->wsClients[$clientID][4] !== false) {
				$this->wsClients[$clientID][4] = false;
			}
		}
		elseif ($opcode == self::WS_OPCODE_CLOSE) {
			// received close message
			if (substr($data, 1, 1) !== false) {
				$array = unpack('na', substr($data, 0, 2));
				$status = $array['a'];
			}
			else {
				$status = false;
			}

			if ($this->wsClients[$clientID][2] == self::WS_READY_STATE_CLOSING) {
				// the server already sent a close frame to the client, this is the client's close frame reply
				// (no need to send another close frame to the client)
				$this->wsClients[$clientID][2] = self::WS_READY_STATE_CLOSED;
			}
			else {
				// the server has not already sent a close frame to the client, send one now
				$this->wsSendClientClose($clientID, self::WS_STATUS_NORMAL_CLOSE);
			}

			$this->wsRemoveClient($clientID);
		}
		elseif ($opcode == self::WS_OPCODE_TEXT || $opcode == self::WS_OPCODE_BINARY) {
			if ( array_key_exists('message', $this->wsOnEvents) )
				foreach ( $this->wsOnEvents['message'] as $func )
					$func($clientID, $data, $dataLength, $opcode == self::WS_OPCODE_BINARY);
		}
		else {
			// unknown opcode
			return false;
		}

		return true;
	}
	function wsProcessClientHandshake($clientID, &$buffer) {
		// fetch headers and request line
		$sep = strpos($buffer, "\r\n\r\n");
		if (!$sep) return false;

		$headers = explode("\r\n", substr($buffer, 0, $sep));
		$headersCount = sizeof($headers); // includes request line
		if ($headersCount < 1) return false;

		// fetch request and check it has at least 3 parts (space tokens)
		$request = &$headers[0];
		$requestParts = explode(' ', $request);
		$requestPartsSize = sizeof($requestParts);
		if ($requestPartsSize < 3) return false;

		// check request method is GET
		if (strtoupper($requestParts[0]) != 'GET') return false;

		// check request HTTP version is at least 1.1
		$httpPart = &$requestParts[$requestPartsSize - 1];
		$httpParts = explode('/', $httpPart);
		if (!isset($httpParts[1]) || (float) $httpParts[1] < 1.1) return false;

		// store headers into a keyed array: array[headerKey] = headerValue
		$headersKeyed = array();
		for ($i=1; $i<$headersCount; $i++) {
			$parts = explode(':', $headers[$i]);
			if (!isset($parts[1])) return false;

			$headersKeyed[trim($parts[0])] = trim($parts[1]);
		}

		// check Host header was received
		if (!isset($headersKeyed['Host'])) return false;

		// check Sec-WebSocket-Key header was received and decoded value length is 16
		if (!isset($headersKeyed['Sec-WebSocket-Key'])) return false;
		$key = $headersKeyed['Sec-WebSocket-Key'];
		if (strlen(base64_decode($key)) != 16) return false;

		// check Sec-WebSocket-Version header was received and value is 7
		if (!isset($headersKeyed['Sec-WebSocket-Version']) || (int) $headersKeyed['Sec-WebSocket-Version'] < 7) return false; // should really be != 7, but Firefox 7 beta users send 8

		// work out hash to use in Sec-WebSocket-Accept reply header
		$hash = base64_encode(sha1($key.'258EAFA5-E914-47DA-95CA-C5AB0DC85B11', true));

		// build headers
		$headers = array(
			'HTTP/1.1 101 Switching Protocols',
			'Upgrade: websocket',
			'Connection: Upgrade',
			'Sec-WebSocket-Accept: '.$hash
		);
		$headers = implode("\r\n", $headers)."\r\n\r\n";

		// send headers back to client
		$socket = $this->wsClients[$clientID][0];

		$left = strlen($headers);
		do {
			$sent = @socket_send($socket, $headers, $left, 0);
			if ($sent === false) return false;

			$left -= $sent;
			if ($sent > 0) $headers = substr($headers, $sent);
		}
		while ($left > 0);

		return true;
	}

	// client write functions
	function wsSendClientMessage($clientID, $opcode, $message) {
		// check if client ready state is already closing or closed
		if ($this->wsClients[$clientID][2] == self::WS_READY_STATE_CLOSING || $this->wsClients[$clientID][2] == self::WS_READY_STATE_CLOSED) return true;

		// fetch message length
		$messageLength = strlen($message);

		// set max payload length per frame
		$bufferSize = 4096;

		// work out amount of frames to send, based on $bufferSize
		$frameCount = ceil($messageLength / $bufferSize);
		if ($frameCount == 0) $frameCount = 1;

		// set last frame variables
		$maxFrame = $frameCount - 1;
		$lastFrameBufferLength = ($messageLength % $bufferSize) != 0 ? ($messageLength % $bufferSize) : ($messageLength != 0 ? $bufferSize : 0);

		// loop around all frames to send
		for ($i=0; $i<$frameCount; $i++) {
			// fetch fin, opcode and buffer length for frame
			$fin = $i != $maxFrame ? 0 : self::WS_FIN;
			$opcode = $i != 0 ? self::WS_OPCODE_CONTINUATION : $opcode;

			$bufferLength = $i != $maxFrame ? $bufferSize : $lastFrameBufferLength;

			// set payload length variables for frame
			if ($bufferLength <= 125) {
				$payloadLength = $bufferLength;
				$payloadLengthExtended = '';
				$payloadLengthExtendedLength = 0;
			}
			elseif ($bufferLength <= 65535) {
				$payloadLength = self::WS_PAYLOAD_LENGTH_16;
				$payloadLengthExtended = pack('n', $bufferLength);
				$payloadLengthExtendedLength = 2;
			}
			else {
				$payloadLength = self::WS_PAYLOAD_LENGTH_63;
				$payloadLengthExtended = pack('xxxxN', $bufferLength); // pack 32 bit int, should really be 64 bit int
				$payloadLengthExtendedLength = 8;
			}

			// set frame bytes
			$buffer = pack('n', (($fin | $opcode) << 8) | $payloadLength) . $payloadLengthExtended . substr($message, $i*$bufferSize, $bufferLength);

			// send frame
			$socket = $this->wsClients[$clientID][0];

			$left = 2 + $payloadLengthExtendedLength + $bufferLength;
			do {
				$sent = @socket_send($socket, $buffer, $left, 0);
				if ($sent === false) return false;

				$left -= $sent;
				if ($sent > 0) $buffer = substr($buffer, $sent);
			}
			while ($left > 0);
		}

		return true;
	}
	function wsSendClientClose($clientID, $status=false) {
		// check if client ready state is already closing or closed
		if ($this->wsClients[$clientID][2] == self::WS_READY_STATE_CLOSING || $this->wsClients[$clientID][2] == self::WS_READY_STATE_CLOSED) return true;

		// store close status
		$this->wsClients[$clientID][5] = $status;

		// send close frame to client
		$status = $status !== false ? pack('n', $status) : '';
		$this->wsSendClientMessage($clientID, self::WS_OPCODE_CLOSE, $status);

		// set client ready state to closing
		$this->wsClients[$clientID][2] = self::WS_READY_STATE_CLOSING;
	}

	// client non-internal functions
	function wsClose($clientID) {
		return $this->wsSendClientClose($clientID, self::WS_STATUS_NORMAL_CLOSE);
	}
	function wsSend($clientID, $message, $binary=false) {
		return $this->wsSendClientMessage($clientID, $binary ? self::WS_OPCODE_BINARY : self::WS_OPCODE_TEXT, $message);
	}

	function log( $message )
	{
		echo date('Y-m-d H:i:s: ') . $message . "\n";
	}

	function bind( $type, $func )
	{
		if ( !isset($this->wsOnEvents[$type]) )
			$this->wsOnEvents[$type] = array();
		$this->wsOnEvents[$type][] = $func;
	}

	function unbind( $type='' )
	{
		if ( $type ) unset($this->wsOnEvents[$type]);
		else $this->wsOnEvents = array();
	}
}
?>
================================================================================
File: router.inc.php
================================================================================

<?php

/**
 * @author              : Waris Agung Widodo
 * @Date                : 2017-07-04 15:27:14
 * @Last Modified by    : ido
 * @Last Modified time  : 2017-07-05 15:19:06
 *
 * Copyright (C) 2017  Waris Agung Widodo (ido.alit@gmail.com)
 */

require 'AltoRouter.php';

class Router extends AltoRouter
{

    private $sysconf;
    private $db;
    
    function __construct($sysconf, $obj_db)
    {
        parent::__construct();
        $this->sysconf = $sysconf;
        $this->db = $obj_db;
    }

    public function match($requestUrl = null, $requestMethod = null)
    {
        $params = array();
        $match = false;

        // set Request Url if it isn't passed as parameter
        if($requestUrl === null) {
            $path = explode('/', $_GET['p']);
            if ($path[0] == $this->basePath) {
                $requestUrl = $_GET['p'];
            } else {
                $requestUrl = '/';
            }
        }

        // strip base path from request url
        $requestUrl = substr($requestUrl, strlen($this->basePath));

        // Strip query string (?a=b) from Request Url
        if (($strpos = strpos($requestUrl, '?')) !== false) {
            $requestUrl = substr($requestUrl, 0, $strpos);
        }

        // set Request Method if it isn't passed as a parameter
        if($requestMethod === null) {
            $requestMethod = isset($_SERVER['REQUEST_METHOD']) ? $_SERVER['REQUEST_METHOD'] : 'GET';
        }

        foreach($this->routes as $handler) {
            list($methods, $route, $target, $name) = $handler;

            $method_match = (stripos($methods, $requestMethod) !== false);

            // Method did not match, continue to next route.
            if (!$method_match) continue;

            if ($route === '*') {
                // * wildcard (matches all)
                $match = true;
            } elseif (isset($route[0]) && $route[0] === '@') {
                // @ regex delimiter
                $pattern = '`' . substr($route, 1) . '`u';
                $match = preg_match($pattern, $requestUrl, $params) === 1;
            } elseif (($position = strpos($route, '[')) === false) {
                // No params in url, do string comparison
                $match = strcmp($requestUrl, $route) === 0;
            } else {
                // Compare longest non-param string with url
                if (strncmp($requestUrl, $route, $position) !== 0) {
                    continue;
                }
                $regex = $this->compileRoute($route);
                $match = preg_match($regex, $requestUrl, $params) === 1;
            }

            if ($match) {

                if ($params) {
                    foreach($params as $key => $value) {
                        if(is_numeric($key)) unset($params[$key]);
                    }
                }

                return array(
                    'target' => $target,
                    'params' => $params,
                    'name' => $name
                );
            }
        }
        return false;
    }

    public function makeCallable($string)
    {
        $method = explode('@', $string);
        if (isset($method[1]) && class_exists($method[0])) {
            $instance = new $method[0]($this->sysconf, $this->db);
            if (method_exists($instance, $method[1])) {
                return array($instance, $method[1]);
            }
        }
        return false;
    }

    public function run()
    {
        // match current request url
        $match = $this->match();
        // call closure or throw 404 status
        if( $match && is_callable( $match['target'] ) ) {
            call_user_func_array( $match['target'], $match['params'] ); 
        } else {
            if ($callable = $this->makeCallable($match['target']??'')) {
                call_user_func_array($callable, $match['params']);
            } else {
                // no route was matched
                // header( $_SERVER["SERVER_PROTOCOL"] . ' 404 Not Found');
                // include $this->sysconf['template']['dir'].'/'.$this->sysconf['template']['theme'].'/404.php';
                // header ("location:index.php");
                http_response_code(404);
                throw new Exception("Not found!");
            }
        }
    }
}
================================================================================
File: Sanitizer.php
================================================================================

<?php
/**
 * @author Drajat Hasan
 * @email drajathasan20@gmail.com
 * @create date 2023-03-01 20:22:50
 * @modify date 2023-04-14 07:22:00
 * @license GPLv3
 * @desc [description]
 */

namespace SLiMS;

use Utility;

class Sanitizer 
{
    private $variableToClean = [];
    
    public static function fromGlobal(array $variableToClean = []): self
    {
        return new self($variableToClean);
    }

    public function __construct(array $variableToClean = [])
    {
        $this->variableToClean = $variableToClean;
    }

    private function setNewValue(string $type, string $key, $value)
    {
        switch ($type) {
            case 'get':
                $_GET[$key] = $value;
                break;

            case 'post':
                $_POST[$key] = $value;
                break;
            
            case 'server':
                $_SERVER[$key] = $value;
                break;

            case 'cookie':
                $_COOKIE[$key] = $value;
                break;

            case 'session':
                $_SESSION[$key] = $value;
                break;
        }
    }

    public function quoteFree(array $exception = [])
    {
        foreach ($this->variableToClean as $type => $globalVariable) {
            foreach ($globalVariable as $key => $value) {
                if (in_array($key, $exception)) continue;
                if (is_array($value)) continue;
                $this->setNewValue($type, $key, str_replace(['\'','"','`'],'',$value));
            }
        }
    }

    public function cleanUp(array $exception = [], array $filter = [true, true, true] /* escape_sql, trim, strip_tag */): void
    {
        foreach ($this->variableToClean as $type => $globalVariable) {
            foreach ($globalVariable as $key => $value) {
                if (in_array($key, $exception)) continue;
                if (is_array($value)) continue;
                $this->setNewValue($type, $key, utility::filterData($key, $type, ...$filter));
            }
        }
    }
}
================================================================================
File: utility.inc.php
================================================================================

<?php
/**
 * utility class
 * A Collection of static utility methods
 *
 * Copyright (C) 2007,2008  Arie Nugraha (dicarve@yahoo.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// be sure that this file not accessed directly
if (!defined('INDEX_AUTH')) {
    die("can not access this file directly");
} elseif (INDEX_AUTH != 1) {
    die("can not access this file directly");
}

class utility
{
    /**
     * Static Method to send out javascript alert
     *
     * @param   string  $str_message
     * @return  void
     */
    public static function jsAlert($str_message)
    {
        if (!$str_message) {
            return;
        }

        // replace newline with javascripts newline
        $str_message = str_replace("\n", '\n', addslashes($str_message));
        echo '<script type="text/javascript">'."\n";
        echo 'alert("'.$str_message.'")'."\n";
        echo '</script>'."\n";
    }

  /**
   * Static Method to send out toastr notification
   *
   * @param   string $type [info, success, warning, error]
   * @param   string $str_message
   * @return  void
   */
    public static function jsToastr($title, $str_message, $type = 'info')
    {
      if (!$str_message) {
        return;
      }

      $options = [
        'closeButton' => true,
        'debug' => false,
        'newestOnTop' => false,
        'progressBar' => false,
        'positionClass' => 'toast-top-right',
        'preventDuplicates' => false,
        'onclick' => null,
        'showDuration' => 300,
        'hideDuration' => 1000,
        'timeOut' => 5000,
        'extendedTimeOut' => 1000,
        'showEasing' => 'swing',
        'hideEasing' => 'linear',
        'showMethod' => 'fadeIn',
        'hideMethod' => 'fadeOut'
      ];

      // replace newline with javascripts newline
      $str_message = str_replace("\n", '\n', addslashes($str_message));
      echo '<script type="text/javascript">'."\n";
      echo 'top.toastr.'.$type.'("'.$str_message.'", "'.$title.'", '.json_encode($options).')'."\n";
      echo '</script>'."\n";
    }


    /**
     * Static Method to create random string
     *
     * @param   int     $int_num_string: number of randowm string to created
     * @return  void
     */
    public static function createRandomString($int_num_string = 32)
    {
      $_random = '';
      $_salt = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
      $_saltlength = strlen($_salt);
      for ($r = 0; $r < $int_num_string; $r++) {
        $_random .= $_salt[rand(0, $_saltlength - 1)];
      }

      return $_random;
    }


    /**
     * Static Method to load application settings from database
     *
     * @param   object  $obj_db
     * @return  void
     */
    public static function loadSettings($obj_db)
    {
        global $sysconf;
        $_setting_query = $obj_db->query('SELECT * FROM setting');
        if (!$obj_db->errno) {
            while ($_setting_data = $_setting_query->fetch_assoc()) {
                $_value = @unserialize($_setting_data['setting_value']);
                if (is_array($_value)) {
                    // make sure setting is available before
                    if (!isset($sysconf[$_setting_data['setting_name']]))
                        $sysconf[$_setting_data['setting_name']] = [];

                    foreach ($_value as $_idx => $_curr_value) {
                        // convert default setting value into array
                        if (!is_array($sysconf[$_setting_data['setting_name']]))
                            $sysconf[$_setting_data['setting_name']] = [$sysconf[$_setting_data['setting_name']]];
                        $sysconf[$_setting_data['setting_name']][$_idx] = $_curr_value;
                    }
                } else {
                    $sysconf[$_setting_data['setting_name']] = stripcslashes($_value??'');
                }
            }
        }
    }


    /**
     * Static Method to check privileges of application module form current user
     *
     * @param   string  $str_module_name
     * @param   string  $str_privilege_type
     * @return  boolean
     */
    public static function havePrivilege($str_module_name, $str_privilege_type = 'r')
    {
        global $sysconf;
        // checking checksum
        if ($sysconf['load_balanced_env']) {
            $server_addr = ip();
        } else {
            $server_addr = isset($_SERVER['SERVER_ADDR']) ? $_SERVER['SERVER_ADDR'] : (isset($_SERVER['LOCAL_ADDR']) ? $_SERVER['LOCAL_ADDR'] : gethostbyname($_SERVER['SERVER_NAME']));
        }


        $_checksum = defined('UCS_BASE_DIR')?md5($server_addr.UCS_BASE_DIR.'admin'):md5($server_addr.SB.'admin');
        if (!isset($_SESSION['checksum']) || $_SESSION['checksum'] != $_checksum) {
            return false;
        }
        // check privilege type
        if (!in_array($str_privilege_type, array('r', 'w'))) {
            return false;
        }
        if (isset($_SESSION['priv'][$str_module_name][$str_privilege_type]) AND $_SESSION['priv'][$str_module_name][$str_privilege_type]) {
            return true;
        }
        return false;
    }


    /**
     * Static Method to write application activities logs
     *
     * @param   object  $obj_db
     * @param   string  $str_log_type
     * @param   string  $str_value_id
     * @param   string  $str_location
     * @param   string  $str_log_msg
     * @return  void
     */
    public static function writeLogs($obj_db, $str_log_type, $str_value_id, $str_location, $str_log_msg, $str_log_submod='', $str_log_action='')
    {
        if (!$obj_db->error) {
            // log table
            $_log_date = date('Y-m-d H:i:s');
            $_log_table = 'system_log';
            // filter input
            $str_log_type = $obj_db->escape_string(trim($str_log_type));
            $str_value_id = $obj_db->escape_string(trim($str_value_id));
            $str_location = $obj_db->escape_string(trim($str_location));
            $str_log_msg = $obj_db->escape_string(trim($str_log_msg));
            $str_log_submod = $obj_db->escape_string(trim($str_log_submod));
            $str_log_action = $obj_db->escape_string(trim($str_log_action));
            // insert log data to database
            @$obj_db->query('INSERT INTO '.$_log_table.'
            VALUES (NULL, \''.$str_log_type.'\', \''.$str_value_id.'\', \''.$str_location.'\','.
             ' \''.$str_log_submod.'\''.
             ', \''.$str_log_action.'\''.
             ', \''.$str_log_msg.'\', \''.$_log_date.'\')');
        }
    }


    /**
     * Static Method to get an ID of database table record
     *
     * @param   object  $obj_db
     * @param   string  $str_table_name
     * @param   string  $str_id_field
     * @param   string  $str_value_field
     * @param   string  $str_value
     * @param   array   $arr_cache
     * @return  mixed
     */
    public static function getID($obj_db, $str_table_name, $str_id_field, $str_value_field, $str_value, &$arr_cache = false)
    {
        $str_value = trim($str_value);
        if ($arr_cache) {
            if (isset($arr_cache[$str_value])) {
                return $arr_cache[$str_value];
            }
        }
        if (!$obj_db->error) {
            $id_q = $obj_db->query('SELECT '.$str_id_field.' FROM '.$str_table_name.' WHERE '.$str_value_field.'=\''.$obj_db->escape_string($str_value).'\'');
            if ($id_q->num_rows > 0) {
                $id_d = $id_q->fetch_row();
                unset($id_q);
                // cache
                if ($arr_cache) {
                    $arr_cache[$str_value] = $id_d[0];
                }
                return $id_d[0];
            } else {
                $_curr_date = date('Y-m-d');
                // if not found then we insert it as new value
                $obj_db->query('INSERT IGNORE INTO '.$str_table_name.' ('.$str_value_field.', input_date, last_update)
                    VALUES (\''.$obj_db->escape_string($str_value).'\', \''.$_curr_date.'\', \''.$_curr_date.'\')');
                if (!$obj_db->error) {
                    // cache
                    if ($arr_cache) {
                        $arr_cache[$str_value] = $obj_db->insert_id;
                    }
                    return $obj_db->insert_id;
                }
            }
        }
    }


    /**
     * Static method to detect mobile browser
     *
     * @return  boolean
     * this script is taken from http://detectmobilebrowsers.com/
     **/
    public static function isMobileBrowser()
    {
        $_is_mobile_browser = false;

        if(preg_match('/android.+mobile|avantgo|bada\/|blackberry|
            blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|
            iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|
            palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|symbian|
            treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|
            xda|xiino/i',
        @$_SERVER['HTTP_USER_AGENT'] ?? '')
        || preg_match('/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|
            a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|
            amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|
            au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|
            br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|
            cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|
            do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|
            ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|
            go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|
            hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|
            i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|
            ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |
            kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|e\-|e\/|\-[a-w])|
            libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|
            me(di|rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|
            t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|
            n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|
            nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|
            pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|
            psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|
            raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|
            sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|
            sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|
            so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|
            ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|
            ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|
            vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|
            vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|
            wi(g |nc|nw)|wmlb|wonu|x700|xda(\-|2|g)|yas\-|your|zeto|zte\-/i',
        substr(@$_SERVER['HTTP_USER_AGENT'] ?? '',0,4)))
            $_is_mobile_browser = true;

        return $_is_mobile_browser;
    }


    /**
     * Static method to check if member already logged in or not
     *
     * @return  boolean
     **/
    public static function isMemberLogin()
    {
        $_logged_in = false;
        $_logged_in = isset($_SESSION['mid']) && isset($_SESSION['m_name']);
        return $_logged_in;
    }


    /**
     * Static method to filter data
     *
     * @param   mixed   $mix_input: input data
     * @param   string  $str_input_type: input type
     * @param   boolean $bool_trim: are input string trimmed
     *
     * @return  mixed
     **/
    public static function filterData($mix_input, $str_input_type = 'get', $bool_escape_sql = true, $bool_trim = true, $bool_strip_html = false) {
        global $dbs;

        if (extension_loaded('filter')) {
            if ($str_input_type == 'var') {
                $mix_input = filter_var($mix_input, FILTER_SANITIZE_STRING);
            } else if ($str_input_type == 'post') {
                $mix_input = filter_input(INPUT_POST, $mix_input);
            } else if ($str_input_type == 'cookie') {
                $mix_input = filter_input(INPUT_COOKIE, $mix_input);
            } else if ($str_input_type == 'session') {
                $mix_input = filter_input(INPUT_SESSION, $mix_input);
            } else if ($str_input_type == 'server') {
                $mix_input = $_SERVER[$mix_input]??null;
            } else {
                $mix_input = filter_input(INPUT_GET, $mix_input);
            }
        } else {
            if ($str_input_type == 'get') {
                $mix_input = $_GET[$mix_input]??null;
            } else if ($str_input_type == 'post') {
                $mix_input = $_POST[$mix_input]??null;
            } else if ($str_input_type == 'cookie') {
                $mix_input = $_COOKIE[$mix_input]??null;
            } else if ($str_input_type == 'session') {
                $mix_input = $_SESSION[$mix_input]??null;
            } else if ($str_input_type == 'server') {
                $mix_input = $_SERVER[$mix_input]??null;
            } 
        }

        if (!is_null($mix_input)) {
            // trim whitespace on string
            if ($bool_trim) { $mix_input = trim($mix_input); }
            // strip html
            if ($bool_strip_html) { $mix_input = strip_tags($mix_input); }
            // escape SQL string
            if ($bool_escape_sql) { $mix_input = $dbs->escape_string($mix_input); }
        }

        return $mix_input;
    }


    /**
     * Static method to convert XML entities
     * Code taken and modified from:
     * Matt Robinson at http://inanimatt.com/php-convert-entities.html
     *
     * @param   string  $str_xml_data: string of xml data to check
     *
     * @return  string
     **/
    public static function convertXMLentities($str_xml_data) {
      static $_ent_table = array('quot' => '&#34;',
        'amp' => '&#38;',
        'lt' => '&#60;',
        'gt' => '&#62;',
        'OElig' => '&#338;',
        'oelig' => '&#339;',
        'Scaron' => '&#352;',
        'scaron' => '&#353;',
        'Yuml' => '&#376;',
        'circ' => '&#710;',
        'tilde' => '&#732;',
        'ensp' => '&#8194;',
        'emsp' => '&#8195;',
        'thinsp' => '&#8201;',
        'zwnj' => '&#8204;',
        'zwj' => '&#8205;',
        'lrm' => '&#8206;',
        'rlm' => '&#8207;',
        'ndash' => '&#8211;',
        'mdash' => '&#8212;',
        'lsquo' => '&#8216;',
        'rsquo' => '&#8217;',
        'sbquo' => '&#8218;',
        'ldquo' => '&#8220;',
        'rdquo' => '&#8221;',
        'bdquo' => '&#8222;',
        'dagger' => '&#8224;',
        'Dagger' => '&#8225;',
        'permil' => '&#8240;',
        'lsaquo' => '&#8249;',
        'rsaquo' => '&#8250;',
        'euro' => '&#8364;',
        'fnof' => '&#402;',
        'Alpha' => '&#913;',
        'Beta' => '&#914;',
        'Gamma' => '&#915;',
        'Delta' => '&#916;',
        'Epsilon' => '&#917;',
        'Zeta' => '&#918;',
        'Eta' => '&#919;',
        'Theta' => '&#920;',
        'Iota' => '&#921;',
        'Kappa' => '&#922;',
        'Lambda' => '&#923;',
        'Mu' => '&#924;',
        'Nu' => '&#925;',
        'Xi' => '&#926;',
        'Omicron' => '&#927;',
        'Pi' => '&#928;',
        'Rho' => '&#929;',
        'Sigma' => '&#931;',
        'Tau' => '&#932;',
        'Upsilon' => '&#933;',
        'Phi' => '&#934;',
        'Chi' => '&#935;',
        'Psi' => '&#936;',
        'Omega' => '&#937;',
        'alpha' => '&#945;',
        'beta' => '&#946;',
        'gamma' => '&#947;',
        'delta' => '&#948;',
        'epsilon' => '&#949;',
        'zeta' => '&#950;',
        'eta' => '&#951;',
        'theta' => '&#952;',
        'iota' => '&#953;',
        'kappa' => '&#954;',
        'lambda' => '&#955;',
        'mu' => '&#956;',
        'nu' => '&#957;',
        'xi' => '&#958;',
        'omicron' => '&#959;',
        'pi' => '&#960;',
        'rho' => '&#961;',
        'sigmaf' => '&#962;',
        'sigma' => '&#963;',
        'tau' => '&#964;',
        'upsilon' => '&#965;',
        'phi' => '&#966;',
        'chi' => '&#967;',
        'psi' => '&#968;',
        'omega' => '&#969;',
        'thetasym' => '&#977;',
        'upsih' => '&#978;',
        'piv' => '&#982;',
        'bull' => '&#8226;',
        'hellip' => '&#8230;',
        'prime' => '&#8242;',
        'Prime' => '&#8243;',
        'oline' => '&#8254;',
        'frasl' => '&#8260;',
        'weierp' => '&#8472;',
        'image' => '&#8465;',
        'real' => '&#8476;',
        'trade' => '&#8482;',
        'alefsym' => '&#8501;',
        'larr' => '&#8592;',
        'uarr' => '&#8593;',
        'rarr' => '&#8594;',
        'darr' => '&#8595;',
        'harr' => '&#8596;',
        'crarr' => '&#8629;',
        'lArr' => '&#8656;',
        'uArr' => '&#8657;',
        'rArr' => '&#8658;',
        'dArr' => '&#8659;',
        'hArr' => '&#8660;',
        'forall' => '&#8704;',
        'part' => '&#8706;',
        'exist' => '&#8707;',
        'empty' => '&#8709;',
        'nabla' => '&#8711;',
        'isin' => '&#8712;',
        'notin' => '&#8713;',
        'ni' => '&#8715;',
        'prod' => '&#8719;',
        'sum' => '&#8721;',
        'minus' => '&#8722;',
        'lowast' => '&#8727;',
        'radic' => '&#8730;',
        'prop' => '&#8733;',
        'infin' => '&#8734;',
        'ang' => '&#8736;',
        'and' => '&#8743;',
        'or' => '&#8744;',
        'cap' => '&#8745;',
        'cup' => '&#8746;',
        'int' => '&#8747;',
        'there4' => '&#8756;',
        'sim' => '&#8764;',
        'cong' => '&#8773;',
        'asymp' => '&#8776;',
        'ne' => '&#8800;',
        'equiv' => '&#8801;',
        'le' => '&#8804;',
        'ge' => '&#8805;',
        'sub' => '&#8834;',
        'sup' => '&#8835;',
        'nsub' => '&#8836;',
        'sube' => '&#8838;',
        'supe' => '&#8839;',
        'oplus' => '&#8853;',
        'otimes' => '&#8855;',
        'perp' => '&#8869;',
        'sdot' => '&#8901;',
        'lceil' => '&#8968;',
        'rceil' => '&#8969;',
        'lfloor' => '&#8970;',
        'rfloor' => '&#8971;',
        'lang' => '&#9001;',
        'rang' => '&#9002;',
        'loz' => '&#9674;',
        'spades' => '&#9824;',
        'clubs' => '&#9827;',
        'hearts' => '&#9829;',
        'diams' => '&#9830;',
        'nbsp' => '&#160;',
        'iexcl' => '&#161;',
        'cent' => '&#162;',
        'pound' => '&#163;',
        'curren' => '&#164;',
        'yen' => '&#165;',
        'brvbar' => '&#166;',
        'sect' => '&#167;',
        'uml' => '&#168;',
        'copy' => '&#169;',
        'ordf' => '&#170;',
        'laquo' => '&#171;',
        'not' => '&#172;',
        'shy' => '&#173;',
        'reg' => '&#174;',
        'macr' => '&#175;',
        'deg' => '&#176;',
        'plusmn' => '&#177;',
        'sup2' => '&#178;',
        'sup3' => '&#179;',
        'acute' => '&#180;',
        'micro' => '&#181;',
        'para' => '&#182;',
        'middot' => '&#183;',
        'cedil' => '&#184;',
        'sup1' => '&#185;',
        'ordm' => '&#186;',
        'raquo' => '&#187;',
        'frac14' => '&#188;',
        'frac12' => '&#189;',
        'frac34' => '&#190;',
        'iquest' => '&#191;',
        'Agrave' => '&#192;',
        'Aacute' => '&#193;',
        'Acirc' => '&#194;',
        'Atilde' => '&#195;',
        'Auml' => '&#196;',
        'Aring' => '&#197;',
        'AElig' => '&#198;',
        'Ccedil' => '&#199;',
        'Egrave' => '&#200;',
        'Eacute' => '&#201;',
        'Ecirc' => '&#202;',
        'Euml' => '&#203;',
        'Igrave' => '&#204;',
        'Iacute' => '&#205;',
        'Icirc' => '&#206;',
        'Iuml' => '&#207;',
        'ETH' => '&#208;',
        'Ntilde' => '&#209;',
        'Ograve' => '&#210;',
        'Oacute' => '&#211;',
        'Ocirc' => '&#212;',
        'Otilde' => '&#213;',
        'Ouml' => '&#214;',
        'times' => '&#215;',
        'Oslash' => '&#216;',
        'Ugrave' => '&#217;',
        'Uacute' => '&#218;',
        'Ucirc' => '&#219;',
        'Uuml' => '&#220;',
        'Yacute' => '&#221;',
        'THORN' => '&#222;',
        'szlig' => '&#223;',
        'agrave' => '&#224;',
        'aacute' => '&#225;',
        'acirc' => '&#226;',
        'atilde' => '&#227;',
        'auml' => '&#228;',
        'aring' => '&#229;',
        'aelig' => '&#230;',
        'ccedil' => '&#231;',
        'egrave' => '&#232;',
        'eacute' => '&#233;',
        'ecirc' => '&#234;',
        'euml' => '&#235;',
        'igrave' => '&#236;',
        'iacute' => '&#237;',
        'icirc' => '&#238;',
        'iuml' => '&#239;',
        'eth' => '&#240;',
        'ntilde' => '&#241;',
        'ograve' => '&#242;',
        'oacute' => '&#243;',
        'ocirc' => '&#244;',
        'otilde' => '&#245;',
        'ouml' => '&#246;',
        'divide' => '&#247;',
        'oslash' => '&#248;',
        'ugrave' => '&#249;',
        'uacute' => '&#250;',
        'ucirc' => '&#251;',
        'uuml' => '&#252;',
        'yacute' => '&#253;',
        'thorn' => '&#254;',
        'yuml' => '&#255;'
        );

      // Entity not found? Destroy it.
      return isset($_ent_table[$str_xml_data[1]]) ? $_ent_table[$str_xml_data[1]] : '';
    }

    /**
     * Static Method to load admin template
     *
     * @param   object  $obj_db
     * @return  void
     */
    public static function loadUserTemplate($obj_db,$uid)
    {
      global $sysconf;
      // load user template settings for override setting
      $_q = $obj_db->query("SELECT admin_template FROM user WHERE user_id=$uid AND (admin_template!=NULL OR admin_template !='')");
      if($_q->num_rows>0){
        $template_settings = unserialize($_q->fetch_row()[0]);
        foreach ($template_settings as $setting_name => $setting_value) {
          $sysconf['admin_template'][$setting_name] = $setting_value;
        }
      }
    }

    public static function dlCount($obj_db, $str_file_id, $str_member_id, $str_user_id)
    {
        if (!$obj_db->error) {
            // log table
            $_log_date = date('Y-m-d H:i:s');
            $_log_table = 'files_read';
            // filter input
            $str_log_type = $obj_db->escape_string(trim($str_file_id));
            $str_value_id = $obj_db->escape_string(trim($str_member_id));
            $str_user_id = $obj_db->escape_string(trim($str_user_id));
            // insert log data to database
            @$obj_db->query('INSERT INTO `'.$_log_table.'` (`filelog_id`,`file_id`,`date_read`,`member_id`,`user_id`,`client_ip`) 
            VALUES (NULL, \''.$str_file_id.'\', \''.$_log_date.'\', \''.$str_value_id.'\', \''.$str_user_id.'\', \''.ip().'\')');
        }
    }
}

================================================================================
File: VideoStream.php
================================================================================

<?php
/**
 * Description of VideoStream
 *
 * @author Rana
 * @modified by waris agung widodo
 * @link http://codesamplez.com/programming/php-html5-video-streaming-tutorial
 */

class VideoStream
{
  private $path = "";
  private $mime = "";
  private $stream = "";
  private $buffer = 102400;
  private $start = -1;
  private $end = -1;
  private $size = 0;
  private $repository;

  function __construct($repository, $filePath, $mimetype)
  {
    $this->repository = $repository;
    $this->path = $filePath;
    $this->mime = $mimetype;
  }

  /**
   * Open stream
   */
  private function open()
  {
    if (!($this->stream = $this->repository->readStream($this->path))) {
      die('Could not open stream for reading');
    }

  }

  /**
   * Set proper header to serve the video content
   */
  private function setHeader()
  {
    ob_get_clean();
    header("Content-Type: {$this->mime}");
    header("Cache-Control: max-age=2592000, public");
    header("Expires: " . gmdate('D, d M Y H:i:s', time() + 2592000) . ' GMT');
    header("Last-Modified: " . gmdate('D, d M Y H:i:s', @$this->repository->lastModified($this->path)) . ' GMT');
    $this->start = 0;
    $this->size = $this->repository->getSize($this->path);
    $this->end = $this->size - 1;
    header("Accept-Ranges: 0-" . $this->end);

    if (isset($_SERVER['HTTP_RANGE'])) {

      $c_start = $this->start;
      $c_end = $this->end;

      list(, $range) = explode('=', $_SERVER['HTTP_RANGE'], 2);
      if (strpos($range, ',') !== false) {
        header('HTTP/1.1 416 Requested Range Not Satisfiable');
        header("Content-Range: bytes $this->start-$this->end/$this->size");
        exit;
      }
      if ($range == '-') {
        $c_start = $this->size - substr($range, 1);
      } else {
        $range = explode('-', $range);
        $c_start = $range[0];

        $c_end = (isset($range[1]) && is_numeric($range[1])) ? $range[1] : $c_end;
      }
      $c_end = ($c_end > $this->end) ? $this->end : $c_end;
      if ($c_start > $c_end || $c_start > $this->size - 1 || $c_end >= $this->size) {
        header('HTTP/1.1 416 Requested Range Not Satisfiable');
        header("Content-Range: bytes $this->start-$this->end/$this->size");
        exit;
      }
      $this->start = $c_start;
      $this->end = $c_end;
      $length = $this->end - $this->start + 1;
      fseek($this->stream, $this->start);
      header('HTTP/1.1 206 Partial Content');
      header("Content-Length: " . $length);
      header("Content-Range: bytes $this->start-$this->end/" . $this->size);
    } else {
      header("Content-Length: " . $this->size);
    }

  }

  /**
   * close curretly opened stream
   */
  private function end()
  {
    fclose($this->stream);
    exit;
  }

  /**
   * perform the streaming of calculated range
   */
  private function stream()
  {
    $i = $this->start;
    set_time_limit(0);
    while (!feof($this->stream) && $i <= $this->end) {
      $bytesToRead = $this->buffer;
      if (($i + $bytesToRead) > $this->end) {
        $bytesToRead = $this->end - $i + 1;
      }
      $data = fread($this->stream, $bytesToRead);
      echo $data;
      flush();
      $i += $bytesToRead;
    }
  }

  /**
   * Start streaming video content
   */
  function start()
  {
    $this->open();
    $this->setHeader();
    $this->stream();
    $this->end();
  }
}
================================================================================
File: Visitor.php
================================================================================

<?php
/**
 * @compose by Drajat Hasan
 * @email drajathasan20@gmail.com
 * @create date 2022-09-18 19:39:17
 * @modify date 2023-01-26 15:04:20
 * @license GPLv3
 * @desc [description]
 */

namespace SLiMS;

class Visitor
{
    /**
     * Default visitor property
     *
     * @var array
     */
    protected array $allowedIp;
    protected string $visitTimeLimit;
    protected bool $accessAllow = false;
    protected array $data = [];
    protected bool $alreadyCheckIn = false;
    protected bool $member = false;
    protected bool $memberExpire = false;
    protected bool $institutionEmpty = false;
    protected string $error = '';
    protected string $image = 'person.png';
    protected bool $result = false;
    protected $opac;

    public function __construct(array $allowedIp, string $visitTimeLimit, Opac $opac)
    {
        $this->allowedIp = $allowedIp;
        $this->visitTimeLimit = $visitTimeLimit;
        $this->opac = $opac;
    }

    /**
     * Access check by ip
     *
     * @return Visitor
     */
    public function accessCheck()
    {
        foreach ($this->allowedIp as $ip) {
        // change wildcard
            $ip = preg_replace('@\*$@i', '.', $ip);
            if ($ip == ip() || $_SERVER['HTTP_HOST'] == 'localhost' || preg_match("@$ip@i", ip())) $this->accessAllow = true;
        }

        return $this;
    }

    /**
     * Record visitor counter
     *
     * @param int|string $memberId
     * @return Visitor
     */
    public function record($memberId)
    {
        $db = DB::getInstance();
        //DB::debug();

        try {
            $query = "SELECT member_id,member_name,member_image,inst_name, IF(TO_DAYS('".date('Y-m-d')."')>TO_DAYS(expire_date), 1, 0) AS is_expire FROM member WHERE member_id = ?";
            $statement = $db->prepare($query);
            $statement->execute([$memberId]);

            // room code check
            if (isset($_GET['room']) && strlen($_GET['room']) > 5) throw new \PDOException("Room code is not valid!");

            // Member
            if ($statement->rowCount() > 0)
            {
                $this->member = true;
                $data = $statement->fetch(\PDO::FETCH_NUM);
                
                // set image based on record data
                $this->image = $data[2]??'person.png';

                // set expire status
                if ($data[4] == 1) $this->memberExpire = true;
                
                // unset image and expire status
                unset($data[4]);
                unset($data[2]);

                $this->data = array_values($data);
                Plugins::getInstance()->execute('MEMBER_ON_VISIT', ['data' => $statement->fetch(\PDO::FETCH_ASSOC)]);
            }
            // Guest
            else
            {
                // institution check for guest
                if (empty(trim($_POST['institution'])))
                {
                    $this->institutionEmpty = true;
                    return $this;
                }

                // default non member photos
                $this->image = 'non_member.png';
                $this->data = [ null, $memberId,trim($_POST['institution'])];
                Plugins::getInstance()->execute('NON_MEMBER_ON_VISIT', ['data' => array_slice($this->data, 1)]);
            }

        
            $insertQuery = "INSERT INTO visitor_count (member_id, member_name, institution, room_code, checkin_date) VALUES (?,?,?,?,?)";
            $insertStatement = $db->prepare($insertQuery);

            if ($this->opac->enable_visitor_limitation && $this->alreadyCheckIn($memberId, $this->member))
            {
                $this->result = true;
                $this->alreadyCheckIn = true;
            }
            else
            {
                $this->result = $insertStatement->execute(array_merge($this->data, [$_GET['room']??null, date('Y-m-d H:i:s')]));
            }
        } catch (\PDOException $e) {
            // set error
            $this->error = $e->getMessage();
            $this->result = false;
        }

        return $this;
    }

    /**
     * Get last data to decide
     * ready checkin now or later
     *
     * @param int|string $memberIdOrName
     * @param boolean $isMember
     * @return bool
     */
    protected function alreadyCheckIn($memberIdOrName, $isMember = true)
    {
        $db = DB::getInstance();
        $criteria = 'member_name';
        if ($isMember) $criteria = 'member_id';
    
        $statement = $db->prepare('SELECT checkin_date FROM visitor_count WHERE '.$criteria.'=? ORDER BY checkin_date DESC LIMIT 1');
        $statement->execute([$memberIdOrName]);
        
        if ($statement->rowCount() > 0) {
            $data = $statement->fetchObject();
            $time = new \DateTime($data->checkin_date);
            $time->add(new \DateInterval('PT'.$this->visitTimeLimit.'M'));
            $timelimit = $time->format('Y-m-d H:i:s');
            $now = date('Y-m-d H:i:s');
            if ($now < $timelimit) {
                return true;
            }
        }
    
        return false;
    }

    public function isMember()
    {
        return $this->member;
    }

    public function isAlreadyCheckIn()
    {
        return $this->alreadyCheckIn;
    }

    public function isMemberExpire()
    {
        return $this->memberExpire;
    }

    public function isAccessAllow()
    {
        return $this->accessAllow;
    }

    public function isInstitutionEmpty()
    {
        return $this->institutionEmpty;
    }

    public function getResult()
    {
        return $this->result;
    }

    public function getData()
    {
        return array_merge($this->data, [$this->image]);
    }

    public function getError()
    {
        return $this->error;
    }
}
================================================================================
File: Url.php
================================================================================

<?php
/**
 * @author Drajat Hasan
 * @email drajathasan20@gmail.com
 * @create date 2022-12-17 07:14:29
 * @modify date 2023-01-12 11:34:58
 * @license GPLv3
 * @desc [description]
 */

namespace SLiMS;

class Url
{
    /**
     * If SLiMS behind reverse proxy
     * you must set this property to true
     *
     * @var boolean
     */
    public static $forceHttps = false;

    /**
     * This property is used to make
     * some magic method to generate result
     * based on availibility method
     *
     * Example:
     * - Url::getSlimsBaseUri(); 
     * * it will be return combination value from Url::getScheme(), Url::getDomain(), Url::getPath()
     * 
     * @var array
     */
    private static $scopes = [
        'slimsBaseUri' => ['scheme','domain', 'path'],
        'slimsFullUri' => ['scheme','domain','self','query']
    ];

    /**
     * Result from scope method process
     *
     * @var string
     */
    private string $scopeResult = '';

    /**
     * Retrieve server name from $_SERVER
     *
     * @return string
     */
    public static function getDomain(bool $strict = true)
    {
        if (!in_array(self::getPort(), [80,443]) && $strict) return $_SERVER['SERVER_NAME'] . ':' . self::getPort();
        return $_SERVER['SERVER_NAME'];
    }

    /**
     * Retrieve server port from $_SERVER
     *
     * @return string
     */
    public static function getPort()
    {
        return $_SERVER['SERVER_PORT'];
    }

    /**
     * Retrieve url scheme from from $_SERVER
     *
     * @return string
     */
    public static function getScheme()
    {
        $urlConfig = Config::getInstance()->get('url.force_https', false);
        return (self::$forceHttps || $urlConfig ? 'https' : $_SERVER['REQUEST_SCHEME']) . '://';
    }

    /**
     * Path is string after domain without filename
     *
     * @return string
     */
    public static function getPath($callBack = '')
    {
        if (is_callable($callBack)) return $callBack(SWB);
        return SWB;
    }

    /**
     * Path with file
     *
     * @return string
     */
    public static function getSelf($callBack = '')
    {
        if (is_callable($callBack)) return $callBack($_SERVER['PHP_SELF']);
        return $_SERVER['PHP_SELF'];
    }

    /**
     * $_GET is QueryString 
     *
     * @param string $callBack
     * @return string
     */
    public static function getQuery($callBack = '')
    {
        if (is_callable($callBack)) return $callBack($_SERVER['QUERY_STRING']);
        return '?' . $_SERVER['QUERY_STRING'];
    }

    /**
     * @return string
     */
    public static function getReferer()
    {
        return $_SERVER['HTTP_REFERER']??self::getSlimsFullUri();
    }

    /**
     * @param string $url
     * @return boolean
     */
    public static function isValid(string $url)
    {
        return filter_var($url, FILTER_VALIDATE_URL);
    }

    /**
     * Sometimes we must check inputed url
     * is our selfUrl (same domain) or not to protected our System
     * from RCE etc, via URL.
     *
     * @param string $url
     * @return boolean
     */
    public static function isSelf(string $url)
    {
        return self::parse($url)->getDomain() === self::getDomain($strict = false);
    }

    /**
     * Parsing URL with style!
     *
     * @param string $url
     * @return string|null
     */
    public static function parse(string $url)
    {
        return new Class($url) {
            private $url;
            private $methods = [
                'domain' => PHP_URL_HOST,
                'scheme' => PHP_URL_SCHEME,
                'user' => PHP_URL_USER,
                'password' => PHP_URL_PASS,
                'port' => PHP_URL_PORT,
                'path' => PHP_URL_PATH,
                'query' => PHP_URL_QUERY,
                'anchor' => PHP_URL_FRAGMENT
            ];

            public function __construct(string $url)
            {
                $this->url = $url;
            }

            public function __call($method, $arguments)
            {
                $method = strtolower(str_replace('get', '', $method));
                if (!isset($this->methods[$method])) return;
                
                return parse_url($this->url, $this->methods[$method]);
            }
        };
    }
    
    /**
     * Megic method to process
     * scopes property
     *
     * @param string $method
     * @param array $arguments
     * @return string
     */
    public static function __callStatic($method, $arguments)
    {
        if (php_sapi_name() === 'cli') return;
        
        $static = new Static;
        $method = lcfirst(str_replace('get', '', $method));
        if (!isset(self::$scopes[$method])) return;

        $url = '';
        foreach (self::$scopes[$method] as $mixedMethods) {
            $url .= self::{'get' . ucfirst($mixedMethods)}();
        }

        $static->scopeResult = trim($url . ($arguments[0]??''));
        return $static;
    }

    /**
     * @return string
     */
    public function decode()
    {
        return urldecode($this->scopeResult);
    }

    /**
     * @return string
     */
    public function encode()
    {
        return urlencode($this->scopeResult);
    }

    public function __toString()
    {
        return $this->scopeResult;
    }
}
================================================================================
Total files processed: 52

